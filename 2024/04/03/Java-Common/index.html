<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png">
  <link rel="mask-icon" href="/images/favicon.png" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blueapong.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Java 基础知识">
<meta property="og:type" content="article">
<meta property="og:title" content="Java基础">
<meta property="og:url" content="https://blueapong.github.io/2024/04/03/Java-Common/index.html">
<meta property="og:site_name" content="Apong&#39;s Blog">
<meta property="og:description" content="Java 基础知识">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blueapong.github.io/assets/image-20240403211146797.png">
<meta property="og:image" content="https://blueapong.github.io/assets/image-20240417190242743.png">
<meta property="og:image" content="https://blueapong.github.io/assets/image-20240423215603321.png">
<meta property="og:image" content="https://blueapong.github.io/assets/image-20240409104301471.png">
<meta property="og:image" content="https://blueapong.github.io/assets/image-20240409113233199.png">
<meta property="og:image" content="https://blueapong.github.io/assets/image-20240410233303176.png">
<meta property="og:image" content="https://blueapong.github.io/assets/image-20240410233957456.png">
<meta property="og:image" content="https://blueapong.github.io/assets/image-20240415131920186.png">
<meta property="og:image" content="https://blueapong.github.io/assets/image-20240415131957807.png">
<meta property="og:image" content="https://blueapong.github.io/assets/image-20240415134338932.png">
<meta property="article:published_time" content="2024-04-03T13:10:14.000Z">
<meta property="article:modified_time" content="2024-05-07T08:20:10.847Z">
<meta property="article:author" content="Apong">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blueapong.github.io/assets/image-20240403211146797.png">

<link rel="canonical" href="https://blueapong.github.io/2024/04/03/Java-Common/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Java基础 | Apong's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Apong's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">当你快坚持不住的时候，困难也快坚持不住了</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-首页">

    <a href="/" rel="section"><i class="fas fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-时间轴">

    <a href="/archives/" rel="section"><i class="fas fa-archive fa-fw"></i>时间轴</a>

  </li>
        <li class="menu-item menu-item-标签">

    <a href="/tags/" rel="section"><i class="fas fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-分类">

    <a href="/categories/" rel="section"><i class="fas fa-folder-open fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-每日总结">

    <a href="/categories/daily/" rel="section"><i class="fa fa-comment fa-fw"></i>每日总结</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blueapong.github.io/2024/04/03/Java-Common/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Apong">
      <meta itemprop="description" content="个人博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Apong's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java基础
        </h1>

        <div class="post-meta">
        <!--置顶功能-->
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-03 21:10:14" itemprop="dateCreated datePublished" datetime="2024-04-03T21:10:14+08:00">2024-04-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          
            <div class="post-description">Java 基础知识</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>Java是基于jvm虚拟机运行的跨平台语言</li>
<li>内置垃圾收集，不用考虑内存管理</li>
</ul>
<h3 id="JRE-和-JDK-介绍"><a href="#JRE-和-JDK-介绍" class="headerlink" title="JRE 和 JDK 介绍"></a>JRE 和 JDK 介绍</h3><p><strong>JRE：</strong> 用于运行 被编译为字节码class 的 Java 代码</p>
<p><strong>JDK：</strong>提供编译器，调试器等用于编写 Java 代码工具</p>
<blockquote>
<p>JRE: Java Runtime Environment</p>
<p>JDK: Java Development Kit</p>
</blockquote>
<p><strong>命令行常用命令</strong></p>
<ul>
<li>Java: 启动jvm虚拟机，运行编译为class字节码的代码。</li>
<li>Javac: 编译Java代码</li>
<li>Javadoc: 注释文档</li>
<li>jdb: 调试器</li>
</ul>
<p><strong>JDK与JRE的关系</strong></p>
<p>JDK &#x3D; JRE + 开发工具（Javac.exe等）</p>
<p>JRE &#x3D; JVM + Java API</p>
<blockquote>
<p>开发程序，需要用到JDk，因为要用Javac编译.Java文件</p>
<p>运行程序，只需要用到JRE，包含了Java API</p>
</blockquote>
<h3 id="名词介绍"><a href="#名词介绍" class="headerlink" title="名词介绍"></a>名词介绍</h3><ol>
<li>JSR规范: Java Specification Request</li>
<li>JCP组织: Java Community Process</li>
</ol>
<blockquote>
<p> JSR规范用于保证 Java 语言的规范性。</p>
<p> 凡是想给 Java 平台添加一个功能，比如说访问数据库的功能，需要先创建一个 JSR规范，定义好接口。</p>
<p> 各个数据库平台必须按照规范实现该接口，开发者就用同样的API访问各个数据库平台。</p>
</blockquote>
<ol start="5">
<li>RI: Reference Implementation</li>
<li>TCK: Technology Compability Kit</li>
<li>IDE: Integrated Development Environment</li>
</ol>
<h2 id="语法规则"><a href="#语法规则" class="headerlink" title="语法规则"></a>语法规则</h2><h3 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h3><ul>
<li>变量、类名 必须以英文字母开头，后接字母，数字和下划线的组合</li>
<li>**类名 **习惯首字母大写</li>
<li>如果单个源文件中有多个类，那么只能有一个类是public类，表示该文件的主入口</li>
</ul>
<blockquote>
<p>在java编程思想（第四版）一书中有这样3段话（6.4 类的访问权限）：</p>
<p>每个编译单元（文件）都只能有一个public类，使得每个编译单元都有单一的公共接口，用public类来表现。该接口可以按要求包含众多的 支持包访问权限 的类。</p>
<p>如果在某个编译单元内有一个以上的public类，就不知道使用哪个类导致无法编译。</p>
<p>同时允许编译单元内完全不带public类，这时候可能会并入其他编译单元编译，并且启动该文件时需手动指定数据来源（文件内存在的多个class）</p>
</blockquote>
<ul>
<li>源文件的名字必须与 public 类的类名相同</li>
<li>如果源文件中没有 public 类，则文件名可以是任意的</li>
</ul>
<h3 id="Hello-world分析"><a href="#Hello-world分析" class="headerlink" title="Hello world分析"></a>Hello world分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>main方法必须声明为静态方法，作为程序执行入口</li>
<li>在书写完Java文件后，使用Javac命令编译源文件</li>
</ul>
<blockquote>
<p>  javac -encoding&#x3D;utf-8 Hello.java</p>
<p>  如果文件编码非utf-8需使用encoding选项指定编码格式</p>
</blockquote>
<ul>
<li>运行代码</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java Hello <span class="comment"># 不需要带.class扩展名</span></span><br></pre></td></tr></table></figure>



<h3 id="主类"><a href="#主类" class="headerlink" title="主类"></a>主类</h3><p>Java程序的执行入口是main方法，&#x3D;&#x3D;包含有main方法的类称为主类&#x3D;&#x3D;</p>
<ul>
<li>一个Java源文件中可以有零个或多个主类。</li>
</ul>
<blockquote>
<p>  假如一个Java文件中有3个类，则在编译后会生成3个class文件</p>
<p>  只有包含main方法的主类才能使用Java命令运行</p>
</blockquote>
<ul>
<li>如果程序中包含主类，则称为Java应用程序。没有就叫做Java库程序，通常被用来让其他Java程序调用.</li>
</ul>
<h3 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h3><blockquote>
<p>从源代码到可执行代码，称为编译，也称为正向工程。</p>
<p>从可执行代码到源代码，称为反编译，也称为逆向工程。</p>
</blockquote>
<p>可用 javap命令实现反编译。</p>
<blockquote>
<p> 但并没有实现完全的反编译，只反编译到<strong>方法声明</strong>这一层，<u>无法反编译方法内的代码。</u></p>
</blockquote>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><ol>
<li>&#x2F;&#x2F;…          单行注释</li>
<li>&#x2F;* … *&#x2F;   多行注释</li>
<li>&#x2F;** … *&#x2F; 文档注释</li>
</ol>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ol>
<li>整数类型：byte，short，int，long</li>
<li>浮点数类型：float，double</li>
<li>字符类型：char</li>
<li>布尔类型： boolean</li>
</ol>
<blockquote>
<p>只有 true 和 false 两个值。</p>
<p>Java语言对布尔类型的存储并没有做规定。</p>
<p>理论上存储布尔类型只需要1 bit，但是通常 JVM 内部会把boolean表示为4字节整数&#x3D;&#x3D;。</p>
</blockquote>
<ol start="5">
<li><u>引用类型</u>，类似如C语言的指针。</li>
</ol>
<blockquote>
<p>在Java中，对象的实例化变量常为引用类型</p>
</blockquote>
<ol start="6">
<li><p>常量，使用final关键字声明。</p>
</li>
<li><p>var关键字</p>
<p>当类型名太长可以用var来进行声明，编译器会根据赋值语句来自动推断出该变量的类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>特殊规则</strong></p>
<ul>
<li>Java只定义了带符号的整型，即最高位为符号位。如，<u>int 最大值为 2^31-1</u></li>
<li>支持使用 _ 来连接数字，结果和原数一致。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">2_000</span>;</span><br><span class="line">System.out.println(x);</span><br><span class="line"><span class="comment">// 输出: 2000</span></span><br></pre></td></tr></table></figure>

<ul>
<li>0前缀表示八进制</li>
<li>0x前缀表示十六进制</li>
<li>0b前缀表示二进制</li>
<li>long类型需在数字后加上字母大小写 “L”</li>
<li><strong>定义float类型变量时末尾一定要加上字母大小写”F”，因为默认浮点数为双精度（double）类型</strong></li>
</ul>
<h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ol>
<li><p><code>/</code> 除法运算符</p>
</li>
<li><p><code>%</code> 求余运算符</p>
</li>
<li><p><code>&gt;&gt;</code> 右移运算符，无法移动符号位，即负数右移后还是负数</p>
</li>
<li><p><code>&gt;&gt;&gt;</code> 可以移动符号位的右移运算符</p>
</li>
<li><p><code>&lt;&lt;</code> 左移运算符同理，不存在向左移动符号位的运算符。</p>
<blockquote>
<p>对<code>byte</code>和<code>short</code>类型进行移位时，会首先转换为<code>int</code>再进行位移。</p>
</blockquote>
</li>
<li><p><code>++</code>，<code>--</code> 自增自减运算符只能用于 整型 和 浮点型 变量。</p>
</li>
<li><p><code>instanceof</code> 运算符，判断前者是否为后者的实例化对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">a <span class="keyword">instanceof</span> Integer; <span class="comment">//得到true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>位运算：<code>&amp;</code>，<code>|</code>，<code>~</code>，<code>^</code> 分别是与，或，非，异或运算。</p>
</li>
<li><p>逻辑运算符：<code>&amp;&amp;</code>，<code>||</code>，<code>！</code> 的操作元必须是boolean型数据。</p>
</li>
</ol>
<h3 id="整数运算"><a href="#整数运算" class="headerlink" title="整数运算"></a>整数运算</h3><ol>
<li>两个整数相除只能得到结果的整数部分（即舍弃余数得到整数）</li>
<li>整数的除法对于除数为0时运行时将报错，但编译不会报错。</li>
</ol>
<p><strong>溢出：</strong></p>
<p>整数由于存在范围限制，如果计算结果超出了范围，就会产生溢出，而溢出<em>不会出错</em>，却会得到一个奇怪的结果。（占据符号位，成为负数）</p>
<h3 id="浮点数运算"><a href="#浮点数运算" class="headerlink" title="浮点数运算"></a>浮点数运算</h3><p><strong>浮点数比较正确做法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">r</span> <span class="operator">=</span> Math.abs(x - y); <span class="comment">// 取绝对值</span></span><br><span class="line"><span class="comment">// 精度范围</span></span><br><span class="line"><span class="keyword">if</span> (r &lt; <span class="number">0.00001</span>) &#123;</span><br><span class="line">    <span class="comment">// 认为相等</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 不相等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<p>在一个复杂的四则运算中，两个整数的运算不会出现自动提升的情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">1.2</span> + <span class="number">24</span> / <span class="number">5</span>; <span class="comment">// d = 1.2 + 4</span></span><br></pre></td></tr></table></figure>

<p>原因：类型提升指的是最后赋值的时候，而算式中 24 &#x2F; 5 依然遵循整数运算规则。</p>
<p><strong>溢出：</strong></p>
<p>整数运算在除数为<code>0</code>时会报错，而浮点数运算在除数为<code>0</code>时，不会报错，但会返回几个特殊值：</p>
<ul>
<li><code>NaN</code>表示Not a Number</li>
<li><code>Infinity</code>表示无穷大</li>
<li><code>-Infinity</code>表示负无穷大</li>
</ul>
<h3 id="布尔运算"><a href="#布尔运算" class="headerlink" title="布尔运算"></a>布尔运算</h3><p><strong>短路运算：</strong>如果一个布尔运算的表达式能提前确定结果，则后续的计算不再执行，直接返回结果。</p>
<h3 id="运算精度"><a href="#运算精度" class="headerlink" title="运算精度"></a><strong>运算精度</strong></h3><ul>
<li>如果表达式中最高精度低于Int型整数，则按int精度计算</li>
</ul>
<blockquote>
<p>如 ‘a’ + ‘b’ &#x3D; int型数字</p>
<p>byte x&#x3D;7; 则执行表达式 ‘B’+x; 的结果是int型。</p>
</blockquote>
<ul>
<li>char型数据和整型数据运算结果的精度是int精度</li>
<li>Java允许把不超出取值范围的算术表达式赋值给对应类型，<strong>但是当算术表达式中含有变量的时候，只会检查变量的类型</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">z</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">2</span> + z; <span class="comment">// 将int转化为byte类型，报错</span></span><br></pre></td></tr></table></figure>

<p>类型遵循自动&#x3D;&#x3D;小转大&#x3D;&#x3D;，不支持&#x3D;&#x3D;大转小&#x3D;&#x3D;（可以强制转型）</p>
<p><strong>强制转型：</strong>超出范围的强制转型会得到错误的结果</p>
<p>如 int -&gt; short：<code>int</code>的两个高位字节直接被扔掉，仅保留了低位的两个字节</p>
<ul>
<li>较小类型和较大类型运算，结果会自动转化为较大类型。</li>
</ul>
<h2 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h2><p>Java 在内存中总是使用 Unicode 表示字符。</p>
<p>所以 char 类型占用两个字节。</p>
<p>可以用转义字符 <code>\u</code> + Unicode编码（十六进制）表示一个字符</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意是十六进制:</span></span><br><span class="line"><span class="type">char</span> <span class="variable">c3</span> <span class="operator">=</span> <span class="string">&#x27;\u0041&#x27;</span>; <span class="comment">// &#x27;A&#x27;，因为十六进制0041</span></span><br></pre></td></tr></table></figure>





<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><ul>
<li><code>\&quot;</code> 表示字符<code>&quot;</code></li>
<li><code>\&#39;</code> 表示字符<code>&#39;</code></li>
<li><code>\\</code> 表示字符<code>\</code></li>
<li><code>\n</code> 表示换行符</li>
<li><code>\r</code> 表示回车符</li>
<li><code>\t</code> 表示Tab</li>
<li><code>\u####</code> 表示一个Unicode编码的字符</li>
</ul>
<h3 id="不可变特性"><a href="#不可变特性" class="headerlink" title="不可变特性"></a>不可变特性</h3><p>字符串的内容是常量，不可改变，<strong>无法通过索引元素改变其值</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串变了吗？</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">s1 = <span class="string">&quot;world&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>字符串变量为引用类型</p>
<p>对其再次赋值，仅仅改变其指向的内存，原内容依旧存在。</p>
<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a><strong>功能</strong></h3><ol>
<li><p>可以使用 “+” 连接字符串</p>
<p>也可以用 “+” 连接字符串和其他数据类型，结果为字符串类型，被拼接的其他数据类型自身不会改变。</p>
</li>
<li><p>‘’’ … ‘’’ 三引号用于表示多行字符串，<strong>Java 13 以后</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">...........SELECT * FROM</span></span><br><span class="line"><span class="string">...........  users</span></span><br><span class="line"><span class="string">...........WHERE id &gt; 100</span></span><br><span class="line"><span class="string">...........ORDER BY name DESC</span></span><br><span class="line"><span class="string">...........&quot;&quot;&quot;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong>字符串s占据&#x3D;&#x3D;5行&#x3D;&#x3D;，因为在desc后面还有一个’\n’，如果不想要5行，可以直接把三引号写在结尾</p>
<p><strong>排版：</strong>最后会根据每行字符的相对位置来显示，共同的空格会被忽略，不规则排版则是以最短的空格为基准。</p>
</li>
<li><p>null 与 “” 的区别</p>
<p>null：一个引用空值。</p>
<p>“”：一个空的字符串，并不是空值。</p>
</li>
</ol>
<h3 id="在引用的使用"><a href="#在引用的使用" class="headerlink" title="== 在引用的使用"></a><code>==</code> 在引用的使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;HELLO&quot;</span>.toLowerCase();</span><br><span class="line">System.out.println(a == b); <span class="comment">// false</span></span><br><span class="line"><span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> a;</span><br><span class="line">System.out.println(a == c); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>原因是：<code>==</code> 用于判断两者是否为同一个引用，而不是判断内容是否一致。</p>
<p>判断字符串内容相等可以使用String类型的equals方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.equals(b)</span><br></pre></td></tr></table></figure>



<p><strong>低内存的特殊</strong></p>
<p>对于数值占用内存较少的情况，JVM 为了节省内存空间，在创建不同变量的时候指向的内存地址都是一样的。</p>
<p>如在128以内（不包括128）的数字</p>
<p>当有多个引用指向它们时，地址是一样的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">System.out.println(a == b); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>



<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>Java 中为了保存 C 语言开发的习惯，保留了<code>int arr[]</code> 和 <code>int[] arr</code> 声明数组类型的形式。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ol>
<li><p>new关键字</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>可以把 <code>int[]</code> 看做一整个数组类，new 出一个 int[] 的对象。</p>
</li>
<li><p>数组常量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>数组常量只能用于初始化，不能声明再赋值。</p>
</li>
</ol>
<h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ol>
<li><p>int[] 括号内不需要指定数字，在初始化的时候会自动推断。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &#123;&#125;内指定了数组元素，这里的3可以省略</span></span><br><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>

<p>如果没有指定，也没有指定数字（数组长度），那这个数组长度只有就是0。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个长度为 10 的数组，默认值为 0</span></span><br><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化后，数组的长度将不可改变，超出长度的索引会报异常。</p>
</li>
<li><p>创建的数组元素，如果没有赋予初值，会被赋予默认值</p>
<ul>
<li><p>数值型基本数据类型的默认值是 0</p>
</li>
<li><p>char 类型的默认值为 ‘\u0000’ </p>
</li>
<li><p>boolean 类型默认值为 false。</p>
</li>
</ul>
</li>
<li><p>通过访问 length 属性可以获得数组的长度。</p>
</li>
</ol>
<p><strong>注意：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    String[] names = &#123;<span class="string">&quot;ABC&quot;</span>, <span class="string">&quot;XYZ&quot;</span>, <span class="string">&quot;zoo&quot;</span>&#125;;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> names[<span class="number">1</span>];</span><br><span class="line">    names[<span class="number">1</span>] = <span class="string">&quot;cat&quot;</span>;</span><br><span class="line">    System.out.println(s);	<span class="comment">// s是被赋值为XYZ了，而不是names[1]的引用</span></span><br><span class="line">    System.out.println(Arrays.toString(names)); <span class="comment">// [ABC, cat, Zoo]</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>names[1] 是一个元素，不是引用。</p>
<h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><p><strong>初始化</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] ns = &#123;</span><br><span class="line">    &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;,</span><br><span class="line">    &#123; <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span> &#125;,</span><br><span class="line">    &#123; <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// new</span></span><br><span class="line"><span class="type">int</span>[][] ns = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;</span><br><span class="line">    &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;,</span><br><span class="line">    &#123; <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span> &#125;,</span><br><span class="line">    &#123; <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>打印多维数组</strong></p>
<p>打印多维数组可以使用<code>Arrays.deepToString()</code>；</p>
<h3 id="排序数组"><a href="#排序数组" class="headerlink" title="排序数组"></a>排序数组</h3><p>使用 Arrays 类的成员函数sort，可对数组进行排序</p>
<p><strong>默认小到大排列</strong>: Arrays.sort(arr);</p>
<p><strong>逆序</strong>: Arrays.sort(arr，Collections.reverseOrder())</p>
<p>sort 不能直接用于排列多维数组，&#x3D;&#x3D;使用什么可以排序多维数组呢&#x3D;&#x3D;</p>
<p>多维数组不需要排序，本质是处理每个一维数组。</p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ol>
<li>使用 Scanner 类初始化数组</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> n: arr)&#123;</span><br><span class="line">    n = scanner.nextInt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>随机打乱</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[index];</span><br><span class="line">    arr[index] = arr[arr.length - <span class="number">1</span>];</span><br><span class="line">    arr[arr.length - <span class="number">1</span>] = temp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line"> 		<span class="comment">// 随机位置与数组的最后一个元素交换</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (<span class="type">int</span>)(Math.random() * arr.length);</span><br><span class="line">        swap(arr, index);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Arrays.toString(arr));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：使用传递&#x3D;&#x3D;数组引用&#x3D;&#x3D;的方式才能在 不同作用域 交换数组内的值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Swap</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr，<span class="type">int</span> i，<span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String args[ ])</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>，<span class="number">2</span>&#125;;</span><br><span class="line">        Swap.swap(arr，<span class="number">0</span>，<span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr)); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>复制数组</p>
<ol>
<li><p>使用Java.util.Arrays的静态方法copyOf复制数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newArr = Arrays.copyOf(oldArr，neededLength);</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用System类中的静态方法arraycopy</p>
</li>
<li><p>使用clone方法复制数组</p>
</li>
</ol>
</li>
<li><p>for each循环</p>
<p>对于可迭代对象，使用for循环的”for each”形式会显得更加简洁</p>
<p>形式: for( varName :  arrayName) {…}</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span>，<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> n: arr)&#123;</span><br><span class="line">            System.out.println(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>这里的n，代表数组中的每个元素，而不是索引值</p>
</li>
<li><p>使用该方法遍历数组，无法控制访问顺序</p>
</li>
<li><p>for each循环还可用于List，Map等数据结构</p>
</li>
</ul>
</li>
<li><p>转 Stream 流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.stream(arr)</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h2><blockquote>
<p>在使用 java 命令执行 java 文件的时候</p>
</blockquote>
<p>可以传入 …String 类型的参数，由 public 类的入口函数 main 的 args 参数获取</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java Main &quot;123&quot; &quot;456&quot;</span><br><span class="line">// args: [&quot;123&quot;, &quot;456&quot;]</span><br></pre></td></tr></table></figure>





<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><blockquote>
<p> 通常使用Scanner类的实例对象来接受用户输入</p>
</blockquote>
<p>Scanner 类包含在 <code>java.util</code> 包内，需要先引入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">myScan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);	<span class="comment">// 传入输入流</span></span><br><span class="line">        <span class="comment">// 使用nextInt()获取整型数据</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> myScan.nextInt();</span><br><span class="line">        <span class="comment">// 使用nextLine()获取一行字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> myScan.nextLine();</span><br><span class="line">        <span class="comment">// next...等等</span></span><br><span class="line">        <span class="comment">// 使用完毕后，关闭输入流</span></span><br><span class="line">        myScan.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong> </p>
<p>nextInt 表示获取用户的下一个输入并转化为 int 类型，不是从输入中获取下一个 int 类型</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用户输入</span></span><br><span class="line">a 123</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">nextInt 会接收 a</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">并抛出 java.util.InputMismatchException 异常</span></span><br></pre></td></tr></table></figure>



<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>使用System.out输出流向输出端输出数据</p>
<ul>
<li>System.out.println() 输出一行</li>
<li>System.out.print()    直接输出</li>
<li>System.out.printf()   格式化输出</li>
</ul>
<p><strong>格式字符：</strong></p>
<p>%d 输出整型数据</p>
<p>%c 输出字符型数据</p>
<p>%f 输出浮点型数据</p>
<p>使用如%m.nd形式，可以控制输出的排版。</p>
<p>m：数字所占位数</p>
<p>n：小数位数</p>
<p><strong>注意</strong>：因为 % 表示占位符，所以连续两个 %% 才表示一个 % 字符本身。</p>
<h3 id="if判断"><a href="#if判断" class="headerlink" title="if判断"></a>if判断</h3><p>if 中表达式必须是 &#x3D;&#x3D;boolean类型&#x3D;&#x3D;，不能使用 0，1，null 代替</p>
<h3 id="switch新用法"><a href="#switch新用法" class="headerlink" title="switch新用法"></a>switch新用法</h3><p>switch 中 case 的条件必须是常量，枚举也可以。</p>
<p><strong>Java 12</strong> 开始，使用 <code>-&gt;</code> 符号可以<strong>无需break</strong>，直接指定执行单一路径，而不会继续向下执行其他语句</p>
<p>switch 将返回被执行 case 条件的结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">fruit</span> <span class="operator">=</span> <span class="string">&quot;apple&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">opt</span> <span class="operator">=</span> <span class="keyword">switch</span> (fruit) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;apple&quot;</span> -&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;pear&quot;</span> -&gt; <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">default</span> -&gt; <span class="number">0</span>;</span><br><span class="line">        &#125;;	<span class="comment">// 赋值语句后以 ; 结束</span></span><br><span class="line">        System.out.println(opt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果需要使用复杂的语句，可以使用花括号{}包裹，再通过yield关键字返回值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&quot;mango&quot;</span> -&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">code</span> <span class="operator">=</span> fruit.hashCode();</span><br><span class="line">    <span class="keyword">yield</span> code;		<span class="comment">// code作为该分支的返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>从 Java 13 开始允许使用yield返回值</p>
</blockquote>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><h4 id="while"><a href="#while" class="headerlink" title="while"></a><strong>while</strong></h4><p>while循环中的判断条件必须是一个 boolean 值，如 3 &gt; 2 的结果，而不能直接放一个数字</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">      <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123; <span class="comment">// 在C语言中可以直接写为 n</span></span><br><span class="line">         res += n--;</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(res);</span><br><span class="line">   &#125; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>对于循环条件判断，以及自增变量的处理，要特别注意边界条件。思考一下下面的代码为何没有获得正确结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">            n ++;</span><br><span class="line">            sum = sum + n;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum); <span class="comment">// 5151</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>n的边界是 0 -&gt; 100，当 n &#x3D; 100 时，会再次进入循环，n 变成了 101。</p>
<p>导致结果多加了一个 101，原本为 5050</p>
<p>将这个操作改为 for 循环则不会有这个问题，因为 自增变量 始终作为后置条件在循环体内执行完之后。</p>
<h4 id="do-while"><a href="#do-while" class="headerlink" title="do while"></a>do while</h4><p>改写 while 循环的 1 到 100 求和</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            sum = sum + n;</span><br><span class="line">            n ++;</span><br><span class="line">        &#125; <span class="keyword">while</span> (n &lt;= <span class="number">100</span>);</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4><p>改写 1 到 100 求和</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">100</span>; i++) &#123;</span><br><span class="line">            sum = sum + i;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>计数器定义位置</strong></p>
<p>如果变量 <code>i</code> 定义在 <code>for</code> 循环外：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int[] ns = &#123; 1, 4, 9, 16, 25 &#125;;</span><br><span class="line">int i;</span><br><span class="line">for (i=0; i&lt;ns.length; i++) &#123;</span><br><span class="line">    System.out.println(ns[i]);</span><br><span class="line">&#125;</span><br><span class="line">// 仍然可以使用i</span><br><span class="line">int n = i;</span><br></pre></td></tr></table></figure>

<p>破坏了<strong>变量应该把访问范围缩到最小</strong>的原则。</p>
<h4 id="for-each"><a href="#for-each" class="headerlink" title="for each"></a>for each</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] ns = &#123; <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span> &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> n : ns) &#123;</span><br><span class="line">            System.out.println(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和<code>for</code>循环相比，<code>for each</code>循环的变量n不再是计数器，而是直接对应到数组的每个元素。</p>
<p>除了数组外，<code>for each</code>循环能够遍历所有“可迭代”的数据类型，包括后面会介绍的<code>List</code>、<code>Map</code>等。</p>
<h4 id="break-和-continue"><a href="#break-和-continue" class="headerlink" title="break 和 continue"></a>break 和 continue</h4><p>break：跳出最近一层循环，多层循环只能跳出一层</p>
<p>continue：跳出本次循环，执行下一个符合条件的循环</p>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h5 id="0-特点"><a href="#0-特点" class="headerlink" title="0. 特点"></a>0. 特点</h5><ul>
<li>封装性</li>
<li>继承</li>
<li>多态</li>
</ul>
<h5 id="1-字段"><a href="#1-字段" class="headerlink" title="1. 字段"></a>1. 字段</h5><blockquote>
<p>字段即成员变量</p>
</blockquote>
<p>​	没有初始化的引用字段，默认为null值; 其他类型的也是默认值，如Int类型是0，boolean是false;</p>
<h6 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h6><ul>
<li>静态方法可以通过对应类的空对象访问</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="literal">null</span>;	<span class="comment">// 定义Test类空对象</span></span><br><span class="line">        test.f1();			<span class="comment">// 使用空对象访问静态方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>:</p>
<ul>
<li>在&#x3D;&#x3D;成员函数内部&#x3D;&#x3D;声明的局部变量不会自动初始化，需要初始化后才可引用</li>
<li>无论成员变量，和成员函数声明定义的顺序如何，&#x3D;&#x3D;成员变量是先与成员函数生成的&#x3D;&#x3D;，所以可以出现以下这种情况</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> m; <span class="comment">// m被定义为成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>不能在成员函数中定义<strong>与参数重名</strong>的变量</li>
<li>可以在成员函数中定义与成员变量同名的变量，定义的局部变量会覆盖成员变量。</li>
</ul>
<h5 id="2-构造函数"><a href="#2-构造函数" class="headerlink" title="2. 构造函数"></a>2. 构造函数</h5><blockquote>
<p>构造函数支持重载(Overload)</p>
</blockquote>
<p>​	Java中可以通过<strong>this引用</strong>可以在一个构造函数中调用其他构造函数，<u>但是C++不行</u>，因为可以有默认参数， 所以就没有构造函数的相互调用了，但是C++可以调用父类的构造函数</p>
<h5 id="3-this关键字"><a href="#3-this关键字" class="headerlink" title="3. this关键字"></a>3. this关键字</h5><ul>
<li>this是Java的一个关键字，表示某个对象<ul>
<li>在构造方法中，代表该构造方法所创建的对象。</li>
<li>实例方法中，代表正在调用该方法的当前对象。</li>
</ul>
</li>
<li>this不能用于类成员变量和类方法。</li>
<li>可用this调用被隐藏的成员变量</li>
</ul>
<blockquote>
<p>如：当局部变量和成员变量重名时，可以使用this.成员变量访问到它</p>
</blockquote>
<h5 id="4-包"><a href="#4-包" class="headerlink" title="4. 包"></a>4. 包</h5><p>包是一种用来管理类的机制，可以有效地区分名字相同的类</p>
<p><strong>使用方法</strong>：</p>
<ul>
<li>用package 包名;语句声明该源文件所在的包</li>
</ul>
<p><strong>注意事项</strong>：</p>
<ul>
<li>该语句必须作为源文件的第一行语句。</li>
<li>建议用域名反写的方式建包（目前还没有看懂）。</li>
<li>包的名字，必须为源文件所在路径，不能随意起名。</li>
</ul>
<blockquote>
<p>如tom&#x2F;jiafei&#x2F;路径下有Test.Java文件，则该文件的包名可以为tom.jiafei</p>
</blockquote>
<p><strong>运行方式</strong>：</p>
<p>​	如果主类的包名是tom.jiafei，就<strong>必须到</strong>tom\jiafei的上一层（即tom的父目录）目录中去运行主类。</p>
<blockquote>
<p>假设tom\jiafei的上一层目录是1000，那么必须用如下格式来运行： C:\1000&gt; Java tom.jiafei.主类名</p>
</blockquote>
<p><strong>import语句</strong></p>
<p>既然有包的建立，那必然有引用包。</p>
<blockquote>
<p>系统会自动导入Java.lang包中所有的类。</p>
</blockquote>
<p>通过import语句，可以使该源文件能够调用其他包中的类。</p>
<p>&#x3D;&#x3D;父包和子包没有关系，包含的类也没有关系&#x3D;&#x3D;</p>
<h5 id="5-修饰符"><a href="#5-修饰符" class="headerlink" title="5. 修饰符"></a>5. 修饰符</h5><p>Java使用四种修饰符，来限制类中的成员变量和成员函数被访问的权限</p>
<ul>
<li>public类。 该类成员可以被所有类访问</li>
<li>protected类。 该类成员只能被同一文件，同一包内的类或子类访问。</li>
<li>没有修饰符的称为default类。 只能被同一文件，和同一包内的类访问。</li>
</ul>
<blockquote>
<p>子类不能访问指：其他包通过引用该包，然后继承该包中的某一个类，该子类无法访问父类的成员。</p>
</blockquote>
<p>&#x3D;&#x3D;事实证明即使是default类，只要其子类在同一个文件或包，依旧能够访问父类成员。&#x3D;&#x3D;</p>
<ul>
<li>private类。 该类成员只能被自己访问。</li>
</ul>
<h5 id="6-包装类"><a href="#6-包装类" class="headerlink" title="6. 包装类"></a>6. 包装类</h5><p>为了方便基本数据类型的使用，Java提供了基本数据类型的相关类，实现了对其的封装。</p>
<p>如：Integer,Character,Byte等类。</p>
<p>构造方法如：Integer a &#x3D; new Integer(2);</p>
<p>返回类中包含的值：a.value();</p>
<h5 id="7-上转型对象"><a href="#7-上转型对象" class="headerlink" title="7. 上转型对象"></a>7. 上转型对象</h5><p>将子类的对象传递给父类引用，称为上转型对象。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Father</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line"><span class="comment">// 第二种情况</span></span><br><span class="line">Father f;</span><br><span class="line"><span class="type">Son</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">f = s;</span><br></pre></td></tr></table></figure>

<p><strong>使用</strong>：</p>
<ul>
<li>不可以使用子类新增的成员（变量、函数）</li>
<li>可以使用子类继承和重写的方法</li>
<li>可以使用子类隐藏的成员变量</li>
</ul>
<blockquote>
<p>如：父类有int a变量，而子类定义了同名变量double a，而上转型对象调用的是父类的a变量。</p>
</blockquote>
<p>&#x3D;&#x3D;不支持向下转型，会报出ClassCastException&#x3D;&#x3D;</p>
<p><strong>多态</strong></p>
<p>多态就是指父类的某个方法被子类重写后产生自己的功能行为，各个子类都不同。</p>
<h5 id="8-抽象类"><a href="#8-抽象类" class="headerlink" title="8. 抽象类"></a>8. 抽象类</h5><p>用于定义共有的属性（变量、方法），合理地使用抽象类，可以写出易维护、易扩展的程序。</p>
<p>&#x3D;&#x3D;抽象类可以没有abstract方法&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;不可以使用static修饰抽象类&#x3D;&#x3D;，因为抽象类没有实例吧。</p>
<p><strong>使用</strong>：</p>
<ul>
<li>具备一般类的基本能力，可以有字段、构造方法；<strong>但不能实例化abstract类对象</strong></li>
<li>不能用final修饰抽象类，因为定义抽象类就是要用来继承的。</li>
<li>抽象类的非抽象子类必须实现抽象父类的所有抽象方法。</li>
</ul>
<p><strong>缺点</strong>：&#x3D;&#x3D;Java中只能继承一个类，所以抽象类并不完善&#x3D;&#x3D;</p>
<h5 id="9-接口"><a href="#9-接口" class="headerlink" title="9. 接口"></a>9. 接口</h5><p>为了弥补只能继承一个类的缺陷，Java定义了接口概念。</p>
<p>接口和抽象类差不多，但是比抽象类更加标准化。接口还有一个优势：&#x3D;&#x3D;允许非同一父类的子类拥有相同名称的方法。&#x3D;&#x3D;</p>
<p><strong>使用</strong>：</p>
<p>通过interface 接口名{}，与定义一个类差不多的形式定义接口；</p>
<ul>
<li>接口中不存在变量。&#x3D;&#x3D;声明常量时必须初始化，不具有默认值&#x3D;&#x3D;</li>
</ul>
<p>类似int MAX &#x3D; 100;</p>
<p>等价于：(public static final) int MAX &#x3D; 100; 	括号内为缺省类型，即可以省略不写。</p>
<ul>
<li>接口中所有的方法默认都是抽象方法</li>
</ul>
<p>如void f(); &#x3D;&gt; 等价于 public abstract void f() {};</p>
<ul>
<li>可以用default关键字定义实例方法（JDK8后），必须是public方法，可省略不写。</li>
</ul>
<blockquote>
<p>default方法与普通类的实例方法一致，该接口的实现类可以选择是否重写，重写需去掉default关键字。</p>
</blockquote>
<ul>
<li>允许使用static关键字定义静态方法（JDK8后）</li>
<li>允许使用private关键字定义私有方法，接口的实现类无法访问private方法，目的是配合default方法使用实现一些算法的封装。（JDK9）</li>
</ul>
<p><strong>注意</strong>：</p>
<ul>
<li>接口没有构造函数</li>
<li>所有字段除了private， 其他的访问权限都是public</li>
</ul>
<p><strong>实现接口</strong></p>
<p>通过implements关键字可以实现一个或多个接口，接口之间用逗号隔开。</p>
<ul>
<li>非抽象类实现接口，必须重写所有抽象方法。</li>
<li>接口的实现了不拥有接口的<strong>静态</strong>和私有方法。</li>
<li>实现接口方法的访问权限必须是public， <strong>允许重载接口方法，并修改访问权限</strong></li>
</ul>
<blockquote>
<p>如接口有void cry(); 子类可以定义protected void cry(int m)方法。</p>
</blockquote>
<p><strong>接口回调</strong></p>
<p>将接口的实现类对象的引用赋值给接口变量，再通过接口变量调用实现类实现的方法，称为接口回调。</p>
<p>实际过程是：在接口变量调用方法时，根据地址通知对应的对象去调用对应的方法。</p>
<p><strong>接口与抽象类的比较</strong></p>
<ul>
<li>接口和abstract类的比较如下：<ul>
<li>abstract类和接口都可以有abstract方法。</li>
<li>接口中只可以有常量，不能有变量；而abstract类中即可以有常量也可以有变量。</li>
<li>abstract类中也可以有非abstract方法，接口不可以(JDK 7及以前的版本）。</li>
</ul>
</li>
</ul>
<h5 id="10-Lambada表达式（JDK8后）"><a href="#10-Lambada表达式（JDK8后）" class="headerlink" title="10. Lambada表达式（JDK8后）"></a>10. Lambada表达式（JDK8后）</h5><p>Lambada表达式，又称为匿名表达式；常用在单接口（只具有一个abstract方法的接口）的接口回调中。</p>
<p>形式：（参数列表） -&gt; {方法体}</p>
<p>Lambada表达式的值就是该方法的入口地址，可以将其赋给接口变量来实现单接口，用于接口回调。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        A obj;</span><br><span class="line">        obj = () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">        &#125;;			<span class="comment">// 分号不要忘记了</span></span><br><span class="line">        obj.f();	<span class="comment">// 输出 ok</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="11-内部类"><a href="#11-内部类" class="headerlink" title="11. 内部类"></a>11. 内部类</h5><p>在一个类中，再定义一个类，那么该类就叫做内部类。</p>
<blockquote>
<p>为了代码的易维护，和相关性，可以将需要用到的类写在另一个类中作为内部类。</p>
<p>对于拥有内部类的类，在编译后将生成多个class文件。</p>
</blockquote>
<p><strong>使用</strong>：</p>
<ul>
<li>外嵌类可以声明内部类对象</li>
<li>内部类不能定义静态成员。&#x3D;&#x3D;为什么内部类可以用static声明&#x3D;&#x3D;。</li>
</ul>
<h5 id="12-匿名类"><a href="#12-匿名类" class="headerlink" title="12. 匿名类"></a>12. 匿名类</h5><blockquote>
<p>有时候为了方便可以通过类体直接创建一个子类</p>
</blockquote>
<ul>
<li>可以是继承父类的子类</li>
<li>也可以是实现接口的子类</li>
<li>使用Lambada表达式做到的接口回调也是匿名类。</li>
</ul>
<p>形式：</p>
<p>new 父类构造方法 &#x2F; 接口名() {类体}</p>
<p>&#x3D;&#x3D;匿名类属于内部类&#x3D;&#x3D;</p>
<h5 id="13-异常类"><a href="#13-异常类" class="headerlink" title="13. 异常类"></a>13. 异常类</h5><p>用于提供程序运行出现错误的信息，及错误的捕捉</p>
<p>异常对象可以调用如下方法得到&#x2F;输出异常相关的信息</p>
<ul>
<li>public String getMessage();</li>
<li>public void printStackTrace();</li>
<li>public String toString();</li>
</ul>
<p><strong>捕捉异常</strong></p>
<p>Java使用try~catch~finally（可选）来捕捉处理异常，允许存在多条catch语句</p>
<p>&#x3D;&#x3D;多条catch语句可以分别处理异常，不是匹配一个就结束&#x3D;&#x3D;</p>
<p>注意：子类异常必须放在父类异常前面，因为父类异常包含子类。</p>
<p><strong>抛出异常</strong></p>
<p>在方法体内使用throw抛出异常对象: throw new Exception();</p>
<p>使用throws声明异常，声明该方法可能会出现的异常</p>
<h2 id="核心类"><a href="#核心类" class="headerlink" title="核心类"></a>核心类</h2><h5 id="1-String类"><a href="#1-String类" class="headerlink" title="1. String类"></a>1. String类</h5><p>String类不可继承。</p>
<p>String常量：用双引号括起来的字符序列。Java把String常量放在常量池内。</p>
<p>&#x3D;&#x3D;重点&#x3D;&#x3D;</p>
<ul>
<li>将一个String常量赋给变量时，如果内容相同的String常量在常量池里已经存在，则不会创建新的字符串常量，而是将已存在的字符串常量引用赋给该变量。</li>
</ul>
<blockquote>
<p>即：String a &#x3D; “hello”; String b &#x3D; “hello”;</p>
<p>a &#x3D;&#x3D; b &#x2F;&#x2F;输出true</p>
</blockquote>
<ul>
<li><p>而使用new关键字创建字符串对象，是在堆内申请一份新内存，因此内容相同但不是同一个引用。</p>
</li>
<li><p>String类对象在生成后，无法改变其中的值。</p>
</li>
</ul>
<blockquote>
<p>String a &#x3D; “hello”;</p>
<p>a[1] &#x3D; ‘a’;	&#x2F;&#x2F; 错误，并且只能通过charAt(index)方法访问。</p>
</blockquote>
<ul>
<li>通过+号可以使字符串进行并置运算。</li>
</ul>
<p>常量并置运算后依旧是常量，而一旦变量参与并置运算，就会重新在堆中创建新的String对象。</p>
<p><strong>与第一点共同思考</strong></p>
<blockquote>
<p>String str1 &#x3D; “helloJava”;</p>
<p>String str2 &#x3D; “hello” + “Java”;</p>
<p>str1 &#x3D;&#x3D; str2 	&#x2F;&#x2F; 得到true，运算后依旧是常量</p>
<p>String a &#x3D; “hello”，b &#x3D; “Java”；</p>
<p>String c &#x3D; a + b;</p>
<p>c &#x3D;&#x3D; str1; 		&#x2F;&#x2F; 得到false，因为a，b为String类变量，所以在并置运算后得到新的字符串对象。</p>
</blockquote>
<p><strong>与字符数组</strong></p>
<p>可以使用字符数组创建String类对象，也可限制范围；</p>
<ul>
<li>String(char a[],int startIndex,int count)；</li>
</ul>
<p>也可以String转字符数组</p>
<ul>
<li>public void getChars(int start,int end,char c[],int offset ) </li>
<li>public char[] toCharArray()</li>
</ul>
<p><strong>与字节数组</strong></p>
<p>String转字节数组</p>
<ul>
<li>public byte[] getBytes()。使用平台默认的字符编码。 </li>
<li>public byte[] getBytes(String charsetName)。指定字符编码</li>
</ul>
<p>&#x3D;&#x3D;GB2312编码中，一个汉字占两个字节。&#x3D;&#x3D;</p>
<h5 id="2-正则表达式"><a href="#2-正则表达式" class="headerlink" title="2. 正则表达式"></a>2. 正则表达式</h5><h5 id="3-Class类与反射"><a href="#3-Class类与反射" class="headerlink" title="3. Class类与反射"></a>3. Class类与反射</h5><blockquote>
<p>​	任何类默认有一个public的静态的(static)Class对象，该对象的名字是class（用关键字做了名字，属于Java系统特权），该对象封装当前类的有关信息（即类型的信息），如该类有哪些构造方法，哪些成员变量，哪些方法等。也可以让类的对象调用getClass()方法（从Java.lang.Object类继承的方法）返回这个Class对象：class。</p>
</blockquote>
<p>Class对象(class)调用方法可以获取当前类的有关信息，比如，类的名字、类中的方法名称、成员变量的名称等等，这一机制也称为Java反射。</p>
<p><strong>用Class类和反射机制创建新对象</strong>（有点问题）</p>
<ol>
<li>使用用Class类的类方法forName(String className)返回对应类的Class对象。</li>
<li>再让这个Class对象调用getDeclaredConstructor()方法得到 对应类 的 无参数的<strong>构造方法</strong>对象。</li>
<li>然后构造方法对象再调用newInstance()返回该类的对象</li>
</ol>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>通过代码块捕获 异常class类，来知道发生了什么错误，并进行下一步处理。</p>
<h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>类的继承关系如下：</p>
<p><img src="/assets/image-20240403211146797.png" alt="image-20240403211146797"></p>
<p><code>Error</code>表示严重的错误，程序对此一般无能为力</p>
<ul>
<li><code>OutOfMemoryError</code>：内存耗尽</li>
<li><code>NoClassDefFoundError</code>：无法加载某个Class</li>
<li><code>StackOverflowError</code>：栈溢出</li>
</ul>
<p>而<code>Exception</code>则是运行时的错误，它可以被捕获并处理。</p>
<p>某些异常是应用程序逻辑处理的一部分，应该捕获并处理。例如：</p>
<ul>
<li><code>NumberFormatException</code>：数值类型的格式错误</li>
<li><code>FileNotFoundException</code>：未找到文件</li>
<li><code>SocketException</code>：读取网络失败</li>
</ul>
<p><strong>Java规定（编辑器也会提示）：</strong></p>
<ol>
<li><p>必须捕获的异常（Checked Exception），包括<code>Exception</code>及其子类，但不包括<code>RuntimeException</code>及其子类。</p>
<p>Checked Exception：需要检查的异常</p>
<p>不包括在内的异常，可以由开发者自由选择是否捕获。</p>
<p>如 <code>NullPointerException</code> ，你可以自己选择是否捕获并处理该异常。</p>
<p>而 <code>IOException</code>，在 Java 环境中是必须要声明捕获的。 </p>
</li>
<li><p>不需要捕获的异常，包括<code>Error</code>及其子类，<code>RuntimeException</code>及其子类。</p>
</li>
</ol>
<p><strong>异常处理建议：</strong>异常不应该在产生的代码层级 <strong>空捕获不处理</strong>，即使真的什么也做不了，也应该把异常记录下来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">byte</span>[] toGBK(String s) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">        <span class="comment">// 先记下来再说:</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有异常都可以调用<code>printStackTrace()</code>方法打印异常栈（先进后出）。</p>
<p>因为是栈，所以异常栈最下面才是触发异常的源头。</p>
<h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><p><strong>catch 语句</strong></p>
<p>可以使用多个 <code>catch</code> 语句。</p>
<p>从上到下匹配对应异常类，但是只有一个能被执行。</p>
<p>因此顺序应保持：子类必须写在前面。</p>
<p>因为如果父类（范围大的异常）写在子类前面，就捕获不到子类了，等于没写。</p>
<p><strong>finally 语句</strong></p>
<p>无论异常是否发生，被捕获到，finally中的语句都会被执行。</p>
<p>特点：</p>
<ol>
<li>非必须</li>
<li>总是在 try ~ catch 之后，最后被执行</li>
</ol>
<p>finally 用于保证一些代码必须被执行，防止因为异常跳出了代码原本的运行逻辑。</p>
<p><strong>合并处理异常</strong></p>
<p>每个异常类应该是在不同 bit 位上，因此可以用 <code>|</code> 或运算符联合多个异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process1();</span><br><span class="line">        process2();</span><br><span class="line">        process3();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException | NumberFormatException e) &#123; <span class="comment">// IOException或NumberFormatException</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Bad input&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Unknown error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>完整示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process1();</span><br><span class="line">        process2();</span><br><span class="line">        process3();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bad encoding&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;IO error&quot;</span>);</span><br><span class="line">    <span class="comment">// 常用于保证同步读写操作流的关闭</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;END&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h3><p><strong>异常传播</strong></p>
<p>当某个方法抛出异常后，如果当前方法没有捕获异常，异常就会被抛到上层调用方法，直到被捕获为止。</p>
<p><strong>抛出异常</strong></p>
<ol>
<li>创建某个 <code>Exception</code> 的实例</li>
<li>用 <code>throw</code> 语句抛出</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">process2</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">NullPointerException</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大部分情况下会合并写成一行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">process2</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="异常“转换”"><a href="#异常“转换”" class="headerlink" title="异常“转换”"></a><strong>异常“转换”</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">process1</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process2();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">process2</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>process1在捕获到process2的异常后，抛出了另一个异常 <code>IllegalArgumentException</code>。</p>
<p>那么原异常信息就会丢失，“转换”成了另一个异常暴露给外部</p>
<p>如果想要在抛出新的异常下，同时保留原始的异常信息，就需要把原始异常的实例作为新的异常构建参数传入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">process1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process2();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">        <span class="comment">// 传入原异常实例</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">process2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样在输出的异常栈信息中，就会包括原始的异常信息。</p>
<p><strong>捕获到异常并再次抛出时，一定要留住原始异常，否则很难定位第一案发现场！</strong></p>
<h3 id="异常屏蔽"><a href="#异常屏蔽" class="headerlink" title="异常屏蔽"></a>异常屏蔽</h3><p><strong>finally 与 catch 的执行顺序</strong></p>
<p>finally 语句的内容是一定会执行的，相比于 catch 语句的执行顺序呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Integer.parseInt(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;catched&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;finally&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">catched</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.RuntimeException: java.lang.NumberFormatException: For input string: <span class="string">&quot;abc&quot;</span></span><br><span class="line">    at Main.main(Main.java:<span class="number">8</span>)</span><br><span class="line">Caused by: java.lang.NumberFormatException: For input string: <span class="string">&quot;abc&quot;</span></span><br><span class="line">    at ...</span><br></pre></td></tr></table></figure>

<p>第一行打印了<code>catched</code>，第二行打印了<code>finally</code>。</p>
<p>说明先进入 catch 语句，再执行 finally 语句，并且 catch 中抛出的异常不会影响到 finally 执行</p>
<p><strong>异常屏蔽</strong></p>
<p>如果在执行 <code>finally</code> 语句时抛出异常，那么，<code>catch</code> 语句的异常还能否继续抛出？</p>
<p>答案：catch 中抛出的异常最终会被 finally 中抛出的异常“覆盖”。</p>
<p>本质猜测：</p>
<p>在 JVM 中有一个全局异常处理Handler，在执行目标类中的代码时，虽然 catch 先抛出了异常，但是要等 finally 执行完，handler 中的 catch 才对异常进行捕获，这时候 finally 中抛出的异常也会进入异常栈，覆盖原始异常，类似上述的异常“转换”，从而丢失原来的异常。</p>
<blockquote>
<p>catch 中只能抛出一个异常，没有被抛出的异常称为“被屏蔽”的异常（Suppressed Exception）。</p>
</blockquote>
<p><strong>如何获取所有的异常信息</strong></p>
<p>方法：先保存原始异常实例，然后调用 <code>Throwable.addSuppressed()</code>，把原始异常添加进来，最后在 <code>finally </code> 抛出。</p>
<p>为什么要在 finally 中抛出？</p>
<p>因为 catch 抛出一条异常就结束了，只能存好这一条异常，留在 finally 中添加了</p>
<h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>在项目开发中，为了方便处理不同业务的异常，会自定义异常，以便能精准的捕获。</p>
<p>自定义异常通常继承 <code>RuntimeException</code>。</p>
<p>这一类异常是 JVM 非强制捕获的异常，具有更好的扩展性，并且能自由的空值。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaseException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BaseException</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BaseException</span><span class="params">(String message, Throwable cause)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message, cause);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BaseException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BaseException</span><span class="params">(Throwable cause)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基本都是原样照抄<code>RuntimeException</code>。这样，抛出异常的时候，就可以选择合适的构造方法。通过IDE可以根据父类快速生成子类的构造方法。</p>
<p>真正的目的是区分不同的异常类。</p>
<h3 id="NPE异常"><a href="#NPE异常" class="headerlink" title="NPE异常"></a>NPE异常</h3><p>NPE 即 <code>NullPointerException</code> 空指针异常。</p>
<p>避免NPE的好习惯</p>
<ol>
<li><p>成员变量在定义时就初始化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>返回空字符串<code>&quot;&quot;</code>、空数组而不是<code>null</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] readLinesFromFile(String file) &#123;</span><br><span class="line">    <span class="keyword">if</span> (getFileSize(file) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 返回空数组而不是null:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Java 8</strong> 后，提供了 <code>Optional&lt;T&gt;</code> 工具类用于判断</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Optional&lt;String&gt; <span class="title function_">readFromFile</span><span class="params">(String file)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!fileExist(file)) &#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.empty();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过调用 Optional.isPresent() 可以判断结果</p>
</li>
</ol>
<p><strong>定位 NPE</strong></p>
<p>在执行类似如下代码时，Java 默认是不会指出哪个对象是null，只会暴露出目标文件所在行数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.b.c.x()</span><br></pre></td></tr></table></figure>

<p>Java 14 以后，只要开启如下 JVM 参数就可以检测出具体的 null 对象。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+ShowCodeDetailsInExceptionMessages Main.java</span><br></pre></td></tr></table></figure>

<p>本质猜测：开启后，每一步对象的嵌套调用都会被记录，当出现错误的时候就显示当前层级，可能会降低性能。</p>
<h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><p>使用 <code>assert</code> 关键字来实现断言。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> x &gt;= <span class="number">0</span> : <span class="string">&quot;x must &gt;= 0&quot;</span>;</span><br></pre></td></tr></table></figure>

<p><code>:</code> 冒号后添加可选的断言消息。</p>
<p>如果断言判断失败，会抛出 <code>AssertionError</code> 异常结束程序，并带上断言消息。</p>
<p>断言常用于测试，只要错误就代表测试失败。</p>
<p>JVM 默认关闭断言指令，即遇到<code>assert</code>语句就自动忽略了，不执行。</p>
<p>需要开启 <code>-enableassertions</code> （可简写为<code>-ea</code>）参数启用断言。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java -ea Main.java</span><br><span class="line">Exception <span class="keyword">in</span> thread <span class="string">&quot;main&quot;</span> java.lang.AssertionError</span><br><span class="line">	at Main.main(Main.java:5)</span><br></pre></td></tr></table></figure>

<p>还可以对特定的类启用断言<code> -ea:com.itranswarp.sample.Main</code></p>
<p>或者特定的包 <code>-ea:com.itranswarp.sample...</code>，用结尾的 … 表示这是一个包。</p>
<h3 id="日志输出"><a href="#日志输出" class="headerlink" title="日志输出"></a>日志输出</h3><p>对比 <code>System.out.println()</code> 有如下好处：</p>
<ol>
<li>可以设置输出样式，避免自己每次都写<code>&quot;ERROR: &quot; + var</code>；</li>
<li>可以设置输出级别，禁止某些级别输出。例如，只输出错误日志；</li>
<li>可以被重定向到文件，这样可以在程序运行结束后查看日志；</li>
<li>可以按包名控制日志级别，只输出某些包打的日志；</li>
<li>可以…… 等等</li>
</ol>
<p>Java 内置了 <code>java.util.logging</code>，可以直接使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.logging.Level;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.Logger;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> Logger.getGlobal();</span><br><span class="line">        logger.info(<span class="string">&quot;start process...&quot;</span>);</span><br><span class="line">        logger.warning(<span class="string">&quot;memory is running out...&quot;</span>);</span><br><span class="line">        logger.fine(<span class="string">&quot;ignored.&quot;</span>);</span><br><span class="line">        logger.severe(<span class="string">&quot;process will be terminated...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Mar 02, 2019 6:32:13 PM Hello main</span><br><span class="line">INFO: start process...</span><br><span class="line">Mar 02, 2019 6:32:13 PM Hello main</span><br><span class="line">WARNING: memory is running out...</span><br><span class="line">Mar 02, 2019 6:32:13 PM Hello main</span><br><span class="line">SEVERE: process will be terminated...</span><br></pre></td></tr></table></figure>

<p>可以看出 fine 的日志没有打印出来。</p>
<p>默认日志级别是 INFO，该级别以下的日志不会被打印出来。</p>
<p>JDK 的 Logging 定义了7个日志级别，从严重到普通：</p>
<ul>
<li>SEVERE</li>
<li>WARNING</li>
<li>INFO</li>
<li>CONFIG</li>
<li>FINE</li>
<li>FINER</li>
<li>FINEST</li>
</ul>
<p><strong>局限</strong></p>
<p>Logging 系统在 JVM 启动时读取配置文件并完成初始化，一旦开始运行<code>main()</code>方法，就无法修改配置；</p>
<p>配置不方便，需要在JVM启动时传递参数<code>-Djava.util.logging.config.file=&lt;config-file-name&gt;</code>。</p>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><p>除了 int 等基本类型外，Java 的其他类型全部都是 class，包括 interface。</p>
<blockquote>
<p>JVM也为 int 等基本类型创建了 Class 实例。</p>
</blockquote>
<p>而<code>class</code>是由JVM在执行过程中动态加载的。JVM在第一次读取到一种<code>class</code>类型时，将其加载进内存。</p>
<blockquote>
<p>没有加载到的class是无法通过Class.forName()找到的。</p>
</blockquote>
<p>每加载一种<code>class</code>，JVM就为其创建一个<code>Class</code>类型的实例，并关联起来。注意：这里的<code>Class</code>类型是一个名叫<code>Class</code>的<code>class</code>。它长这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Class</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Class</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以<code>String</code>类为例，当JVM加载<code>String</code>类时，它首先读取<code>String.class</code>文件到内存，然后，为<code>String</code>类创建一个<code>Class</code>实例并关联起来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Class</span>(String);</span><br></pre></td></tr></table></figure>

<p><strong>每个类的Class实例是唯一的。</strong></p>
<p><strong>每个类的<code>Class</code>实例包含了该<code>class</code>的所有完整信息：</strong></p>
<p><img src="/../assets/image-20240417190242743.png" alt="image-20240417190242743"></p>
<p>所以可以通过某个类的 Class 实例获取这个类的所有信息，这种操作被称为反射。</p>
<p><strong>动态加载特性</strong></p>
<p>动态加载<code>class</code>的特性对于Java程序非常重要。</p>
<p>利用JVM动态加载<code>class</code>的特性，我们才能在运行期根据条件加载不同的实现类。</p>
<p>例如，Commons Logging总是优先使用Log4j，只有当Log4j不存在时，才使用JDK的logging。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Commons Logging优先使用Log4j:</span></span><br><span class="line"><span class="type">LogFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (isClassPresent(<span class="string">&quot;org.apache.logging.log4j.Logger&quot;</span>)) &#123;</span><br><span class="line">    factory = createLog4j();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    factory = createJdkLog();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isClassPresent</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class.forName(name);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a><strong>基本使用</strong></h3><h4 id="如何获取一个类的Class实例"><a href="#如何获取一个类的Class实例" class="headerlink" title="如何获取一个类的Class实例"></a><strong>如何获取一个类的Class实例</strong></h4><ol>
<li><p>通过类的静态变量class获取</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clz</span> <span class="operator">=</span> String.class;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过类的某个实例的 getClass() 方法获取</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">Class</span> <span class="variable">clz</span> <span class="operator">=</span> s.getClass();</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过 Class 的静态方法获取</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数为类的完整包路径</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="对比-instanceof"><a href="#对比-instanceof" class="headerlink" title="对比 instanceof"></a><strong>对比 instanceof</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> n <span class="keyword">instanceof</span> Integer; <span class="comment">// true，因为n是Integer类型</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b2</span> <span class="operator">=</span> n <span class="keyword">instanceof</span> Number; <span class="comment">// true，因为n是Number类型的子类</span></span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b3</span> <span class="operator">=</span> n.getClass() == Integer.class; <span class="comment">// true，因为n.getClass()返回Integer.class</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b4</span> <span class="operator">=</span> n.getClass() == Number.class; <span class="comment">// false，因为Integer.class!=Number.class</span></span><br></pre></td></tr></table></figure>

<p>instanceof 不但可以匹配相同类型，还可以匹配该类型的父类</p>
<p>而 Class 实例只能匹配其本身的类型，因为每个 class 都有唯一的 Class 实例。</p>
<h4 id="获取类的基本信息"><a href="#获取类的基本信息" class="headerlink" title="获取类的基本信息"></a><strong>获取类的基本信息</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        printClassInfo(<span class="string">&quot;&quot;</span>.getClass());</span><br><span class="line">        printClassInfo(Runnable.class);</span><br><span class="line">        printClassInfo(java.time.Month.class);</span><br><span class="line">        printClassInfo(String[].class);</span><br><span class="line">        printClassInfo(<span class="type">int</span>.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printClassInfo</span><span class="params">(Class cls)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Class name: &quot;</span> + cls.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;Simple name: &quot;</span> + cls.getSimpleName());</span><br><span class="line">        <span class="keyword">if</span> (cls.getPackage() != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Package name: &quot;</span> + cls.getPackage().getName());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;is interface: &quot;</span> + cls.isInterface());</span><br><span class="line">        System.out.println(<span class="string">&quot;is enum: &quot;</span> + cls.isEnum());</span><br><span class="line">        System.out.println(<span class="string">&quot;is array: &quot;</span> + cls.isArray());</span><br><span class="line">        System.out.println(<span class="string">&quot;is primitive: &quot;</span> + cls.isPrimitive());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数组（例如<code>String[]</code>）也是一种类，而且不同于<code>String.class</code>，它的类名是<code>[Ljava.lang.String;</code>。</p>
<h4 id="创建新实例"><a href="#创建新实例" class="headerlink" title="创建新实例"></a><strong>创建新实例</strong></h4><p>如果获取到了一个<code>Class</code>实例，我们就可以通过该<code>Class</code>实例来创建对应类型的实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取String的Class实例:</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> String.class;</span><br><span class="line"><span class="comment">// 创建一个String实例:</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> (String) cls.newInstance();</span><br></pre></td></tr></table></figure>



<h3 id="Field"><a href="#Field" class="headerlink" title="Field"></a>Field</h3><p>通过类的 Class 实例可以获取到该类的<strong>所有实例</strong>的字段信息。</p>
<h4 id="获取方法介绍："><a href="#获取方法介绍：" class="headerlink" title="获取方法介绍："></a><strong>获取方法介绍：</strong></h4><ul>
<li>Field getField(name)：根据字段名获取某个 public 的field（包括父类）</li>
<li>Field[] getFields()：获取所有 public 的field（包括父类）</li>
<li>Field getDeclaredField(name)：根据字段名获取当前类的某个field（不包括父类）</li>
<li>Field[] getDeclaredFields()：获取当前类的所有field（不包括父类）</li>
</ul>
<p>getDeclaredField 相比于 getField 更针对<strong>自身声明的所有字段（包括private）</strong></p>
<h4 id="Field对象属性介绍"><a href="#Field对象属性介绍" class="headerlink" title="Field对象属性介绍"></a><strong>Field对象属性介绍</strong></h4><ul>
<li><code>getName()</code>：返回字段名称，例如，<code>&quot;name&quot;</code>；</li>
<li><code>getType()</code>：返回字段类型，也是一个<code>Class</code>实例，例如，<code>String.class</code>；</li>
<li><code>getModifiers()</code>：返回字段的修饰符，它是一个<code>int</code>，不同的bit表示不同的含义。</li>
</ul>
<p>以<code>String</code>类的<code>value</code>字段为例，它的定义是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span>[] value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们用反射获取该字段的信息，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> String.class.getDeclaredField(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">f.getName(); <span class="comment">// &quot;value&quot;</span></span><br><span class="line">f.getType(); <span class="comment">// class [B 表示byte[]类型</span></span><br><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> f.getModifiers();</span><br><span class="line">Modifier.isFinal(m); <span class="comment">// true</span></span><br><span class="line">Modifier.isPublic(m); <span class="comment">// false</span></span><br><span class="line">Modifier.isProtected(m); <span class="comment">// false</span></span><br><span class="line">Modifier.isPrivate(m); <span class="comment">// true</span></span><br><span class="line">Modifier.isStatic(m); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h4 id="获取字段值"><a href="#获取字段值" class="headerlink" title="获取字段值"></a><strong>获取字段值</strong></h4><p><code>f.get(Object)</code> 获取该字段在指定实例的值。</p>
<p>因为每个类只有一个 Class，其中的每个字段只有一个 Field，而类的实例存在多个。</p>
<p>因此要想获取该字段的值，必须指定是哪个实例，所以才要传入实例。</p>
<p>但是不能直接访问非 public 字段，需要声明访问许可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f.setAccessible(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p>不声明直接访问 private 字段会抛出 <code>IllegalAccessException</code> 非法访问异常。</p>
<p><code>setAccessible(true)</code>可能会失败。</p>
<p>如果JVM运行期存在<code>SecurityManager</code>，那么它会根据规则进行检查，有可能阻止<code>setAccessible(true)</code>。</p>
<p>例如，某个<code>SecurityManager</code>可能不允许对<code>java</code>和<code>javax</code>开头的<code>package</code>的类调用<code>setAccessible(true)</code>，这样可以保证JVM核心库的安全。</p>
<h4 id="设置字段值"><a href="#设置字段值" class="headerlink" title="设置字段值"></a><strong>设置字段值</strong></h4><p><code>f.set(Object1, Object2)</code> 设置指定实例 Object1 的 Field 字段值为 Object2。</p>
<p>同理，修改非 public 字段，需要声明访问许可。</p>
<h3 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h3><p>通过 Class 实例也可以获取该类的所有 method 方法信息。</p>
<h4 id="获取方法（类似Field）"><a href="#获取方法（类似Field）" class="headerlink" title="获取方法（类似Field）"></a><strong>获取方法（类似Field）</strong></h4><ul>
<li><code>Method getMethod(name, Class...)</code>：获取某个<code>public</code>的<code>Method</code>（包括父类）</li>
<li><code>Method[] getMethods()</code>：获取所有<code>public</code>的<code>Method</code>（包括父类）</li>
<li><code>Method getDeclaredMethod(name, Class...)</code>：获取当前类的某个<code>Method</code>（不包括父类）</li>
<li><code>Method[] getDeclaredMethods()</code>：获取当前类的所有<code>Method</code>（不包括父类）</li>
</ul>
<p>区别：因为方法允许重载，所以在获取 Method 实例时除了需要指定方法名外，还需要显式的按顺序指定参数类型。</p>
<h4 id="Method-实例属性介绍"><a href="#Method-实例属性介绍" class="headerlink" title="Method 实例属性介绍"></a><strong>Method 实例属性介绍</strong></h4><ul>
<li><code>getName()</code>：返回方法名称，例如：<code>&quot;getScore&quot;</code>；</li>
<li><code>getReturnType()</code>：返回方法返回值类型，也是一个Class实例，例如：<code>String.class</code>；</li>
<li><code>getParameterTypes()</code>：返回方法的参数类型，是一个Class数组，例如：<code>&#123;String.class, int.class&#125;</code>；</li>
<li><code>getModifiers()</code>：返回方法的修饰符，它是一个<code>int</code>，不同的bit表示不同的含义。</li>
</ul>
<h4 id="调用实例方法"><a href="#调用实例方法" class="headerlink" title="调用实例方法"></a><strong>调用实例方法</strong></h4><p><code>m.invoke(Object, ...params)</code> 调用指定实例的实例方法，类似 Field 的 get 用法。</p>
<p>当我们获取到一个<code>Method</code>对象时，就可以对它进行调用。我们以下面的代码为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello world&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">r</span> <span class="operator">=</span> s.substring(<span class="number">6</span>); <span class="comment">// &quot;world&quot;</span></span><br></pre></td></tr></table></figure>

<p>改写为反射来调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// String对象:</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello world&quot;</span>;</span><br><span class="line">        <span class="comment">// 获取String substring(int)方法，参数为int:</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> String.class.getMethod(<span class="string">&quot;substring&quot;</span>, <span class="type">int</span>.class);</span><br><span class="line">        <span class="comment">// 在s对象上调用该方法并获取结果:</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">r</span> <span class="operator">=</span> (String) m.invoke(s, <span class="number">6</span>);</span><br><span class="line">        <span class="comment">// 打印调用结果:</span></span><br><span class="line">        System.out.println(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="调用静态方法"><a href="#调用静态方法" class="headerlink" title="调用静态方法"></a><strong>调用静态方法</strong></h4><p><code>m.invoke(null, ...params)</code></p>
<p>由于静态方法是直接绑定到类实例上的，所以第一个参数永远是 null。</p>
<h4 id="调用非-public-方法"><a href="#调用非-public-方法" class="headerlink" title="调用非 public 方法"></a><strong>调用非 public 方法</strong></h4><p>也和 Field 类似，需要声明访问许可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m.setAccessible(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a><strong>多态</strong></h4><p>一个<code>Person</code>类定义了<code>hello()</code>方法，并且它的子类<code>Student</code>也覆写了<code>hello()</code>方法</p>
<p>如果从Person类的 Class 获取Method实例，作用于 Student 实例时，调用的是谁的方法。</p>
<p>答案：会调用 Student 的，可能是因为每个 Method 是唯一的，作用于哪个实例，就是哪个实例的方法。</p>
<p>因此，使用反射调用方法时，仍然遵循多态原则：即总是调用实际类型的覆写方法（如果存在）。上述的反射代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> Person.class.getMethod(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">m.invoke(<span class="keyword">new</span> <span class="title class_">Student</span>());</span><br></pre></td></tr></table></figure>

<p>实际上相当于：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">p.hello();</span><br></pre></td></tr></table></figure>



<h3 id="Constructor"><a href="#Constructor" class="headerlink" title="Constructor"></a>Constructor</h3><p>通常使用<code>new</code>操作符创建新的实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br></pre></td></tr></table></figure>

<p>如果通过反射来创建新的实例，可以调用Class提供的newInstance()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> Person.class.newInstance();</span><br></pre></td></tr></table></figure>

<p>直接调用 <code>newInstance()</code> 方法只能调用该类的<strong>public无参数</strong>构造方法。</p>
<p>如果构造方法带有参数，或者不是public，就无法直接通过Class.newInstance()来调用。</p>
<p>因此，Java提供了这个类似Field、Method的Constructor类，包含了一个 Class 的所有构造方法信息。</p>
<h4 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a><strong>获取方法</strong></h4><ul>
<li><code>getConstructor(Class...)</code>：获取某个<code>public</code>的<code>Constructor</code>；</li>
<li><code>getConstructors()</code>：获取所有<code>public</code>的<code>Constructor</code>；</li>
<li><code>getDeclaredConstructor(Class...)</code>：获取某个<code>Constructor</code>；</li>
<li><code>getDeclaredConstructors()</code>：获取所有<code>Constructor</code>。</li>
</ul>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a><strong>使用</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取构造方法Integer(int):</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">cons1</span> <span class="operator">=</span> Integer.class.getConstructor(<span class="type">int</span>.class);</span><br><span class="line">        <span class="comment">// 调用构造方法:</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">n1</span> <span class="operator">=</span> (Integer) cons1.newInstance(<span class="number">123</span>);</span><br><span class="line">        System.out.println(n1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样，调用非<code>public</code>的<code>Constructor</code>时，必须首先通过<code>setAccessible(true)</code>设置允许访问。</p>
<h3 id="获取继承关系"><a href="#获取继承关系" class="headerlink" title="获取继承关系"></a>获取继承关系</h3><h4 id="获取父类的Class"><a href="#获取父类的Class" class="headerlink" title="获取父类的Class"></a><strong>获取父类的Class</strong></h4><p>有了<code>Class</code>实例，我们还可以获取它的父类的<code>Class</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">i</span> <span class="operator">=</span> Integer.class;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">n</span> <span class="operator">=</span> i.getSuperclass();</span><br><span class="line">        System.out.println(n);</span><br><span class="line">        <span class="type">Class</span> <span class="variable">o</span> <span class="operator">=</span> n.getSuperclass();</span><br><span class="line">        System.out.println(o);</span><br><span class="line">        System.out.println(o.getSuperclass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行上述代码可以看到，<code>Integer</code>的父类类型是<code>Number</code>，<code>Number</code>的父类是<code>Object</code>，<code>Object</code>的父类是<code>null</code>，因为所有的类都是继承于 <code>Objcet</code>。</p>
<p>除<code>Object</code>外，其他任何非<code>interface</code>的<code>Class</code>都必定存在一个父类类型。</p>
<h4 id="获取interface"><a href="#获取interface" class="headerlink" title="获取interface"></a><strong>获取interface</strong></h4><p>通过<code>clz.getInterfaces()</code> 方法可以查询到该类实现的接口类型。</p>
<p>例如，查询<code>Integer</code>实现的接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">s</span> <span class="operator">=</span> Integer.class;</span><br><span class="line">        Class[] is = s.getInterfaces();</span><br><span class="line">        <span class="keyword">for</span> (Class i : is) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行上述代码可知，<code>Integer</code>实现的接口有：</p>
<ul>
<li>java.lang.Comparable</li>
<li>java.lang.constant.Constable</li>
<li>java.lang.constant.ConstantDesc</li>
</ul>
<p>注意：</p>
<ol>
<li><code>getInterfaces()</code>只返回当前类直接实现的接口类型，<strong>并不包括其父类实现的接口类型</strong></li>
<li>如果一个类没有实现任何<code>interface</code>，那么<code>getInterfaces()</code>返回空数组。</li>
</ol>
<h4 id="继承关系判断"><a href="#继承关系判断" class="headerlink" title="继承关系判断"></a><strong>继承关系判断</strong></h4><p>要判断一个类是否可以赋值给另一个类（向上转型）可以调用<code>isAssignableFrom()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Number n = ?</span></span><br><span class="line">Number.class.isAssignableFrom(Integer.class); <span class="comment">// true，因为Integer可以赋值给Number</span></span><br><span class="line"><span class="comment">// Integer i = ?</span></span><br><span class="line">Integer.class.isAssignableFrom(Number.class); <span class="comment">// false，因为Number不能赋值给Integer</span></span><br></pre></td></tr></table></figure>



<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>Java 中，是不能直接实例化 interface 的。</p>
<p>所有<code>interface</code>类型的变量总是通过某个实例向上转型并赋值给接口类型变量的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CharSequence</span> <span class="variable">cs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br></pre></td></tr></table></figure>

<p>但是 Java 标准库提供了一种动态代理（Dynamic Proxy）的机制：可以在运行期动态创建某个<code>interface</code>的实例。</p>
<p>就是不去实现，而是在代码运行中动态创建并使用。</p>
<p>通过JDK提供的一个<code>Proxy.newProxyInstance()</code>创建一个<code>Hello</code>接口对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                System.out.println(method);</span><br><span class="line">                <span class="comment">// 匹配对应方法，执行自定义内容</span></span><br><span class="line">                <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;morning&quot;</span>)) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Good morning, &quot;</span> + args[<span class="number">0</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Hello</span> <span class="variable">hello</span> <span class="operator">=</span> (Hello) Proxy.newProxyInstance(</span><br><span class="line">            Hello.class.getClassLoader(), <span class="comment">// 传入ClassLoader</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; Hello.class &#125;, <span class="comment">// 传入要实现的接口</span></span><br><span class="line">            handler); <span class="comment">// 传入处理调用方法的InvocationHandler</span></span><br><span class="line">        hello.morning(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">morning</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>动态创建 interface 实现类步骤</strong></p>
<ol>
<li>定义一个<code>InvocationHandler</code>实例，它负责实现接口的方法调用；</li>
<li>通过 Proxy.newProxyInstance() 创建 interface 实例，传入3个参数：<ol>
<li>使用的<code>ClassLoader</code>，通常就是接口类的<code>ClassLoader</code>；</li>
<li>需要实现的接口数组，至少需要传入一个接口进去（这里传入接口本身的 Class 实例）；</li>
<li>用来处理接口方法调用的<code>InvocationHandler</code>实例。</li>
</ol>
</li>
<li>将返回的<code>Object</code>强制转型为接口。</li>
</ol>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h3 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h3><p>注解是放在Java源码的类、方法、字段、参数前的一种特殊“注释”。</p>
<p><strong>区别于注释：</strong></p>
<p>注释会被编译器直接忽略，注解则可以被编译器打包进入class文件，可以把注解看做是一种用作标注的“元数据”。</p>
<p><strong>分类</strong></p>
<p>Java的注解可以分为三类：</p>
<p><strong>第一类</strong>是由<strong>编译器</strong>使用的注解，作用于编译阶段，例如：</p>
<ul>
<li><p><code>@Override</code>：让编译器检查该方法是否正确地实现了覆写；</p>
</li>
<li><p><code>@SuppressWarnings</code>：告诉编译器忽略此处代码产生的警告。</p>
</li>
</ul>
<p>这类注解不会被编译进入<code>.class</code>文件，它们在编译后就被编译器扔掉了。</p>
<p><strong>第二类</strong>是由<strong>底层工具</strong>处理<code>.class</code>文件使用的注解。</p>
<p>比如在加载class的时候对class做动态修改，实现一些特殊的功能（如Lombok加一些属性等）。</p>
<p>这类注解会被编译进入<code>.class</code>文件，但加载结束后并不会存在于内存中。</p>
<p><strong>第三类</strong>是在<strong>程序运行期</strong>能够读取的注解，它们在加载后一直存在于JVM中，程序在运行中可以随时捕捉和处理。</p>
<p>例如，一个配置了<code>@PostConstruct</code>的方法会在调用构造方法后自动被调用（这是Java代码读取该注解实现的功能，JVM并不会识别该注解）。</p>
<h3 id="定义注解"><a href="#定义注解" class="headerlink" title="定义注解"></a><strong>定义注解</strong></h3><h4 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a><strong>配置参数</strong></h4><p>定义一个注解时可以定义配置参数。配置参数必须是<strong>不可变类型</strong>，包括：</p>
<ul>
<li>所有基本类型；</li>
<li>String；</li>
<li>枚举类型；</li>
<li>基本类型、String、Class以及枚举的数组。</li>
</ul>
<p>还允许为配置参数指定默认值，缺少某个配置参数时将使用默认值。</p>
<p>大部分注解会有一个名为<code>value</code>的配置参数，对此参数赋值，可以只写常量省略value参数名称。</p>
<p>即配置注解时，如果配置的参数名称是<code>value</code>，且只有一个参数，那么可以省略参数名称。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="meta">@Check(min=0, max=100, value=55)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Check(value=99)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> p;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Check(99)</span> <span class="comment">// @Check(value=99)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Check</span>	   <span class="comment">// 全部配置参数使用默认值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="定义格式"><a href="#定义格式" class="headerlink" title="定义格式"></a><strong>定义格式</strong></h4><p>Java语言使用<code>@interface</code>语法来定义注解（<code>Annotation</code>），它的格式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">type</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    String <span class="title function_">level</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;info&quot;</span>;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a><strong>元注解</strong></h4><p>有一些注解可以修饰其他注解，这些注解就称为元注解（meta annotation）。</p>
<p>Java标准库已经定义了一些元注解，我们只需要使用元注解，通常不需要自己去编写元注解。</p>
<h5 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h5><p>最常用的元注解是<code>@Target</code>。使用<code>@Target</code>可以定义<code>Annotation</code>能够被应用于源码的哪些位置：</p>
<ul>
<li>类或接口：<code>ElementType.TYPE</code>；</li>
<li>字段：<code>ElementType.FIELD</code>；</li>
<li>方法：<code>ElementType.METHOD</code>；</li>
<li>构造方法：<code>ElementType.CONSTRUCTOR</code>；</li>
<li>方法参数：<code>ElementType.PARAMETER</code>。</li>
</ul>
<p>例如，定义注解<code>@Report</code>可用在方法上，我们必须添加一个<code>@Target(ElementType.METHOD)</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">type</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    String <span class="title function_">level</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;info&quot;</span>;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义注解<code>@Report</code>可用在方法或字段上，可以把<code>@Target</code>注解参数变为数组<code>&#123; ElementType.METHOD, ElementType.FIELD &#125;</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;</span></span><br><span class="line"><span class="meta">    ElementType.METHOD,</span></span><br><span class="line"><span class="meta">    ElementType.FIELD</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上<code>@Target</code>定义的<code>value</code>是<code>ElementType[]</code>数组，<strong>只有一个元素时，可以省略数组的写法</strong>。</p>
<h5 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h5><p>另一个重要的元注解<code>@Retention</code>定义了<code>Annotation</code>的生命周期：</p>
<ul>
<li><p>仅编译期：<code>RetentionPolicy.SOURCE</code>；</p>
<p>提供给编译器使用，编译结束后会丢掉。</p>
</li>
<li><p>仅class文件：<code>RetentionPolicy.CLASS</code>；</p>
<p>用于修改底层class结构，不会被JVM加载。</p>
</li>
<li><p>运行期：<code>RetentionPolicy.RUNTIME</code>。</p>
<p>可以在程序运行中捕获和处理，最常用。</p>
</li>
</ul>
<p>如果<code>@Retention</code>不存在，则该<code>Annotation</code>默认为<code>CLASS</code>。</p>
<p>因为通常我们自定义的<code>Annotation</code>都是<code>RUNTIME</code>，所以要加上<code>@Retention(RetentionPolicy.RUNTIME)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">type</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    String <span class="title function_">level</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;info&quot;</span>;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Repeatable"><a href="#Repeatable" class="headerlink" title="@Repeatable"></a>@Repeatable</h5><p>使用<code>@Repeatable(Class)</code>这个元注解可以定义<code>Annotation</code>是否可重复标注在同一个地方。</p>
<p>并将重复的注解读到目标 Class 的参数中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将多个 Report 记录到 Reports 注解中。</span></span><br><span class="line"><span class="meta">@Repeatable(Reports.class)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">type</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    String <span class="title function_">level</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;info&quot;</span>;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Reports &#123;</span><br><span class="line">    Report[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过<code>@Repeatable</code>修饰后，在某个类型声明处，就可以添加多个<code>@Report</code>注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Report(type=1, level=&quot;debug&quot;)</span></span><br><span class="line"><span class="meta">@Report(type=2, level=&quot;warning&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h5><p>使用<code>@Inherited</code>定义子类是否可继承父类定义的<code>Annotation</code>。</p>
<p><code>@Inherited</code>仅针对<code>@Target(ElementType.TYPE)</code>类型的<code>annotation</code>有效，并且对<code>interface</code>的继承无效：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">type</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    String <span class="title function_">level</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;info&quot;</span>;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在使用的时候，如果一个类用到了<code>@Report</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Report(type=1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>则它的子类默认也定义了该注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="自定义-Annotation-步骤"><a href="#自定义-Annotation-步骤" class="headerlink" title="自定义 Annotation 步骤"></a>自定义 Annotation 步骤</h4><ol>
<li>用<code>@interface</code>定义注解：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>定义配置参数、默认值：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">type</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    String <span class="title function_">level</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;info&quot;</span>;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把最常用的参数定义为<code>value()</code>，推荐所有参数都尽量设置默认值。</p>
<ol start="3">
<li>用元注解配置注解：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">type</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    String <span class="title function_">level</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;info&quot;</span>;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，必须设置<code>@Target</code>和<code>@Retention</code>，<code>@Retention</code>一般设置为<code>RUNTIME</code>，因为我们自定义的注解通常要求在运行期读取。一般情况下，不必写<code>@Inherited</code>和<code>@Repeatable</code>。</p>
<h3 id="读取处理注解"><a href="#读取处理注解" class="headerlink" title="读取处理注解"></a>读取处理注解</h3><p><code>SOURCE</code>类型的注解主要由编译器使用，因此我们一般只使用，不编写。</p>
<p><code>CLASS</code>类型的注解主要由底层工具库使用，涉及到class的加载，一般我们很少用到。</p>
<p>只有<code>RUNTIME</code>类型的注解不但要使用，还经常需要编写。</p>
<p>因此，以下方式针对 RUNTIME 类型处理。</p>
<h4 id="读取注解："><a href="#读取注解：" class="headerlink" title="读取注解："></a><strong>读取注解</strong>：</h4><p>判断某个注解是否存在于<code>Class</code>、<code>Field</code>、<code>Method</code>或<code>Constructor</code>：</p>
<ul>
<li><code>Class.isAnnotationPresent(Class)</code></li>
<li><code>Field.isAnnotationPresent(Class)</code></li>
<li><code>Method.isAnnotationPresent(Class)</code></li>
<li><code>Constructor.isAnnotationPresent(Class)</code></li>
</ul>
<p>使用反射API读取Annotation：</p>
<ul>
<li><code>Class.getAnnotation(Class)</code></li>
<li><code>Field.getAnnotation(Class)</code></li>
<li><code>Method.getAnnotation(Class)</code></li>
<li><code>Constructor.getAnnotation(Class)</code></li>
</ul>
<p>使用反射API读取<code>Annotation</code>有两种方法。</p>
<ol>
<li>先判断<code>Annotation</code>是否存在，如果存在，就直接读取：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Person.class;</span><br><span class="line"><span class="keyword">if</span> (cls.isAnnotationPresent(Report.class)) &#123;</span><br><span class="line">    <span class="type">Report</span> <span class="variable">report</span> <span class="operator">=</span> cls.getAnnotation(Report.class);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>是直接读取<code>Annotation</code>，如果<code>Annotation</code>不存在，将返回<code>null</code>：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Person.class;</span><br><span class="line"><span class="type">Report</span> <span class="variable">report</span> <span class="operator">=</span> cls.getAnnotation(Report.class);</span><br><span class="line"><span class="keyword">if</span> (report != <span class="literal">null</span>) &#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读取方法、字段和构造方法的<code>Annotation</code>和Class类似。</p>
<p>但要读取方法参数的<code>Annotation</code>就比较麻烦一点，因为方法参数本身可以看成一个数组，而每个参数又可以定义多个注解。</p>
<p>所以，方法参数的所有注解用一个二维数组来表示。</p>
<p>例如，对于以下方法定义的注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">(<span class="meta">@NotNull</span> <span class="meta">@Range(max=5)</span> String name, <span class="meta">@NotNull</span> String prefix)</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要读取方法参数的注解，我们先用反射获取<code>Method</code>实例，然后读取方法参数的所有注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取Method实例:</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> ...</span><br><span class="line"><span class="comment">// 获取所有参数的Annotation:</span></span><br><span class="line">Annotation[][] annos = m.getParameterAnnotations();</span><br><span class="line"><span class="comment">// 第一个参数（索引为0）的所有Annotation:</span></span><br><span class="line">Annotation[] annosOfName = annos[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (Annotation anno : annosOfName) &#123;</span><br><span class="line">    <span class="keyword">if</span> (anno <span class="keyword">instanceof</span> Range r) &#123; <span class="comment">// @Range注解</span></span><br><span class="line">        <span class="comment">// 获取range注解的max参数值</span></span><br><span class="line">        r.max();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anno <span class="keyword">instanceof</span> NotNull n) &#123; <span class="comment">// @NotNull注解</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="处理注解"><a href="#处理注解" class="headerlink" title="处理注解"></a>处理注解</h4><p>注解本身只是一个标注，被标注的对象如何处理完全由程序自己决定。</p>
<p>例如，JUnit是一个测试框架，它会自动运行所有标记为<code>@Test</code>的方法。</p>
<p>以<code>@Range</code>注解标注一个<code>String</code>字段为例，要求标注了这个注解的字段长度满足注解配置参数要求：</p>
<ol>
<li>定义注解</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Range &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">min</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">max</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">255</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用注解</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="meta">@Range(min=1, max=20)</span></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Range(max=10)</span></span><br><span class="line">    <span class="keyword">public</span> String city;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>处理注解</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">check</span><span class="params">(Person person)</span> <span class="keyword">throws</span> IllegalArgumentException, ReflectiveOperationException &#123;</span><br><span class="line">    <span class="comment">// 遍历所有Field:</span></span><br><span class="line">    <span class="keyword">for</span> (Field field : person.getClass().getFields()) &#123;</span><br><span class="line">        <span class="comment">// 获取Field定义的@Range:</span></span><br><span class="line">        <span class="type">Range</span> <span class="variable">range</span> <span class="operator">=</span> field.getAnnotation(Range.class);</span><br><span class="line">        <span class="comment">// 如果@Range存在:</span></span><br><span class="line">        <span class="keyword">if</span> (range != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取Field的值:</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> field.get(person);</span><br><span class="line">            <span class="comment">// 如果值是String:</span></span><br><span class="line">            <span class="keyword">if</span> (value <span class="keyword">instanceof</span> String s) &#123;</span><br><span class="line">                <span class="comment">// 判断值是否满足@Range的min/max:</span></span><br><span class="line">                <span class="keyword">if</span> (s.length() &lt; range.min() || s.length() &gt; range.max()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Invalid field: &quot;</span> + field.getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样一来，通过标注<code>@Range</code>注解，配合<code>check()</code>方法处理，就完成了<code>Person</code>实例的检查。</p>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p><strong>为什么需要泛型？</strong></p>
<p>复用，类型安全，避免出现误转型</p>
<p><strong>泛型的原理</strong></p>
<p>“类型擦除”，自动转型。</p>
<h3 id="定义泛型"><a href="#定义泛型" class="headerlink" title="定义泛型"></a>定义泛型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(T e)</span> &#123;...&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;...&#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在类名后头用<code>&lt;T&gt;</code>声明类型参数，这个类型可以是任意类型。</p>
<blockquote>
<p>定义接口泛型也是类似</p>
</blockquote>
<h4 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a><strong>向上转型</strong></h4><p><code>ArrayList&lt;Integer&gt;</code>不可以向上转型为<code>ArrayList&lt;Number&gt;</code>或<code>List&lt;Number&gt;</code>。</p>
<p>&#x3D;&#x3D;<strong>泛型不一致不能向上转型</strong>&#x3D;&#x3D;</p>
<p>如果允许成功赋值，在对它进行读取时就会出现类型错误，如 Double 写入了本就是 Integer 的 Number。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建ArrayList&lt;Integer&gt;类型：</span></span><br><span class="line">ArrayList&lt;Integer&gt; integerList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line"><span class="comment">// 添加一个Integer：</span></span><br><span class="line">integerList.add(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">123</span>));</span><br><span class="line"><span class="comment">// “向上转型”为ArrayList&lt;Number&gt;：</span></span><br><span class="line">ArrayList&lt;Number&gt; numberList = integerList;</span><br><span class="line"><span class="comment">// 添加一个Float，因为Float也是Number：</span></span><br><span class="line">numberList.add(<span class="keyword">new</span> <span class="title class_">Float</span>(<span class="number">12.34</span>));</span><br><span class="line"><span class="comment">// 从ArrayList&lt;Integer&gt;获取索引为1的元素（即添加的Float）：</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> integerList.get(<span class="number">1</span>); <span class="comment">// ClassCastException!</span></span><br></pre></td></tr></table></figure>

<p>允许类型<code>ArrayList&lt;T&gt;</code>可以向上转型为<code>List&lt;T&gt;</code>，必须保证泛型一致。</p>
<p>T 可以是 ?，表示可以是任意类型</p>
<p><code>ArrayList&lt;T&gt;</code>可以向上转型为 <code>ArrayList&lt;?&gt; </code></p>
<h4 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(T first, T last)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.first = first;</span><br><span class="line">        <span class="built_in">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getFirst</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getLast</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对静态方法使用&lt;T&gt;:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Pair&lt;T&gt; <span class="title function_">create</span><span class="params">(T first, T last)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;T&gt;(first, last);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>像这种直接在静态方法中使用泛型参数会报错，但是可以用声明泛型方法的方式来使用泛型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态泛型方法应该使用其他类型区分:</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K&gt; Pair&lt;K&gt; <span class="title function_">create</span><span class="params">(K first, K last)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;K&gt;(first, last);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态方法的泛型参数是区别于泛型类的，因为不用指定泛型也可以使用静态方法。</p>
<h4 id="多个泛型"><a href="#多个泛型" class="headerlink" title="多个泛型"></a>多个泛型</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T, K&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> K last;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(T first, K last)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.first = first;</span><br><span class="line">        <span class="built_in">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getFirst</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">public</span> K <span class="title function_">getLast</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类似 <code>Map&lt;K, V&gt;</code></p>
<h3 id="使用泛型"><a href="#使用泛型" class="headerlink" title="使用泛型"></a>使用泛型</h3><p>使用<code>ArrayList</code>带有泛型的类时，如果不声明泛型类型时，泛型类型实际上就是<code>Object</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译器警告:</span></span><br><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">list.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;World&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">first</span> <span class="operator">=</span> (String) list.get(<span class="number">0</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">second</span> <span class="operator">=</span> (String) list.get(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>此时，只能把<code>&lt;T&gt;</code>当作<code>Object</code>使用，没有发挥泛型的优势，依旧需要手动转型。</p>
<p>当我们定义泛型类型<code>&lt;String&gt;</code>后，<code>List&lt;T&gt;</code>的泛型接口变为强类型<code>List&lt;String&gt;</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无编译器警告:</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;World&quot;</span>);</span><br><span class="line"><span class="comment">// 无强制转型:</span></span><br><span class="line"><span class="type">String</span> <span class="variable">first</span> <span class="operator">=</span> list.get(<span class="number">0</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">second</span> <span class="operator">=</span> list.get(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>如果类型声明了泛型类型，在 new 实例时可以省略，由编译器自动推断。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以省略后面的Number，编译器可以自动推断泛型类型：</span></span><br><span class="line">List&lt;Number&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>



<h3 id="擦拭法"><a href="#擦拭法" class="headerlink" title="擦拭法"></a>擦拭法</h3><p>擦拭法是指，虚拟机对泛型其实一无所知，所有的工作像对泛型的检查和转换都是编译器做的。</p>
<p>擦拭法的效果：</p>
<ul>
<li>编译器把类型<code>&lt;T&gt;</code>视为<code>Object</code>；</li>
<li>编译器根据<code>&lt;T&gt;</code>实现安全的强制转型。</li>
</ul>
<p>使用泛型的时候，我们编写的代码也是编译器看到的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;String&gt; p = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">first</span> <span class="operator">=</span> p.getFirst();</span><br><span class="line"><span class="type">String</span> <span class="variable">last</span> <span class="operator">=</span> p.getLast();</span><br></pre></td></tr></table></figure>

<p>而虚拟机执行的代码并没有泛型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Pair</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pair</span>(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">first</span> <span class="operator">=</span> (String) p.getFirst();</span><br><span class="line"><span class="type">String</span> <span class="variable">last</span> <span class="operator">=</span> (String) p.getLast();</span><br></pre></td></tr></table></figure>

<p>所以，Java的泛型是由编译器在编译时实行的，<strong>编译器</strong>内部永远把所有类型<code>T</code>视为<code>Object</code>处理，但是，在需要转型的时候，<strong>编译器</strong>会根据<code>T</code>的类型自动为我们实行安全地强制转型。</p>
<h4 id="带来的局限"><a href="#带来的局限" class="headerlink" title="带来的局限"></a>带来的局限</h4><ol>
<li><code>&lt;T&gt;</code>不能是基本类型，因为基本类型无法对Object进行强制转型。</li>
<li>泛型类的 Class 实例都是同一个</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;String&gt; p1 = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">Pair&lt;Integer&gt; p2 = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line"><span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> p1.getClass();</span><br><span class="line"><span class="type">Class</span> <span class="variable">c2</span> <span class="operator">=</span> p2.getClass();</span><br><span class="line">System.out.println(c1==c2); <span class="comment">// true</span></span><br><span class="line">System.out.println(c1==Pair.class); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>无法用 instanceof 判断带泛型的类型</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;Integer&gt; p = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line"><span class="comment">// Compile error:</span></span><br><span class="line"><span class="keyword">if</span> (p <span class="keyword">instanceof</span> Pair&lt;String&gt;) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>不能使用 new 关键字实例化 T 类型，因为实际上会变成<code>new Object()</code></li>
</ol>
<h4 id="不能覆写Object类的方法"><a href="#不能覆写Object类的方法" class="headerlink" title="不能覆写Object类的方法"></a>不能覆写Object类的方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(T t)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.val == t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果覆盖了Object方法，会导致两个类被向上转型为Object时，出现类型转换错误。</p>
<h4 id="泛型继承"><a href="#泛型继承" class="headerlink" title="泛型继承"></a>泛型继承</h4><p>一个类可以继承自一个泛型类。例如：父类的类型是<code>Pair&lt;Integer&gt;</code>，子类的类型是<code>IntPair</code>，可以这么继承：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntPair</span> <span class="keyword">extends</span> <span class="title class_">Pair</span>&lt;Integer&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用的时候，因为子类<code>IntPair</code>并没有泛型类型，所以，正常使用即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">IntPair</span> <span class="variable">ip</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntPair</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>前面讲了，我们无法获取<code>Pair&lt;T&gt;</code>的<code>T</code>类型，即给定一个变量<code>Pair&lt;Integer&gt; p</code>，无法从<code>p</code>中获取到<code>Integer</code>类型。</p>
<p>但是在父类是泛型类型的情况下，编译器会把类型<code>T</code>（对<code>IntPair</code>来说，也就是<code>Integer</code>类型）保存到子类的class文件中，不然编译器就不知道<code>IntPair</code>只能存取<code>Integer</code>这种类型。</p>
<h4 id="获取父类泛型类型"><a href="#获取父类泛型类型" class="headerlink" title="获取父类泛型类型"></a>获取父类泛型类型</h4><p>在继承了泛型类型的情况下，子类可以获取父类的泛型类型。</p>
<p>例如：<code>IntPair</code>可以获取到父类的泛型类型<code>Integer</code>。获取父类的泛型类型代码比较复杂：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.ParameterizedType;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Class&lt;IntPair&gt; clazz = IntPair.class;</span><br><span class="line">        <span class="type">Type</span> <span class="variable">t</span> <span class="operator">=</span> clazz.getGenericSuperclass();</span><br><span class="line">        <span class="keyword">if</span> (t <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">            <span class="type">ParameterizedType</span> <span class="variable">pt</span> <span class="operator">=</span> (ParameterizedType) t;</span><br><span class="line">            Type[] types = pt.getActualTypeArguments(); <span class="comment">// 可能有多个泛型类型</span></span><br><span class="line">            <span class="type">Type</span> <span class="variable">firstType</span> <span class="operator">=</span> types[<span class="number">0</span>]; <span class="comment">// 取第一个泛型类型</span></span><br><span class="line">            Class&lt;?&gt; typeClass = (Class&lt;?&gt;) firstType;</span><br><span class="line">            System.out.println(typeClass); <span class="comment">// Integer</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="类型标识继承关系"><a href="#类型标识继承关系" class="headerlink" title="类型标识继承关系"></a>类型标识继承关系</h4><p><img src="/../assets/image-20240423215603321.png" alt="image-20240423215603321"></p>
<h3 id="extends、super"><a href="#extends、super" class="headerlink" title="extends、super"></a>extends、super</h3><h4 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Pair&lt;Integer&gt; p = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> add(p);</span><br><span class="line">        System.out.println(n);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(Pair&lt;? extends Number&gt; p)</span> &#123;</span><br><span class="line">        <span class="type">Number</span> <span class="variable">first</span> <span class="operator">=</span> p.getFirst();</span><br><span class="line">        <span class="type">Number</span> <span class="variable">last</span> <span class="operator">=</span> p.getLast();</span><br><span class="line">        <span class="keyword">return</span> first.intValue() + last.intValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>? extends Number</code> 表示该泛型可以是Number或其子类。</p>
<p>允许传入 <code>Pair&lt;Integer&gt;</code>。</p>
<p>这种使用<code>&lt;? extends Number&gt;</code>的泛型定义称之为上界通配符（Upper Bounds Wildcards），即把泛型类型<code>T</code>的上界限定在<code>Number</code>了。</p>
<p>如果声明的类型是 <code>Pair&lt;Number&gt;</code> ，无法传入 <code>Pair&lt;Integer&gt;</code> ，因为后者无法向上转型为前者。</p>
<p><strong>限制：</strong></p>
<p>方法参数签名<code>setFirst(? extends Number)</code>无法传递任何<code>Number</code>的子类型给<code>setFirst(? extends Number)</code>。</p>
<p>因为 Double 和 Integer 都可以传入，编译器会阻止这种类型不安全的行为。</p>
<p>例外：可以传入 null</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p.setFirst(<span class="literal">null</span>); <span class="comment">// ok, 但是后面会抛出NullPointerException</span></span><br><span class="line">p.getFirst().intValue(); <span class="comment">// NullPointerException</span></span><br></pre></td></tr></table></figure>

<p><strong>应用场景</strong></p>
<p>使用 extends 限定 T 的上界</p>
<p>例如定义 <code>Pair&lt;T extends Number&gt;</code>，则该泛型参数 T 只能传入 Number 的子类。</p>
<blockquote>
<p>T 和 ? 的区别：</p>
<p>? 表示一个通配符，可以传入任何类型。</p>
<p>T 表示一个泛型参数，在定义泛型类或方法时，需要用 T 来描述其他内容。</p>
</blockquote>
<h4 id="super"><a href="#super" class="headerlink" title="super"></a>super</h4><p>和 extends 相反，super 限定了 T 的下界。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">set</span><span class="params">(Pair&lt;? <span class="built_in">super</span> Integer&gt; p, Integer first, Integer last)</span> &#123;</span><br><span class="line">    p.setFirst(first);</span><br><span class="line">    p.setLast(last);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>? super Integer</code> 表示接收泛型类型为 Integer 或其父类。</p>
<p><strong>限制</strong></p>
<p>super 允许写，不允许读。</p>
<p>因为类型无法向下转型。</p>
<h4 id="对比extends和super通配符"><a href="#对比extends和super通配符" class="headerlink" title="对比extends和super通配符"></a>对比extends和super通配符</h4><p>我们再回顾一下<code>extends</code>通配符。作为方法参数，<code>&lt;? extends T&gt;</code>类型和<code>&lt;? super T&gt;</code>类型的区别在于：</p>
<ul>
<li><code>&lt;? extends T&gt;</code>允许调用读方法<code>T get()</code>获取<code>T</code>的引用，但不允许调用写方法<code>set(T)</code>传入<code>T</code>的引用（传入<code>null</code>除外）；</li>
<li><code>&lt;? super T&gt;</code>允许调用写方法<code>set(T)</code>传入<code>T</code>的引用，但不允许调用读方法<code>T get()</code>获取<code>T</code>的引用（获取<code>Object</code>除外）。</li>
</ul>
<p>一个是允许读不允许写，另一个是允许写不允许读。</p>
<p>先记住上面的结论，我们来看Java标准库的<code>Collections</code>类定义的<code>copy()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Collections</span> &#123;</span><br><span class="line">    <span class="comment">// 把src的每个元素复制到dest中:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">copy</span><span class="params">(List&lt;? <span class="built_in">super</span> T&gt; dest, List&lt;? extends T&gt; src)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;src.size(); i++) &#123;</span><br><span class="line">            <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> src.get(i);</span><br><span class="line">            dest.add(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>为什么 super 支持写，extends 支持读</strong></p>
<p>写：因为 super 可以传入 T 的超类，此时的泛型就有可能是 T 或其超类，在 set 时就允许向上转型赋值；而 extends 允许传入子类，如果对其赋值，就是向下转型了。</p>
<p>写：因为 extends 允许传入子类，此时的泛型就是 T 或其子类，那么 get 时，就可以使用 T （上界）来接收，满足向上转型，而 super 允许传入超类，此时这个 T 就是它的下界，不允许向下赋值。</p>
<p>因此，super和extends的读写，可以单独允许Object和null</p>
<h4 id="无限定通配符"><a href="#无限定通配符" class="headerlink" title="无限定通配符"></a>无限定通配符</h4><p>Java的泛型还允许使用无限定通配符（Unbounded Wildcard Type），即只定义一个<code>?</code>：</p>
<p>因为<code>&lt;?&gt;</code>通配符既没有<code>extends</code>，也没有<code>super</code>，因此：</p>
<ul>
<li>不允许调用<code>set(T)</code>方法并传入引用（<code>null</code>除外）；</li>
<li>不允许调用<code>T get()</code>方法并获取<code>T</code>引用（只能获取<code>Object</code>引用）。</li>
</ul>
<p>换句话说，既不能读，也不能写，那只能做一些<code>null</code>判断：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isNull</span><span class="params">(Pair&lt;?&gt; p)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> p.getFirst() == <span class="literal">null</span> || p.getLast() == <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大多数情况下，可以引入泛型参数<code>&lt;T&gt;</code>消除<code>&lt;?&gt;</code>通配符：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="type">boolean</span> <span class="title function_">isNull</span><span class="params">(Pair&lt;T&gt; p)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> p.getFirst() == <span class="literal">null</span> || p.getLast() == <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>&lt;?&gt;</code>通配符有一个独特的特点，就是：<code>Pair&lt;?&gt;</code>是所有<code>Pair&lt;T&gt;</code>的超类：</p>
<h3 id="泛型和反射"><a href="#泛型和反射" class="headerlink" title="泛型和反射"></a>泛型和反射</h3><h4 id="泛型-Class"><a href="#泛型-Class" class="headerlink" title="泛型 Class"></a>泛型 Class</h4><p>Java的部分反射API也是泛型。例如：<code>Class&lt;T&gt;</code>就是泛型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// compile warning:</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> String.class;</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String) clazz.newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">// no warning:</span></span><br><span class="line">Class&lt;String&gt; clazz = String.class;</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> clazz.newInstance();</span><br></pre></td></tr></table></figure>

<p>调用<code>Class</code>的<code>getSuperclass()</code>方法返回的<code>Class</code>类型是<code>Class&lt;? super T&gt;</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;? <span class="built_in">super</span> String&gt; sup = String.class.getSuperclass();</span><br></pre></td></tr></table></figure>

<h4 id="泛型-Constructor"><a href="#泛型-Constructor" class="headerlink" title="泛型 Constructor"></a>泛型 Constructor</h4><p>构造方法<code>Constructor&lt;T&gt;</code>也是泛型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;Integer&gt; clazz = Integer.class;</span><br><span class="line">Constructor&lt;Integer&gt; cons = clazz.getConstructor(<span class="type">int</span>.class);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> cons.newInstance(<span class="number">123</span>);</span><br></pre></td></tr></table></figure>

<h4 id="泛型数组"><a href="#泛型数组" class="headerlink" title="泛型数组"></a>泛型数组</h4><p>我们可以<strong>声明</strong>带泛型的数组，但不能用<code>new</code>操作符<strong>创建</strong>带泛型的数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;String&gt;[] ps = <span class="literal">null</span>; <span class="comment">// ok</span></span><br><span class="line">Pair&lt;String&gt;[] ps = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;String&gt;[<span class="number">2</span>]; <span class="comment">// compile error!</span></span><br></pre></td></tr></table></figure>

<p>可以通过强制转型实现“带泛型”的数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">Pair&lt;String&gt;[] ps = (Pair&lt;String&gt;[]) <span class="keyword">new</span> <span class="title class_">Pair</span>[<span class="number">2</span>];</span><br></pre></td></tr></table></figure>

<p>但是数组实际上在运行期没有泛型，而是 <code>Pair&lt;Object&gt;[]</code>。</p>
<p>因为类型擦拭，只能通过编译器来强制检查变量<code>ps</code>。</p>
<p><strong>注意：通过绕过泛型声明的引用依旧可以使用任意类型修改创建的数组</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Pair[] arr = <span class="keyword">new</span> <span class="title class_">Pair</span>[<span class="number">2</span>];</span><br><span class="line">Pair&lt;String&gt;[] ps = (Pair&lt;String&gt;[]) arr;</span><br><span class="line"></span><br><span class="line">ps[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;String&gt;(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>);</span><br><span class="line">arr[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;Integer&gt;(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ClassCastException:</span></span><br><span class="line">Pair&lt;String&gt; p = ps[<span class="number">1</span>];</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> p.getFirst();</span><br></pre></td></tr></table></figure>

<p>虽然这两个变量实际上指向同一个数组，但是操作<code>arr</code>可以传入非String的参数。</p>
<p><strong>要安全地使用泛型声明数组，必须扔掉原来<code>arr</code>的引用：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">Pair&lt;String&gt;[] ps = (Pair&lt;String&gt;[]) <span class="keyword">new</span> <span class="title class_">Pair</span>[<span class="number">2</span>];</span><br></pre></td></tr></table></figure>

<p>上面的代码中，由于拿不到原始数组的引用，就只能对泛型数组<code>ps</code>进行操作，这种操作就是安全的。</p>
<p>带泛型的数组实际上是编译器的类型擦除：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Pair[] arr = <span class="keyword">new</span> <span class="title class_">Pair</span>[<span class="number">2</span>];</span><br><span class="line">Pair&lt;String&gt;[] ps = (Pair&lt;String&gt;[]) arr;</span><br><span class="line"></span><br><span class="line">System.out.println(ps.getClass() == Pair[].class); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> (String) arr[<span class="number">0</span>].getFirst();</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> ps[<span class="number">0</span>].getFirst();</span><br></pre></td></tr></table></figure>

<p>所以我们不能直接创建泛型数组<code>T[]</code>，因为擦拭后代码变为<code>Object[]</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// compile error:</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Abc</span>&lt;T&gt; &#123;</span><br><span class="line">    T[] createArray() &#123;</span><br><span class="line">        <span class="comment">// 实际上返回 Object[]，换个引用就可以随意get,set任何类型</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">T</span>[<span class="number">5</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>创建泛型数组</strong></p>
<ol>
<li>借助<code>Class&lt;T&gt;</code>来创建泛型数组：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">T[] createArray(Class&lt;T&gt; cls) &#123;</span><br><span class="line">    <span class="keyword">return</span> (T[]) Array.newInstance(cls, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>利用可变参数创建泛型数组<code>T[]</code>：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayHelper</span> &#123;</span><br><span class="line">    <span class="meta">@SafeVarargs</span></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; T[] asArray(T... objs) &#123;</span><br><span class="line">        <span class="keyword">return</span> objs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String[] ss = ArrayHelper.asArray(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">Integer[] ns = ArrayHelper.asArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<h4 id="谨慎使用泛型可变参数"><a href="#谨慎使用泛型可变参数" class="headerlink" title="谨慎使用泛型可变参数"></a>谨慎使用泛型可变参数</h4><p>在上面的例子中，我们看到，通过：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; T[] asArray(T... objs) &#123;</span><br><span class="line">    <span class="keyword">return</span> objs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>似乎可以安全地创建一个泛型数组。但实际上，这种方法非常危险。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] arr = asArray(<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">        <span class="comment">// ClassCastException:</span></span><br><span class="line">        String[] firstTwo = pickTwo(<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(firstTwo));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &lt;K&gt; K[] pickTwo(K k1, K k2, K k3) &#123;</span><br><span class="line">        <span class="comment">// 传入的 k1, k2 参数其实是 Object 类型</span></span><br><span class="line">        <span class="keyword">return</span> asArray(k1, k2);  <span class="comment">// 返回 Object[]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; T[] asArray(T... objs) &#123;</span><br><span class="line">        <span class="comment">// 直接返回可变参数数组，可以识别，返回 T[]</span></span><br><span class="line">        <span class="keyword">return</span> objs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接调用<code>asArray(T...)</code>没有问题，直接将获取到的类型参数数组返回。</p>
<p>而如果在另一个方法中调用该方法，传入参数时，参数的类型已经被擦除了。</p>
<p>所以就会返回Object[]，然后产生<code>ClassCastException</code>。</p>
<p>编译器对所有可变泛型参数都会发出警告，只有确认完全没有问题，才可以用<code>@SafeVarargs</code>消除警告。</p>
<p> &#x3D;&#x3D;如果在<strong>方法内部</strong>创建了泛型数组，最好不要将它返回给外部使用。&#x3D;&#x3D;</p>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><p>List 只是一个接口，用来规范使用方法。</p>
<ul>
<li>在末尾添加一个元素：<code>boolean add(E e)</code></li>
<li>在指定索引添加一个元素：<code>boolean add(int index, E e)</code></li>
<li>删除指定索引的元素：<code>E remove(int index)</code></li>
<li>删除某个元素：<code>boolean remove(Object e)</code></li>
<li>获取指定索引的元素：<code>E get(int index)</code></li>
<li>获取链表大小（包含元素的个数）：<code>int size()</code></li>
</ul>
<p>要创建一个 List 实例，可以借助 <code>ArrayList</code> 或 <code>LinkedList</code>。</p>
<p>一个是线性表，一个是链表，区别如下。</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">ArrayList</th>
<th>LinkedList</th>
</tr>
</thead>
<tbody><tr>
<td align="left">获取指定元素</td>
<td align="left">速度很快</td>
<td>需要从头开始查找元素</td>
</tr>
<tr>
<td align="left">添加元素到末尾</td>
<td align="left">速度很快</td>
<td>速度很快</td>
</tr>
<tr>
<td align="left">在指定位置添加&#x2F;删除</td>
<td align="left">需要移动元素</td>
<td>不需要移动元素</td>
</tr>
<tr>
<td align="left">内存占用</td>
<td align="left">少</td>
<td>较大</td>
</tr>
</tbody></table>
<h4 id="List-of"><a href="#List-of" class="headerlink" title="List.of"></a>List.of</h4><p>Java 11以后，可以用 List.of(…T) 静态方法创建一个<strong>只读</strong>的列表。</p>
<p>注意：</p>
<ol>
<li>不允许传入 null</li>
<li>对只读<code>List</code>调用<code>add()</code>、<code>remove()</code>方法会抛出<code>UnsupportedOperationException</code>。</li>
</ol>
<h4 id="List转Array"><a href="#List转Array" class="headerlink" title="List转Array"></a>List转Array</h4><ol>
<li><p>直接调用 toArray 方法，返回 Object 类型数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object[] array = list.toArray();</span><br></pre></td></tr></table></figure>
</li>
<li><p>传入一个数组，返回该数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer[] arr = list.toArray(<span class="keyword">new</span> <span class="title class_">Integer</span>[<span class="number">5</span>]);</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>传入的数组类型如果和list类型无法兼容，会抛出 <code>ArrayStoreException</code></li>
<li>如果传入的数组容量比list小，会被截掉</li>
</ul>
</li>
<li><p>传入数组的构造方法引用</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer[] arr = intList.toArray(Integer[]::<span class="keyword">new</span>)</span><br></pre></td></tr></table></figure>



<h4 id="Array转List"><a href="#Array转List" class="headerlink" title="Array转List"></a>Array转List</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(...T)</span><br></pre></td></tr></table></figure>



<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h4 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h4><p>同 List，Map 只是一个接口</p>
<p><strong>常用方法</strong></p>
<ul>
<li>插入元素：<code>V put(K key, V value)</code></li>
<li>访问value：<code>V get(K key)</code></li>
<li>是否包含某个key：<code>boolean containsKey(K key)</code></li>
<li>是否包含某个value：<code>boolean containsKey(K key)</code></li>
<li>返回所有的key：<code>Set&lt;K&gt; keySet()</code></li>
<li>返回所有的value：<code>Collection&lt;V&gt; values()</code></li>
<li>返回所有的键值对：<code>Set&lt;Entry&lt;K, v&gt;&gt; entrySet()</code></li>
</ul>
<p><strong>注意：</strong></p>
<ol>
<li>不存在重复的key，如果对相同的key进行put，会替换掉这个key映射的value，并返回上次的value。</li>
<li>keySet  不一定是有序的。</li>
</ol>
<p><strong>实现类</strong></p>
<ol>
<li>HashMap：无序</li>
<li>TreeMap：有序，可以传入一个比较器来给key排序，默认按照key本身的Comparator</li>
</ol>
<h4 id="HashMap的本质"><a href="#HashMap的本质" class="headerlink" title="HashMap的本质"></a>HashMap的本质</h4><p>通过空间换时间，用一个大数组来存储value，这样就可以直接索引。</p>
<p><strong>步骤：</strong></p>
<ol>
<li>通过 key 的 equals 方法进行匹配到对应的 key</li>
<li>再通过 key 的 hashCode 方法计算出 hash 值，即该 key 对应 value 在数组中存储的索引值。</li>
</ol>
<p><strong>数组长度</strong></p>
<p>HashMap 初始化时默认的数组大小只有 16。</p>
<p>通过类似如下算法的方式，控制 hash 值的分布范围：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> key.hashCode() &amp; <span class="number">0xf</span>; <span class="comment">// 0xf = 15</span></span><br></pre></td></tr></table></figure>

<p>如果添加到超过初始长度后，内部会进行扩容。</p>
<p>&#x3D;&#x3D;为了能方便进行位运算，每次扩容后的长度会保证为 2^n^&#x3D;&#x3D;</p>
<p>为了保证性能，最少创建时就指定相应的容量</p>
<blockquote>
<p>使用 ArrayList 实现类同理</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">10000</span>);</span><br></pre></td></tr></table></figure>

<p>虽然指定容量是<code>10000</code>，但<code>HashMap</code>内部的数组长度总是2n，因此，实际数组长度被初始化为比<code>10000</code>大的<code>16384</code>（214）。</p>
<h4 id="hashcode重复"><a href="#hashcode重复" class="headerlink" title="hashcode重复"></a>hashcode重复</h4><p>假如存入了两个 key，但是非常巧合的是它们的 hashcode 重复了。</p>
<p>那么，在<code>HashMap</code>的数组中，存储的就不是一个 value 了</p>
<p><strong>而是一个由重复的 hashcode 对应 key 的 value 的 <code>List</code>，包含这两个 key 对应的键值对。</strong></p>
<p>于是查找的方法，就不只是直接索引了，而是索引之后再遍历这个 list，找到相应的 key。</p>
<p>如果冲突的概率越大，这个<code>List</code>就越长，<code>Map</code>的<code>get()</code>方法效率就越低</p>
<p>不同的<code>key</code>具有相同的<code>hashCode()</code>的情况称之为<strong>哈希冲突</strong>。</p>
<blockquote>
<p>在冲突的时候，一种最简单的解决办法是用<code>List</code>存储<code>hashCode()</code>相同的<code>key-value</code>。</p>
<p>也可以用链表，树等结构</p>
</blockquote>
<p>总之：hash 值的唯一性决定了 HashMap 的查询性能。</p>
<h4 id="对比-Hashtable"><a href="#对比-Hashtable" class="headerlink" title="对比 Hashtable"></a>对比 Hashtable</h4><ol>
<li>继承类不同 dictionary</li>
<li>提供接口不同</li>
<li>对 key-value 的 null 值</li>
<li>线程安全</li>
<li>遍历方式</li>
<li>容量分配</li>
<li>hash值计算方式</li>
</ol>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><h4 id="使用-3"><a href="#使用-3" class="headerlink" title="使用"></a>使用</h4><p><code>Set</code>用于存储不重复的元素集合，它主要提供以下几个方法：</p>
<ul>
<li>将元素添加进<code>Set&lt;E&gt;</code>：<code>boolean add(E e)</code></li>
<li>将元素从<code>Set&lt;E&gt;</code>删除：<code>boolean remove(Object e)</code></li>
<li>判断是否包含元素：<code>boolean contains(Object e)</code></li>
</ul>
<h4 id="HashSet的本质"><a href="#HashSet的本质" class="headerlink" title="HashSet的本质"></a>HashSet的本质</h4><p><code>HashSet</code>仅仅是对<code>HashMap</code>的一个简单封装，只管理key，而放入相同的Object作为value。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSet</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Set</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="comment">// 持有一个HashMap:</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;E, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 放入HashMap的value:</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.put(e, PRESENT) == <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.containsKey(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.remove(o) == PRESENT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="SortedSet"><a href="#SortedSet" class="headerlink" title="SortedSet"></a>SortedSet</h4><p>Set 是无序的，而 SortedSet 接口继承至 Set，并且是有序的。</p>
<p>实现类是：TreeSet，需要传入一个比较器，如果没有就使用 key 默认的比较器。</p>
<h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><blockquote>
<p>File类，与输入输出流都存放在Java.io包内。</p>
</blockquote>
<p>&#x3D;&#x3D;所有的输入输出类，都必须被异常处理包裹，捕捉FileNotFoundException&#x3D;&#x3D;</p>
<h5 id="1-File类"><a href="#1-File类" class="headerlink" title="1. File类"></a>1. File类</h5><p>File对象主要用来获取文件本身的一些信息，不涉及对文件的读写操作。</p>
<p><strong>构造函数</strong></p>
<ul>
<li>File(String filename);</li>
<li>File(String directoryPath,String filename);</li>
<li>File(File f，String filename);</li>
</ul>
<p>&#x3D;&#x3D;即使文件不存在，也不会报出异常&#x3D;&#x3D;</p>
<p><strong>常用方法</strong></p>
<ul>
<li>public String getName() 获取文件的名字。</li>
<li>public boolean canRead() 判断文件是否是可读的。</li>
<li>public boolean canWrite() 判断文件是否可被写入。</li>
<li>public boolean exits() 判断文件是否存在。</li>
<li>public <strong>long</strong> length() 获取文件的长度（单位是字节）。</li>
</ul>
<p>即长度为该文件内容为多少个字节，返回类型是long。</p>
<p>假如文件内容为：我是who12(整型)1000（long类型），那么读取到的length为4+3+4+8 &#x3D; 19个字节。</p>
<ul>
<li>public String getAbsolutePath() 获取文件的绝对路径。</li>
<li>public boolean isFile() 判断文件是否是一个普通文件，而不是目录。</li>
<li>public boolean isDirectroy() 判断文件是否是一个目录。</li>
</ul>
<h5 id="2-输入输出流"><a href="#2-输入输出流" class="headerlink" title="2. 输入输出流"></a>2. 输入输出流</h5><ul>
<li>FileInputStream</li>
</ul>
<p>以字节的形式读取文件</p>
<p>FileInputStream(String name);<br>FileInputStream(File file);<br>int read() 读取单个字节的数据<br>int read(byte b[]) 读取到字节数组b中，返回读取的实际字节长度，如果到达文件末尾则返回-1。<br>int read(byte b[]，int off，int len) 读取文件内容从off位置len个字节到字节数组b中</p>
<ul>
<li>FileOutputStream</li>
</ul>
<p>以字节的形式写入文件</p>
<p><strong>区别</strong> void write(byte b[],int off,int len) 从字节数组中偏移量off处取len个字节写到目的地。</p>
<ul>
<li>FileReader</li>
</ul>
<p>以字符的形式读取文件</p>
<p>nt read() 读取单个字符的数据<br>int read(char b[]) 读取到字符数组b中<br>int read(char b[]，int off，int len) 读取从off位置len个字符到字符数组b中</p>
<ul>
<li>FileWriter</li>
</ul>
<p>以字符的形式写入文件</p>
<p>使用方法类比即可</p>
<h5 id="3-缓冲流"><a href="#3-缓冲流" class="headerlink" title="3. 缓冲流"></a>3. 缓冲流</h5><p>缓冲流只能指向FileWriter或FileReader类对象，相较于提供了更多输入输出的方法，可以提高大文件（数据）的读写速度。</p>
<ul>
<li>BufferedReader，BufferedWriter</li>
</ul>
<p>readLine() 读取文本行<br>write(String s,int off,int len) 把字符串s写到文件中<br>newLine(); 向文件写入一个回行符</p>
<h5 id="4-随机访问文件流"><a href="#4-随机访问文件流" class="headerlink" title="4. 随机访问文件流"></a>4. 随机访问文件流</h5><p>RandomAccessFile类可以同时实现输入和输出操作。</p>
<p>构造函数：</p>
<p>RandomAccessFile(String name,String mode) ;<br>RandomAccessFile(File file,String mode) ;</p>
<p>mode指对文件的操作方式，如：r 表示只读，rw表示读和写，w表示写入。</p>
<p>使用方法：</p>
<p>read();</p>
<p>writeInt(); writeLong();</p>
<p>seek(long a)  定位RandomAccessFile流的读写位置<br>getFilePointer() 获取流的当前读写位置</p>
<p><strong>还有对象流（用来输入输出对象）等一些乱七八糟的</strong></p>
<h2 id="日期与时间"><a href="#日期与时间" class="headerlink" title="日期与时间"></a>日期与时间</h2><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><h2 id="加密与安全"><a href="#加密与安全" class="headerlink" title="加密与安全"></a>加密与安全</h2><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>多线程可以让程序同时执行多个任务。</p>
<p>但它的本质是<strong>多个任务轮流进行</strong>，比如让浏览器执行0.001秒，让QQ执行0.001秒，再让音乐播放器执行0.001秒，在人看来，CPU就是在同时执行多个任务。</p>
<p>即使是多核CPU，因为任务的数量往往多于CPU的核数，所以任务也是交替进行的。 </p>
<p><strong>为什么多线程操作在程序中往往比单线程快？</strong></p>
<p>以MySQL插入数据为例</p>
<p>因为MySQL内部将调度任务分为了多个线程，如果插入操作是单线程的，就无法占满所有的线程。</p>
<p>相当于给你10个工人，你却只用了一个工人。</p>
<blockquote>
<p>为什么MySQL内部需要多线程？</p>
<p>可能是因为有一些操作需要同时进行，如守护线程 :question:</p>
</blockquote>
<p>总之：在应用多线程中间件（到达目的地的管道）时，同时使用多线程操作才会比单线程快。</p>
<h3 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a><strong>进程与线程</strong></h3><p><img src="/assets/image-20240409104301471.png" alt="image-20240409104301471"></p>
<p>在计算机中，<strong>一个任务整体称为一个进程</strong>。</p>
<p>例如，浏览器就是一个进程，视频播放器是另一个进程，类似的，音乐播放器和Word都是进程。</p>
<p>一个任务整体（进程）里可以包含多个子任务（线程）。</p>
<p>例如，浏览器可以打开多个窗口，同时查看不同网站的内容，此时浏览器进程程执行了多个显示窗口的线程。</p>
<p><strong>进程与线程的关系</strong>：一个进程可以包含一个或多个线程，但<strong>至少</strong>会有一个线程。</p>
<blockquote>
<p><strong>操作系统调度的最小任务单位其实不是进程，而是线程。</strong></p>
</blockquote>
<p><strong>多进程和多线程对比</strong>：</p>
<p>多进程的缺点：</p>
<ol>
<li><p>开销大，创建进程开销大，尤其是在Windows系统上；</p>
</li>
<li><p>通信慢，进程间通信 比 线程间通信要慢，因为线程间通信就是读写同一个变量，速度很快。</p>
</li>
</ol>
<p>多进程的优点：</p>
<ol>
<li><p>稳定性高，多进程稳定性比多线程高，</p>
<p>因为在多进程的情况下，一个进Java程崩溃不会影响其他进程，而在多线程的情况下，任何一个线程崩溃会直接导致整个进程崩溃。</p>
</li>
</ol>
<h3 id="JVM-多线程"><a href="#JVM-多线程" class="headerlink" title="JVM 多线程"></a>JVM 多线程</h3><p>Java 语言内置了多线程支持，一个Java程序实际上是一个JVM进程。</p>
<p>JVM进程用一个主线程来执行<code>main()</code>方法，在<code>main()</code>方法内部也可以启动多个子线程。</p>
<p>此外，JVM还有负责垃圾回收的其他工作线程等。</p>
<p>和单线程相比，<strong>多线程编程的特点</strong>在于：多线程经常需要读写共享数据，并且需要同步。</p>
<h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><p><strong>创建步骤：</strong></p>
<ol>
<li>实例化一个Thread类对象，重写 run() 方法。</li>
<li>再调用Thread对象的start()方法，开启一个新线程。</li>
<li>线程启动后，会自动调用Thread对象的 run() 方法。</li>
</ol>
<p>在这种创建方法中，run方法体的内容就代表这该线程需要执行的任务。</p>
<p><strong>重写 run 的几种方法：</strong></p>
<ol>
<li>继承<code>Thread</code>类，重写<code>run()</code>方法：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start new thread!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>创建<code>Thread</code>实例时，传入一个<code>Runnable</code>实例：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">        t.start(); <span class="comment">// 启动新线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start new thread!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>或者直接传入Runable接口匿名类</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>也可以使用 Java 8 后的 lambda 表达式</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>又或者使用T创建 Thread 匿名类，重写run方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：</p>
<ul>
<li><p>在通过start()方法启动新线程后，该线程不一定立即执行。</p>
</li>
<li><p>直接调用线程的run()方法，无法启动新线程，只是执行一个普通方法而已。</p>
<p>线程的开启由 start() 方法代理，执行 run() 方法内容。</p>
</li>
</ul>
<p><strong>线程休眠</strong></p>
<p>通过调用 <code>Thread.sleep(milliseconds)</code> 静态方法，可以使线程休眠 x 毫秒</p>
<p>线程休眠方法会抛出 <code>InterruptedException</code> checked异常，必须显式捕获异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>设置线程的优先级</strong></p>
<p>可以在线程内部调用 <code>Thread.setPriority(n)</code>设置线程的优先级（1 - 10），默认值是5。</p>
<p>优先级高的线程被操作系统调度的优先级较高。</p>
<p>操作系统对高优先级线程可能调度更频繁，<strong>但无法确保高优先级的线程一定会先执行。</strong></p>
<h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><p>一个新的线程开启后，只会执行一次 run 方法，执行完毕代表该线程结束。</p>
<p>线程的状态有以下几种：</p>
<ul>
<li>New：新创建的线程，尚未执行；</li>
<li>Runnable：运行中的线程，正在执行<code>run()</code>方法的Java代码；</li>
<li>Blocked：运行中的线程，因为某些操作被阻塞而挂起；</li>
<li>Waiting：运行中的线程，因为某些操作在等待中；</li>
<li>Timed Waiting：运行中的线程，因为执行<code>sleep()</code>方法正在计时等待；</li>
<li>Terminated：线程已终止，因为<code>run()</code>方法执行完毕。</li>
</ul>
<p><img src="/assets/image-20240409113233199.png" alt="image-20240409113233199"></p>
<p>当线程启动后，它可以在<code>Runnable</code>、<code>Blocked</code>、<code>Waiting</code>和<code>Timed Waiting</code>这几个状态之间切换，直到最后变成<code>Terminated</code>状态，线程终止。</p>
<p><strong>线程终止的原因</strong>有：</p>
<ul>
<li>线程正常终止：<code>run()</code>方法执行到<code>return</code>语句返回；</li>
<li>线程意外终止：<code>run()</code>方法因为未捕获的异常导致线程终止；</li>
<li>对某个线程的<code>Thread</code>实例调用<code>stop()</code>方法强制终止（强烈不推荐使用）。</li>
</ul>
<h3 id="等待线程"><a href="#等待线程" class="headerlink" title="等待线程"></a><strong>等待线程</strong></h3><p>一个线程还可以等待另一个线程直到其运行结束。</p>
<p>例如，<code>main</code>线程在启动<code>t</code>线程后，可以通过<code>t.join()</code>等待<code>t</code>线程结束后再继续运行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;start&quot;</span>);</span><br><span class="line">        t.start();</span><br><span class="line">        t.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>join</code> <strong>含义理解</strong>：</p>
<p>t 线程加入 main 线程任务中，作为任务执行的一个步骤，只有等 t 执行完毕，main 线程任务的步骤才可以继续往下执行。</p>
<p>&#x3D;&#x3D;改正：不是等 t 执行完毕，而是等该线程调度结束，例如，死循环线程不会一直执行。&#x3D;&#x3D;</p>
<p>如果<code>t</code>线程已经结束，对实例<code>t</code>调用<code>join()</code>会立刻返回。</p>
<p>此外，<code>join(long)</code>的重载方法也可以指定一个等待时间，超过等待时间后就不再继续等待（就不要它加入了嘿嘿）。</p>
<h3 id="中断线程"><a href="#中断线程" class="headerlink" title="中断线程"></a>中断线程</h3><p>如果线程需要执行一个 <strong>长时间任务</strong>，就可能需要能<strong>控制的</strong>中断线程，确保这个任务是可控的。</p>
<p>中断线程有三种方法：</p>
<ol>
<li><strong>调用线程对象的<code>interrupt()</code>方法</strong></li>
</ol>
<p>通过调用interrupt方法，给线程传递一个中断的信号。</p>
<p><strong>目标线程需要通过调用继承 Thread 的 <code>isInterrupted()</code> 方法，反复检测自身状态是否是 interrupted 状态。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        t.start();</span><br><span class="line">        Thread.sleep(<span class="number">1</span>); 	<span class="comment">// 暂停 Main 线程1毫秒，确保线程 t 运行一次再结束。</span></span><br><span class="line">        t.interrupt(); 		<span class="comment">// 中断 t 线程</span></span><br><span class="line">        t.join(); 			<span class="comment">// 将 t 线程加入到 main 线程中，确保 “end” 最后输出</span></span><br><span class="line">        System.out.println(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 检测中断信号</span></span><br><span class="line">        <span class="keyword">while</span> (! isInterrupted()) &#123;</span><br><span class="line">            n ++;</span><br><span class="line">            System.out.println(n + <span class="string">&quot; hello!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong>首先开启了一个新的线程 t，该线程监听中断信号不断循环输出 hello（模拟长时间任务），然后 main 线程发出中断信号，同时 t 线程中的循环监听到了中断信号，随后停止运行，重新回到 main 线程继续执行，最后输出 “end”。</p>
<p><strong>注意：</strong>如果线程内没有检测中断信号，只是调用 <code>interrupt()</code> 方法线程是不会中断的。</p>
<p><strong>应用场景：</strong></p>
<p>首先需要注意的是，通过 interrupt 方法中断线程的前提，是目标线程必须时刻监听中断信号。</p>
<p>因此，目标线程应该将<strong>长时间任务转化为分片的任务</strong>，循环进行，同时监听中断信号。</p>
<ol start="2">
<li><strong>监听目标线程内其他线程的 join 方法。</strong></li>
</ol>
<p>假设有两个线程 A，B。</p>
<p>A 线程中对 B 线程调用了 join() 方法，而此时 A 线程又收到了 interrupt 信号</p>
<p>那么 join 方法就会抛出一个 <code>InterruptedException</code> 异常，A 线程就会结束运行。</p>
<p><strong>结束点</strong>：目标线程内部其他线程的 join 时刻</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        <span class="comment">// 开启线程 A</span></span><br><span class="line">        a.start();</span><br><span class="line">        a.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        <span class="comment">// 开启线程 B</span></span><br><span class="line">        b.start();</span><br><span class="line">        <span class="comment">// 捕获异常，但不做处理</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            b.join();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;&#125;</span><br><span class="line">        <span class="comment">// 中断线程 B</span></span><br><span class="line">        b.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(!isInterrupted())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;run&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">break</span>;	<span class="comment">// 如果不加break，概率导致死循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>为什么线程 B 监听了中断信号，在捕获异常时还需要 break？</strong></p>
<p>因为在对 B 线程调用 interrupt 方法时，如果线程 B 本身就在 waiting，sleeping 状态时，内部的 sleep 方法会抛出 InterrputedException 异常，并重置中断状态（isInterrupted&#x3D;false），所以要在捕获到异常时break。</p>
<p>:question: 上方答案存疑</p>
<ol start="3">
<li><strong>定义标志变量结束线程</strong></li>
</ol>
<p>例如，定义一个变量 running，然后在目标线程中监听其值来决定是否结束线程（类似 Thread 自身维护的 isInterrupt）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">HelloThread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloThread</span>();</span><br><span class="line">        t.start();</span><br><span class="line">        Thread.sleep(<span class="number">1</span>);</span><br><span class="line">        t.running = <span class="literal">false</span>; <span class="comment">// 将标志变量设置为false，结束线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HelloThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">running</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (running) &#123;</span><br><span class="line">            n ++;</span><br><span class="line">            System.out.println(n + <span class="string">&quot; hello!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;end!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>running 在此处代码中，同时作为了 main 和 t 线程之间共享的变量。</p>
<p><strong>变量的更新机制</strong></p>
<p>在Java虚拟机中，变量是保存在主内存的。</p>
<p>每个线程<strong>访问</strong>变量时，会先生成一个副本保存在自己的工作内存中。</p>
<p>如果线程<strong>修改</strong>了变量的值，虚拟机会在不确定的时刻再把修改后的值写回到主内存，存在线程之间变量不一致的问题！</p>
<p>例如，running &#x3D; false，然后 main 修改其为 true，但是没有写到主内存，那么此时线程 A 访问 running 仍会的到 true，而不会立刻结束线程，只有在回写到主内存后才会结束线程。</p>
<p>而 <code>volatile</code> 关键字的目的是告诉虚拟机：</p>
<ul>
<li>每次访问变量时，总是获取主内存的最新值；</li>
<li>每次修改变量后，立刻回写到主内存。</li>
</ul>
<p>这样就可以确保线程之间变量的一致性。</p>
<h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p>有一种线程的目的就是无限循环，无法设定结束条件。</p>
<p>例如，一个定时任务的线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TimerThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(LocalTime.now());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>已知 JVM 需要所有线程都运行结束后，才会退出。</strong> </p>
<p>如果存在这样一个无限执行的线程，且与任务无关，但是又需要在所有任务结束后，关闭 JVM 终止程序，该如何操作呢。</p>
<p>答案：守护线程。</p>
<p><strong>守护线程是指为其他线程服务的线程。</strong></p>
<p><strong>JVM 关闭时无需关心守护线程是否结束，只要其他线程结束就终止程序，同时顺带关闭守护线程</strong>。</p>
<p>创建守护线程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">t.setDaemon(<span class="literal">true</span>);</span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure>

<p>目标线程通过调用 setDeamon(true)；来将本线程设为守护线程。</p>
<p><strong>注意：</strong>守护线程不应该持有任何需要手动关闭的资源，如打开文件。因为该线程何时关闭是不确定的，无法释放资源。</p>
<h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><p><strong>同步：</strong>指两个变量始终保持一定的相对关系，可以是同时，也可以是完成同一个操作一前一后（你先做，再到我做）。</p>
<p>从 volatile 那一节中知道，如果多个线程同时读写共享的变量，会出现数据不一致的问题。</p>
<p>假设有两个加法线程，同时操作同一个变量，都执行加法操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n = n + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>这一行语句被 JVM 解析成 3 条指令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ILOAD</span><br><span class="line">IADD</span><br><span class="line">ISTORE</span><br></pre></td></tr></table></figure>

<p><img src="/assets/image-20240410233303176.png" alt="image-20240410233303176"></p>
<p>如果线程 1 在LOAD后就被中断，转而执行线程 2，此时 n 还是 100，就会出现两个线程同时写入 101 给 n，而不是正常的 102。</p>
<p><strong>如何让线程 2 每次都基于线程 1 的结果继续运算呢？</strong></p>
<p>只需要保证当一个线程进行 LOAD, ADD, STORE 操作时，其他线程必须等待这一个线程执行完之后再依次执行，确保操作的<strong>原子性</strong>。</p>
<p>这样的操作被称为<strong>原子操作</strong></p>
<p><img src="/assets/image-20240410233957456.png" alt="image-20240410233957456"></p>
<p>这样的操作称为加锁，解锁。</p>
<p>通过加锁和解锁的操作，就能保证3条指令执行期间只有一个线程，不会有其他线程会进入此指令区间。</p>
<p>只有在执行线程解锁，将锁释放后，其他线程才能获得锁并执行这 3 条指令。</p>
<h4 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a><strong>synchronized</strong></h4><p>Java 使用 <code>synchronized</code> 关键字对一个对象进行加锁，保证了代码块在任意时刻最多只有一个线程能执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">add</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AddThread</span>();</span><br><span class="line">        <span class="type">var</span> <span class="variable">dec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DecThread</span>();</span><br><span class="line">        add.start();</span><br><span class="line">        dec.start();</span><br><span class="line">        add.join();</span><br><span class="line">        dec.join();</span><br><span class="line">        System.out.println(Counter.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Counter.lock) &#123;</span><br><span class="line">                Counter.count += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DecThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Counter.lock) &#123;</span><br><span class="line">                Counter.count -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里以 lock 作为锁，每个线程执行加减操作时需要先获取锁，如果这把锁被其他线程占用了，就需要等待锁被释放后，重新获取锁才能执行。</p>
<h4 id="保持线程之间同步的步骤："><a href="#保持线程之间同步的步骤：" class="headerlink" title="保持线程之间同步的步骤："></a><strong>保持线程之间同步的步骤：</strong></h4><ol>
<li>划出需要同步的代码块；</li>
<li>选择同一个对象作为锁；</li>
<li>使用 <code>synchronized(lockObject) &#123; ... &#125;</code> 包裹代码块。</li>
</ol>
<p><strong>注意</strong>：</p>
<ul>
<li>锁的对象必须是同一个，如果不同就会有两把锁，出现两个线程异步执行的情况。</li>
<li>获取锁和释放锁需要消耗一定的时间，所以，<code>synchronized</code>会降低程序的执行效率、性能。</li>
<li>不用担心同步过程中会抛出异常，锁会被正确释放。</li>
</ul>
<h4 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a><strong>原子操作</strong></h4><p>具有原子性的操作被称为原子操作。原子：不可以再被分解的物质。</p>
<p><strong>原子操作是指不能被中断的一个或一系列操作。</strong></p>
<p>对于原子操作不需要使用锁，因为每一个原子操作，都是在“一下”完成的，不被其他线程打断。</p>
<p>JVM规范定义了几种原子操作：</p>
<ul>
<li>基本类型（<code>long</code>和<code>double</code>除外，没有明确规定）赋值，例如：<code>int n = m</code>；</li>
<li>引用类型赋值，例如：<code>List&lt;String&gt; list = anotherList</code>。</li>
</ul>
<p>但如果是多行赋值操作，就需要给操作加锁（对象本身）了。</p>
<p>锁的对象随实际需要改变，这里假设多个线程用到了同一个 Pair 实例对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> x，<span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.x = x;</span><br><span class="line">            <span class="built_in">this</span>.y = y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 同时，读的操作也许加锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] get() &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="type">int</span>[] copy = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">            copy[<span class="number">0</span>] = x;</span><br><span class="line">            copy[<span class="number">1</span>] = y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果“写”操作不加锁，就会出现当 A 线程给 pair 对象的 x 赋值时，被 B 线程打断并重新把 x 赋值为另一个值，这时候 A 线程的逻辑就会不严谨。</p>
<p> 假设当前坐标是<code>(100, 200)</code>。</p>
<p>那么当设置新坐标为<code>(110, 220)</code>时，如果“读”操作不加锁，读到的值可能有：</p>
<ul>
<li>(100, 200)：x，y更新前；</li>
<li>(110, 200)：x更新后，y更新前就调用了 pair 的 get 方法；</li>
<li>(110, 220)：x，y更新后。</li>
</ul>
<p>加锁可以保证读的值不被污染，并且是最新。</p>
<p><strong>有时也可以巧妙的将非原子操作转换为原子操作</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] pair;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> x，<span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="comment">// 局部变量不需要同步</span></span><br><span class="line">        <span class="type">int</span>[] ps = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; x，y &#125;; </span><br><span class="line">        <span class="built_in">this</span>.pair = ps;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] get() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;x, y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 ps 是局部变量，不被其他线程可见，不存在被其他线程中途修改的问题。</p>
<p><strong>每个线程都会有各自的局部变量，互不影响，并且互不可见，并不需要同步。</strong></p>
<p>将多行赋值改为引用赋值，确保操作被“一次”执行，保证原子性。</p>
<p>同理这里的读操作也转为了原子操作，x,y 每次都同步读取，不存在读了线程 A 设置的 x 后，y 又变成了线程 B 设置的。</p>
<p>缺点就是无法保证每次都是最新的状态，可以再添加 <code>volatile</code> 关键字，确保实时性。</p>
<p>看到这里应该就明白 <code>volatile</code> 和 <code>synchronized</code> 之间的区别的吧。</p>
<p>区别：</p>
<ol>
<li>volatile 只用于保证状态更新后能被实时写入主内存，保证状态的实时性。</li>
<li>synchronized 则用于保证一连串操作同时只有一个线程在执行。</li>
</ol>
<p>如果用 volatile 来限制 n &#x3D; n + 1，只能确保每个线程更新后能立马写回主内存，但无法确保每个线程用来更新的值是其他线程执行完之后的值，还是操作了同一个值。</p>
<p>总之，volatile 只注重变量被赋值后“真正”更新的实时性。</p>
<h4 id="不可变对象无需同步"><a href="#不可变对象无需同步" class="headerlink" title="不可变对象无需同步"></a>不可变对象无需同步</h4><p>如果多线程读写的是一个不可变对象（如String，List），那么无需同步。</p>
<p>因为不会修改这个对象的状态，而是修改对象本身。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Data &#123;</span><br><span class="line">    List&lt;String&gt; names;</span><br><span class="line">    void set(String[] names) &#123;</span><br><span class="line">        this.names = List.of(names);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;String&gt; get() &#123;</span><br><span class="line">        return this.names;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到<code>set()</code>方法内部创建了一个不可变<code>List</code>，这个<code>List</code>包含的对象也是不可变对象<code>String</code>，因此，整个<code>List&lt;String&gt;</code>对象都是不可变的，因此读写均无需同步。</p>
<p>对于读写的操作的同步问题</p>
<p>其实只需要多加思考如何保证写的操作是“阶段性”的，那么读就很容易保持阶段性（同步）。</p>
<h4 id="总结多线程"><a href="#总结多线程" class="headerlink" title="总结多线程"></a><strong>总结多线程</strong></h4><p>深入理解多线程还需理解变量在栈上的存储方式，基本类型和引用类型的存储方式也不同。</p>
<p>什么时候需要考虑多线程问题？</p>
<ol>
<li>并发高的场景</li>
<li>修改线程共享变量（对象变量等）的时候</li>
</ol>
<p>为什么需要多线程？</p>
<p>每个任务分别做一点，和任务交替完成，总和不是一样的吗？</p>
<p>是的，但是前提是这写些个任务之间是可以“相加”的关系，前后结果没有太大联系。</p>
<p>但如果前一个任务和后一个任务中，<strong>有一部分成果是一致的呢？基于某一个相同的结果呢？</strong></p>
<p>&#x3D;&#x3D;那多线程带来的效率就是幂级的提升&#x3D;&#x3D;</p>
<h3 id="synchronized-方法"><a href="#synchronized-方法" class="headerlink" title="synchronized 方法"></a>synchronized 方法</h3><p>在业务逻辑中，如果自由的自定义 <code>synchronized</code> 代码块，会显得代码逻辑混乱。</p>
<p>因此，常常将同步的行为整体封装为一个类，如计数器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">            count += n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dec</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">            count -= n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该计数器的加减操作以自身 this 实例为锁，支持同时创建多个实例，每个实例内部维护各自的 COUNT 不因为线程而错乱。</p>
<p>如果一个类被设计为允许 多线程 正确访问，我们就说这个类是<strong>线程安全</strong>的。</p>
<p>还有一些不变类，例如<code>String</code>，<code>Integer</code>，<code>LocalDate</code>，它们的所有成员变量都是<code>final</code>，多线程同时访问时只能读不能写，这些不变类也是线程安全的。</p>
<p>最后，类似<code>Math</code>这些只提供静态方法，没有成员变量的类，也是线程安全的。</p>
<p>事实上大部分情况下，大部分类，例如<code>ArrayList</code>，都是非线程安全的类，我们不能在多线程中安全的使用它们。</p>
<p><strong>即使是上升为 List 引用，也是线程非安全的，因为内部的作用域还是 ArrayList 本身</strong></p>
<blockquote>
<p>只能访问，不能插入和修改元素，因为 length 和 元素内存值 会不一致。</p>
</blockquote>
<p>&#x3D;&#x3D;没有特殊说明时，一个类默认是非线程安全的。&#x3D;&#x3D;</p>
<blockquote>
<p>因为内置线程安全会影响性能，应交由开发者自由控制。</p>
</blockquote>
<p><strong>synchronized 方法修饰符</strong></p>
<p>当锁的对象是 this 实例时，以下两种写法等价。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123; <span class="comment">// 锁住this</span></span><br><span class="line">        count += n;</span><br><span class="line">    &#125; <span class="comment">// 解锁</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> n)</span> &#123; <span class="comment">// 锁住this</span></span><br><span class="line">    count += n;</span><br><span class="line">&#125; <span class="comment">// 解锁</span></span><br></pre></td></tr></table></figure>

<p><strong>static 方法加锁</strong></p>
<p>由于 static 方法没有 this 实例，因此其锁住的是一个类的 Class 实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(Counter.class) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>Java的线程锁是可重入的锁。</p>
<p><strong>可重入锁</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            dec(-n);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            count += n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">dec</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        count += n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码先执行 add，然后在 add 内部再执行 dec，可以看到两个方法都是以 this 为锁对象的。</p>
<p><strong>像这种同一把锁可以允许同一个线程多次获取的情况，就是可重入锁。</strong></p>
<p><strong>如果不同线程获取不同锁呢？</strong></p>
<p>会造成 <strong>死锁</strong> 发生。</p>
<p>死锁通俗来说，就是这把锁无法被再次正常使用了，获取不到也释放不了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> m)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(lockA) &#123; <span class="comment">// 获得lockA的锁</span></span><br><span class="line">        <span class="built_in">this</span>.value += m;</span><br><span class="line">        <span class="keyword">synchronized</span>(lockB) &#123; <span class="comment">// 获得lockB的锁</span></span><br><span class="line">            <span class="built_in">this</span>.another += m;</span><br><span class="line">        &#125; <span class="comment">// 释放lockB的锁</span></span><br><span class="line">    &#125; <span class="comment">// 释放lockA的锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dec</span><span class="params">(<span class="type">int</span> m)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(lockB) &#123; <span class="comment">// 获得lockB的锁</span></span><br><span class="line">        <span class="built_in">this</span>.another -= m;</span><br><span class="line">        <span class="keyword">synchronized</span>(lockA) &#123; <span class="comment">// 获得lockA的锁</span></span><br><span class="line">            <span class="built_in">this</span>.value -= m;</span><br><span class="line">        &#125; <span class="comment">// 释放lockA的锁</span></span><br><span class="line">    &#125; <span class="comment">// 释放lockB的锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设同时有两个线程，分别执行 add 和 dec 方法，首先都获取到了 lockA 和 lockB，就会出现这样一个情况：</p>
<ul>
<li>线程1：准备获得<code>lockB</code>，失败，等待中；</li>
<li>线程2：准备获得<code>lockA</code>，失败，等待中。</li>
</ul>
<p>两个线程都因为想要获取对方的锁，而无限等待，造成死锁。</p>
<p><strong>死锁发生后，没有任何机制能解除死锁，只能强制结束JVM进程。</strong><br>&#x3D;&#x3D;如何避免死锁&#x3D;&#x3D;</p>
<p>答案：只要保证获取锁的顺序一致。</p>
<p>所有线程都遵循这个顺序同步，只要存在线程获取到锁开始了，其他线程就必须等待，不允许步骤交叉进行。</p>
<p>将 dec 方法改为如下代码，即可避免死锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dec</span><span class="params">(<span class="type">int</span> m)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(lockA) &#123; <span class="comment">// 获得lockA的锁</span></span><br><span class="line">        <span class="built_in">this</span>.value -= m;</span><br><span class="line">        <span class="keyword">synchronized</span>(lockB) &#123; <span class="comment">// 获得lockB的锁</span></span><br><span class="line">            <span class="built_in">this</span>.another -= m;</span><br><span class="line">        &#125; <span class="comment">// 释放lockB的锁</span></span><br><span class="line">    &#125; <span class="comment">// 释放lockA的锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，大部分情况下的业务逻辑都比这个复杂，可能这个服务和另一个服务交叉获取了锁，无法被明显的发现而造成死锁。</p>
<p>这时候可以借助第三方工具，如 redis，给“锁”设置一个过期时间，超出过期时间后就自动释放。</p>
<h3 id="wait和notify"><a href="#wait和notify" class="headerlink" title="wait和notify"></a>wait和notify</h3><p>synchronized 解决了多线程竞争问题，但是没有解决协调问题。</p>
<p>竞争：多个线程争夺执行权</p>
<p>协调：多个线程之间配合交换执行权</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TaskQueue</span> &#123;</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">addTask</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.queue.add(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title function_">getTask</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码看上去没有问题：<code>getTask()</code>内部先判断队列是否为空，如果为空，就循环等待，直到另一个线程往队列中放入了一个任务，<code>while()</code>循环退出，就可以返回队列的元素了。</p>
<p>但实际上<code>while()</code>循环永远不会退出。因为线程在执行<code>while()</code>循环时，已经在<code>getTask()</code>入口获取了<code>this</code>锁，其他线程根本无法调用<code>addTask()</code>，因为<code>addTask()</code>执行条件也是获取<code>this</code>锁。</p>
<p>在队列为空的时候 getTask 获取了锁并进入了死循环，导致永远无法 addTask，造成了逻辑死锁。</p>
<p><strong>正确的逻辑</strong>：一个线程可以调用<code>getTask()</code>从队列中获取任务。如果队列为空，则该线程应该等待，直到其他线程往队列中添加了任务之后被唤醒。</p>
<p><strong>借助 wait 和 notify 改造代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TaskQueue</span> &#123;</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">addTask</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.queue.add(s);</span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title function_">getTask</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">            <span class="built_in">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当队列为空时，该线程调用 wait 方法等待。</p>
<p><strong>wait 期间会<em>释放</em>线程获得的锁，<code>wait()</code>方法返回后，线程又会重新试图获得锁。</strong></p>
<p><code>wait()</code>方法必须在当前获取的锁对象上调用，这里获取的是<code>this</code>锁，因此调用<code>this.wait()</code>。</p>
<p><strong>notifyAll 和 notify</strong></p>
<p>内部调用了<code>this.notifyAll()</code>而不是<code>this.notify()</code>，使用<code>notifyAll()</code>将唤醒所有当前正在<code>this</code>锁等待的线程，而<code>notify()</code>只会唤醒其中一个（具体哪个依赖操作系统，有一定的随机性）。</p>
<p>通常来说，<code>notifyAll()</code>更安全。有些时候，如果我们的代码逻辑考虑不周，用<code>notify()</code>会导致只唤醒了一个线程，而其他线程可能永远等待下去醒不过来了。</p>
<p><strong>注意：</strong></p>
<p>在<code>while()</code>循环中调用<code>wait()</code>，而不是<code>if</code>语句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title function_">getTask</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (queue.isEmpty()) &#123;</span><br><span class="line">        <span class="built_in">this</span>.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述的写法是错误的，因为可能会有多个线程同时 getTask，而没有获取到锁的线程，会再次进入 wait，如果这里是 if 的话，当线程被唤醒后不会继续判断，而是继续往下执行。</p>
<h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a><strong>ReentrantLock</strong></h3><p>Java 5开始，引入了 <code>java.util.concurrent</code> 并发工具包。</p>
<p>它提供了大量更高级的并发功能，能大大简化多线程程序的编写。</p>
<p>虽然 Java 可以直接用<code>synchronized</code>关键字加锁，但这种锁有很大的缺点。</p>
<ol>
<li>使用起来不方便，需要嵌套代码，非常“重量级”</li>
<li>获取锁失败时必须一直等待，没有额外的尝试，等待超时机制。</li>
</ol>
<p><code>java.util.concurrent.locks</code> 包提供的 <code>ReentrantLock</code> 可以用于替代 <code>synchronized</code> 加锁，也是一把可重入锁。</p>
<p>分别给出 synchronized 和 ReentrantLock 加锁代码：</p>
<p><strong>synchronized</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">            count += n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ReentrantLock</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            count += n;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为确保锁住是 this 实例，将 ReentrantLock 声明为对象属性。</p>
<p><strong>对比</strong></p>
<p>因为<code>synchronized</code>是Java语言层面提供的语法，所以我们不需要考虑异常。</p>
<p>而<code>ReentrantLock</code>是Java代码实现的锁，我们就必须先手动获取锁，然后在确保无论是否发生异常，都要在<code>finally</code>中正确释放锁。</p>
<p><strong>尝试机制</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尝试获取锁，最多等待 1 秒</span></span><br><span class="line"><span class="keyword">if</span> (lock.tryLock(<span class="number">1</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 tryLock 尝试获取锁并设置尝试的时间，返回一个 boolean 值。</p>
<p>如果超时返回 false，可以进行一些额外的操作，而不是一直等待下去。</p>
<h3 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h3><p>synchronized 具有 wait 和 notify 功能，ReentrantLock 该如何呢？</p>
<p>同样提供了 Condition 类，可以使用<code>Condition</code>对象来实现<code>wait</code>和<code>notify</code>的功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TaskQueue</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addTask</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            queue.add(s);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getTask</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> queue.remove();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用方式和 wait 和 notify 类似。</p>
<p>注意：引用的<code>Condition</code>对象必须从<code>Lock</code>实例的<code>newCondition()</code>返回，这样才能正确协调获取这同一把锁的线程。</p>
<p><code>Condition</code>提供的<code>await()</code>、<code>signal()</code>、<code>signalAll()</code>原理和<code>synchronized</code>锁对象的<code>wait()</code>、<code>notify()</code>、<code>notifyAll()</code>是一致的，并且其行为也是一样的：</p>
<ul>
<li><code>await()</code>会释放当前锁，进入等待状态；</li>
<li><code>signal()</code>会唤醒某个等待线程；</li>
<li><code>signalAll()</code>会唤醒所有等待线程；</li>
<li>唤醒线程从<code>await()</code>返回后需要重新获得锁。</li>
</ul>
<p>此外，和<code>tryLock()</code>类似，<code>await()</code>可以在等待指定时间后，如果还没有被其他线程通过<code>signal()</code>或<code>signalAll()</code>唤醒，可以自己醒来：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (condition.await(1, TimeUnit.SECOND)) &#123;</span><br><span class="line">    // 被其他线程唤醒</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // 指定时间内没有被其他线程唤醒</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a>ReadWriteLock</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] counts = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inc</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            counts[index] += <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] get() &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Arrays.copyOf(counts, counts.length);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ReentrantLock 保证了某一段操作同时只有一个线程在执行，但是对于不影响内存的操作：“读”，难道也只能同时允许一个线程进入吗？？</p>
<p>但是如果不加锁，又会出现数据不一致的情况。</p>
<p>实际上我们想要的是：允许多个线程同时读，但只要有一个线程在写，其他线程就必须等待：</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">读</th>
<th align="left">写</th>
</tr>
</thead>
<tbody><tr>
<td align="left">读</td>
<td align="left">允许</td>
<td align="left">不允许</td>
</tr>
<tr>
<td align="left">写</td>
<td align="left">不允许</td>
<td align="left">不允许</td>
</tr>
</tbody></table>
<p>使用<code>ReadWriteLock</code>可以解决这个问题，它保证：</p>
<ul>
<li>只允许一个线程写入（其他线程既不能写入也不能读取）；</li>
<li>没有写入时，多个线程允许同时读（提高性能）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReadWriteLock</span> <span class="variable">rwlock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="comment">// 获取读锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">rlock</span> <span class="operator">=</span> rwlock.readLock();</span><br><span class="line">    <span class="comment">// 获取写锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">wlock</span> <span class="operator">=</span> rwlock.writeLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] counts = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inc</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        wlock.lock(); <span class="comment">// 加写锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            counts[index] += <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            wlock.unlock(); <span class="comment">// 释放写锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] get() &#123;</span><br><span class="line">        rlock.lock(); <span class="comment">// 加读锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Arrays.copyOf(counts, counts.length);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rlock.unlock(); <span class="comment">// 释放读锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>内部应该是维护了一个状态量，同时监控读写锁的状态，满足 无写-无读 的情况才可以写</p>
</blockquote>
<p>使用<code>ReadWriteLock</code>时，适用条件是同一个数据，有大量线程读取，但仅有少数线程修改。</p>
<p>例如，一个论坛的帖子，回复可以看做写入操作，它是不频繁的，但是，浏览可以看做读取操作，是非常频繁的，这种情况就可以使用<code>ReadWriteLock</code>。</p>
<h3 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h3><p><code>ReadWriteLock</code> 仍然存在效率问题。</p>
<p>如果有线程正在读，写线程需要等待读线程释放锁后才能获取写锁，即读的过程中不允许写，这是一种悲观的读锁。</p>
<p>悲观：读的过程中一定会有其他线程执行写操作，为确保一致性应拒绝。</p>
<p>而 StampedLock 是一种乐观锁，允许在读的同时进行写；但是这样会造成数据不一致，需要额外编写代码维护一致性。</p>
<p>乐观：读的过程不会被写入，允许写操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">StampedLock</span> <span class="variable">stampedLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StampedLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">(<span class="type">double</span> deltaX, <span class="type">double</span> deltaY)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> stampedLock.writeLock(); <span class="comment">// 获取写锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            x += deltaX;</span><br><span class="line">            y += deltaY;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            stampedLock.unlockWrite(stamp); <span class="comment">// 释放写锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">distanceFromOrigin</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> stampedLock.tryOptimisticRead(); <span class="comment">// 获得一个乐观读锁</span></span><br><span class="line">        <span class="comment">// 注意下面两行代码不是原子操作</span></span><br><span class="line">        <span class="comment">// 假设x,y = (100,200)</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">currentX</span> <span class="operator">=</span> x;</span><br><span class="line">        <span class="comment">// 此处已读取到x=100，但x,y可能被写线程修改为(300,400)</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">currentY</span> <span class="operator">=</span> y;</span><br><span class="line">        <span class="comment">// 此处已读取到y，如果没有写入，读取是正确的(100,200)</span></span><br><span class="line">        <span class="comment">// 如果有写入，读取是错误的(100,400)</span></span><br><span class="line">        <span class="keyword">if</span> (!stampedLock.validate(stamp)) &#123; <span class="comment">// 检查乐观读锁后是否有其他写锁发生</span></span><br><span class="line">            stamp = stampedLock.readLock(); <span class="comment">// 获取一个悲观读锁</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                currentX = x;</span><br><span class="line">                currentY = y;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                stampedLock.unlockRead(stamp); <span class="comment">// 释放悲观读锁</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.sqrt(currentX * currentX + currentY * currentY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给乐观读的操作加一个 validate 确保数据一致性，如果有其他线程写入，则获取悲观读锁重新读，保证一致性。</p>
<h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><p>Semaphore：信号量。</p>
<p>前面学习各种锁的实现。</p>
<p>本质上锁的目的是保护一种受限资源，保证同一时刻只有一个线程能访问（ReentrantLock），或者只有一个线程能写入（ReadWriteLock）。</p>
<p>还有一种受限资源，目的是控制一种资源访问量，可能是不存在并发问题的只读操作。</p>
<p>例如，一个服务器同时只能允许 10 个人进入。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccessLimitControl</span> &#123;</span><br><span class="line">    <span class="comment">// 任意时刻仅允许最多3个线程获取许可:</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">access</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 如果超过了许可数量,其他线程将在此等待:</span></span><br><span class="line">        semaphore.acquire();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">            <span class="keyword">return</span> UUID.randomUUID().toString();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放资源</span></span><br><span class="line">            semaphore.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用<code>acquire()</code>可能会进入等待，直到满足条件为止。也可以使用<code>tryAcquire()</code>指定等待时间：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if (semaphore.tryAcquire(3, TimeUnit.SECONDS)) &#123;</span><br><span class="line">    // 指定等待时间3秒内获取到许可:</span><br><span class="line">    try &#123;</span><br><span class="line">        // TODO:</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        semaphore.release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要对某一受限资源进行限流访问，可以使用<code>Semaphore</code>，保证同一时间最多N个线程访问受限资源。</p>
<blockquote>
<p>线程容量和QBS区别</p>
</blockquote>
<h3 id="Concurrent集合"><a href="#Concurrent集合" class="headerlink" title="Concurrent集合"></a>Concurrent集合</h3><p>在前面通过 ReentrantLock 和 Condition 实现了一个阻塞的任务队列 BlockingQueue。</p>
<p><code>BlockingQueue</code>的意思就是说，当一个线程调用这个<code>getTask()</code>方法时，该方法内部可能会让线程变成等待状态，直到队列条件满足不为空，线程被唤醒后，<code>getTask()</code>方法才会返回。</p>
<p>除了<code>BlockingQueue</code>外，针对<code>List</code>、<code>Map</code>、<code>Set</code>、<code>Deque</code>等，<code>java.util.concurrent</code>包也提供了对应的并发集合类。我们归纳一下：</p>
<table>
<thead>
<tr>
<th align="left">interface</th>
<th align="left">non-thread-safe</th>
<th align="left">thread-safe</th>
</tr>
</thead>
<tbody><tr>
<td align="left">List</td>
<td align="left">ArrayList</td>
<td align="left">CopyOnWriteArrayList</td>
</tr>
<tr>
<td align="left">Map</td>
<td align="left">HashMap</td>
<td align="left">ConcurrentHashMap</td>
</tr>
<tr>
<td align="left">Set</td>
<td align="left">HashSet &#x2F; TreeSet</td>
<td align="left">CopyOnWriteArraySet</td>
</tr>
<tr>
<td align="left">Queue</td>
<td align="left">ArrayDeque &#x2F; LinkedList</td>
<td align="left">ArrayBlockingQueue &#x2F; LinkedBlockingQueue</td>
</tr>
<tr>
<td align="left">Deque 双向队列</td>
<td align="left">ArrayDeque &#x2F; LinkedList</td>
<td align="left">LinkedBlockingDeque</td>
</tr>
</tbody></table>
<p>使用这些并发集合与使用非线程安全的集合类完全相同。我们以<code>ConcurrentHashMap</code>为例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = new ConcurrentHashMap&lt;&gt;();</span><br><span class="line">// 在不同的线程读写:</span><br><span class="line">map.put(&quot;A&quot;, &quot;1&quot;);</span><br><span class="line">map.put(&quot;B&quot;, &quot;2&quot;);</span><br><span class="line">map.get(&quot;A&quot;, &quot;1&quot;);</span><br></pre></td></tr></table></figure>

<p>操作和原生集合使用一致，所有的同步和加锁的逻辑都在集合内部实现了</p>
<p><code>java.util.Collections</code>工具类还提供了一个<strong>旧的线程安全集合转换器</strong>，可以这么用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map unsafeMap = new HashMap();</span><br><span class="line">Map threadSafeMap = Collections.synchronizedMap(unsafeMap);</span><br></pre></td></tr></table></figure>

<p>但是它实际上是封装了了非线程安全的<code>Map</code>，对所有读写方法都用<code>synchronized</code>加锁。</p>
<p>这样获得的线程安全集合的性能比<code>java.util.concurrent</code>集合要低很多，所以不推荐使用。</p>
<h3 id="Atomic-类"><a href="#Atomic-类" class="headerlink" title="Atomic 类"></a>Atomic 类</h3><p>ava的<code>java.util.concurrent</code>包除了提供底层锁、并发集合外，还提供了一组原子操作的封装类，它们位于<code>java.util.concurrent.atomic</code>包。</p>
<p>我们以<code>AtomicInteger</code>为例，它提供的主要操作有：</p>
<ul>
<li>增加值并返回新值：<code>int addAndGet(int delta)</code></li>
<li>加1后返回新值：<code>int incrementAndGet()</code></li>
<li>获取当前值：<code>int get()</code></li>
<li>用CAS方式设置：<code>int compareAndSet(int expect, int update)</code></li>
</ul>
<p>Atomic类是通过无锁（lock-free）的方式实现的线程安全（thread-safe）访问。它的主要原理是利用了CAS：Compare and Set。</p>
<p>如果我们自己通过CAS编写<code>incrementAndGet()</code>，它大概长这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以把这里的 var 看成对象属性，参数（局部变量）在多线程中是不共享的。</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">incrementAndGet</span><span class="params">(AtomicInteger <span class="keyword">var</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> prev, next;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prev = <span class="keyword">var</span>.get();</span><br><span class="line">        next = prev + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> ( ! <span class="keyword">var</span>.compareAndSet(prev, next));</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CAS：将比较和写入封装成原子性操作。</p>
<p>用一个以 CAS 为条件的 do~while 循环包裹 inc 和 get 操作，只要在自增后原值不变则返回值，如果期间改变了就重复操作。</p>
<p>利用<code>AtomicLong</code>可以编写一个多线程安全的全局唯一ID生成器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class IdGenerator &#123;</span><br><span class="line">    AtomicLong var = new AtomicLong(0);</span><br><span class="line"></span><br><span class="line">    public long getNextId() &#123;</span><br><span class="line">        return var.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在高度竞争的情况下，还可以使用Java 8提供的<code>LongAdder</code>和<code>LongAccumulator</code>。</p>
<p>应用：</p>
<ul>
<li>原子操作实现了无锁的线程安全；</li>
<li>适用于计数器，累加器等。</li>
</ul>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>为什么需要线程池？</p>
<p>因为创建线程需要操作系统资源（线程资源，栈空间等），频繁创建和销毁大量线程需要消耗大量时间。</p>
<p>而大多数情况下因为每个线程执行的任务不一定会同时完成，而是有一些线程提前完成。</p>
<p>那如果需要继续完成类似的任务，要继续创建新的线程来执行吗？</p>
<p>不是的，为了避免频繁创建线程浪费资源，选择创建一个线程池，当线程执行结束后，会被收回线程池，以供下次调用，就不用创建新线程了。</p>
<p><strong>创建线程池</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个固定大小的线程池:</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            es.submit(<span class="keyword">new</span> <span class="title class_">Task</span>(<span class="string">&quot;&quot;</span> + i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭线程池:</span></span><br><span class="line">        es.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>提交任务后，会异步的执行完这一些任务。</p>
<p>线程池在程序结束的时候要关闭。有三种关闭的方式：</p>
<ol>
<li>使用<code>shutdown()</code>方法关闭线程池的时候，它会等待正在执行的任务先完成，然后再关闭。</li>
<li><code>shutdownNow()</code>会立刻停止正在执行的任务，</li>
<li><code>awaitTermination()</code>则会等待指定的时间让线程池关闭。</li>
</ol>
<p>因为<code>ExecutorService</code>只是接口，Java标准库提供的几个常用实现类有：</p>
<ul>
<li>FixedThreadPool：线程数固定的线程池；</li>
<li>CachedThreadPool：线程数根据任务动态调整的线程池；</li>
<li>SingleThreadExecutor：仅单线程执行的线程池。</li>
</ul>
<p>创建这些线程池的方法都被封装到<code>Executors</code>这个工厂类中，可以选择创建需要的线程池。</p>
<p><strong>ScheduledThreadPool</strong></p>
<p>还有一种任务，需要定期反复执行，例如，每秒刷新证券价格。</p>
<p>这种任务本身固定，需要反复执行的，可以使用<code>ScheduledThreadPool</code>。</p>
<p>创建一个<code>ScheduledThreadPool</code>仍然是通过<code>Executors</code>类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService ses = Executors.newScheduledThreadPool(4);</span><br></pre></td></tr></table></figure>

<p>我们可以提交一次性任务，它会在指定延迟后只执行一次：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 1秒后执行一次性任务:</span><br><span class="line">ses.schedule(new Task(&quot;one-time&quot;), 1, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<p>如果任务以固定的每3秒执行，我们可以这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 2秒后开始执行定时任务，每3秒执行:</span><br><span class="line">ses.scheduleAtFixedRate(new Task(&quot;fixed-rate&quot;), 2, 3, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<p>如果任务以固定的3秒为间隔执行，我们可以这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 2秒后开始执行定时任务，以3秒为间隔执行:</span><br><span class="line">ses.scheduleWithFixedDelay(new Task(&quot;fixed-delay&quot;), 2, 3, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<p>注意FixedRate和FixedDelay的区别。FixedRate是指任务总是<strong>以固定时间间隔触发</strong>，不管任务执行多长时间：</p>
<p><img src="/assets/image-20240415131920186.png" alt="image-20240415131920186"></p>
<p>而FixedDelay是指，上一次任务<strong>执行完毕</strong>后，等待固定的时间间隔，再执行下一次任务：</p>
<p><img src="/assets/image-20240415131957807.png" alt="image-20240415131957807"></p>
<p><strong>注意：</strong></p>
<ol>
<li><p>在FixedRate模式下，假设每秒触发，如果某次任务执行时间超过1秒，后续任务会不会并发执行？</p>
<p>也就是原定于每 1 秒执行一次的任务，但是上次任务还没有执行完，还会根据每秒一次执行吗？</p>
<p>答案：不会，如果任务执行时间超出了触发间隔，会在这一次任务执行完毕后，再执行下一次任务，如果下一次任务没有超出时间间隔，则保持间隔时间触发，如果又超出了，继续等待至完毕后再执行下一次，变成了顺序执行固定任务。</p>
</li>
<li><p>如果任务抛出了异常，后续任务是否继续执行？</p>
<p>答案：如果一个定时任务中任何一次执行出现了问题，这么这个 schedule 就会停止。</p>
</li>
</ol>
<p><strong>Timer</strong></p>
<p>Java标准库还提供了一个<code>java.util.Timer</code>类，这个类也可以定期执行任务，但是，一个<code>Timer</code>会对应一个<code>Thread</code>，所以，一个<code>Timer</code>只能定期执行一个任务，多个定时任务必须启动多个<code>Timer</code>，而一个<code>ScheduledThreadPool</code>就可以调度多个定时任务，所以，我们完全可以用<code>ScheduledThreadPool</code>取代旧的<code>Timer</code>。</p>
<h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><p><code>Runnable</code>接口有个问题，它的方法没有返回值。</p>
<p>如果任务需要一个返回结果，那么只能保存到变量，还要额外封装方法读取，要考虑诸多因素非常不便。</p>
<p>所以，Java标准库还提供了一个<code>Callable</code>接口，和<code>Runnable</code>接口比，它多了一个返回值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> longTimeCalculation(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并且<code>Callable</code>接口是一个泛型接口，可以返回指定类型的结果。</p>
<p>在线程池中的 submit 中，如果提供一个 Callable 接口，就会返回一个<code>Future</code>类型，一个<code>Future</code>类型的实例代表一个未来能获取结果的对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">4</span>); </span><br><span class="line"><span class="comment">// 定义任务:</span></span><br><span class="line">Callable&lt;String&gt; task = <span class="keyword">new</span> <span class="title class_">Task</span>();</span><br><span class="line"><span class="comment">// 提交任务并获得Future:</span></span><br><span class="line">Future&lt;String&gt; future = executor.submit(task);</span><br><span class="line"><span class="comment">// 从Future获取异步执行返回的结果:</span></span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> future.get(); <span class="comment">// 可能阻塞</span></span><br></pre></td></tr></table></figure>

<p>在调用<code>get()</code>时，如果异步任务已经完成，我们就直接获得结果。</p>
<p>如果异步任务还没有完成，那么<code>get()</code>会阻塞，直到任务完成后才返回结果。</p>
<p>一个<code>Future&lt;V&gt;</code>接口表示一个未来可能会返回的结果，它定义的方法有：</p>
<ul>
<li><code>get()</code>：获取结果（可能会等待）</li>
<li><code>get(long timeout, TimeUnit unit)</code>：获取结果，但只等待指定的时间；</li>
<li><code>cancel(boolean mayInterruptIfRunning)</code>：取消当前任务；</li>
<li><code>isDone()</code>：判断任务是否已完成。</li>
</ul>
<h3 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h3><p>使用<code>Future</code>获得异步执行结果时，由于 get 结果并进行处理会进行阻塞或者封装一些其他的方法，非常麻烦。</p>
<p>从Java 8开始引入了<code>CompletableFuture</code>，它针对<code>Future</code>做了改进，可以传入回调对象，当异步任务完成或者发生异常时，自动调用回调对象的回调方法。</p>
<p><strong>使用方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建异步执行任务:</span></span><br><span class="line">        CompletableFuture&lt;Double&gt; cf = CompletableFuture.supplyAsync(Main::fetchPrice);</span><br><span class="line">        <span class="comment">// 如果执行成功:</span></span><br><span class="line">        cf.thenAccept((result) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;price: &quot;</span> + result);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 如果执行异常:</span></span><br><span class="line">        cf.exceptionally((e) -&gt; &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭:</span></span><br><span class="line">        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行成功：thenAccept；执行异常：exceptionally。</p>
<p>supplyAsync接收的是一个Supplier接口函数，thenAccept, exceptionally接收一个Consumer接口函数</p>
<p>相比于 Future 优点：</p>
<ul>
<li>异步任务<strong>结束时</strong>，会自动回调某个对象的方法；</li>
<li>异步任务<strong>出错时</strong>，会自动回调某个对象的方法；</li>
<li>主线程设置好回调后，不再关心异步任务的执行。</li>
</ul>
<p><strong>CompletableFuture 还可以制作串行、并行及两者结合的异步操作</strong></p>
<p><strong>串行</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 第一个任务:</span></span><br><span class="line">        CompletableFuture&lt;String&gt; cfQuery = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> queryCode(<span class="string">&quot;中国石油&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// cfQuery成功后继续执行下一个任务:</span></span><br><span class="line">        CompletableFuture&lt;Double&gt; cfFetch = cfQuery.thenApplyAsync((code) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> fetchPrice(code);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// cfFetch成功后打印结果:</span></span><br><span class="line">        cfFetch.thenAccept((result) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;price: &quot;</span> + result);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭:</span></span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 thenApplyAsync 接着上一步异步继续执行，并且返回一个新的 CompletableFuture 对象。</p>
<p><strong>并行串行结合</strong></p>
<p>考虑如下这样的一个场景：</p>
<p>同时从新浪和网易查询证券代码，只要任意一个返回结果，就进行下一步查询价格，查询价格也同时从新浪和网易查询，只要任意一个返回结果，就完成操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 两个CompletableFuture执行异步查询:</span></span><br><span class="line">        CompletableFuture&lt;String&gt; cfQueryFromSina = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> queryCode(<span class="string">&quot;中国石油&quot;</span>, <span class="string">&quot;https://finance.sina.com.cn/code/&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        CompletableFuture&lt;String&gt; cfQueryFrom163 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> queryCode(<span class="string">&quot;中国石油&quot;</span>, <span class="string">&quot;https://money.163.com/code/&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用anyOf合并为一个新的CompletableFuture:</span></span><br><span class="line">        CompletableFuture&lt;Object&gt; cfQuery = CompletableFuture.anyOf(cfQueryFromSina, cfQueryFrom163);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 两个CompletableFuture执行异步查询:</span></span><br><span class="line">        CompletableFuture&lt;Double&gt; cfFetchFromSina = cfQuery.thenApplyAsync((code) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> fetchPrice((String) code, <span class="string">&quot;https://finance.sina.com.cn/price/&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        CompletableFuture&lt;Double&gt; cfFetchFrom163 = cfQuery.thenApplyAsync((code) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> fetchPrice((String) code, <span class="string">&quot;https://money.163.com/price/&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用anyOf合并为一个新的CompletableFuture:</span></span><br><span class="line">        CompletableFuture&lt;Object&gt; cfFetch = CompletableFuture.anyOf(cfFetchFromSina, cfFetchFrom163);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最终结果:</span></span><br><span class="line">        cfFetch.thenAccept((result) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;price: &quot;</span> + result);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭:</span></span><br><span class="line">        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述的执行流程，可以用下图解释：</p>
<p><img src="/assets/image-20240415134338932.png" alt="image-20240415134338932"></p>
<p>除了<code>anyOf()</code>可以实现“任意个<code>CompletableFuture</code>只要一个成功”，<code>allOf()</code>可以实现“所有<code>CompletableFuture</code>都必须成功”，这些组合操作可以实现非常复杂的异步流程控制。</p>
<p>最后我们注意<code>CompletableFuture</code>的命名规则：</p>
<ul>
<li><code>xxx()</code>：表示该方法将继续在已有的线程中执行；</li>
<li><code>xxxAsync()</code>：表示将异步在线程池中执行。</li>
</ul>
<p><strong>注意</strong>：不管是 thenApplyAsync 还是 anyOf, allOf 等操作对 CompletableFuture 进行整合，都会返回一个新的 CompletableFuture 对象，最终结果应基于最后一个组合对象操作。</p>
<blockquote>
<p>还有个 runAsync 方法，可以不需要返回值也能使用。</p>
</blockquote>
<h3 id="ForkJoin"><a href="#ForkJoin" class="headerlink" title="ForkJoin"></a>ForkJoin</h3><p>Java 7开始引入了一种新的Fork&#x2F;Join线程池，它可以执行一种特殊的任务：把一个大任务拆成多个小任务并行执行。</p>
<p>以大数据进行并行求和为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建2000个随机数组成的数组:</span></span><br><span class="line">        <span class="type">long</span>[] array = <span class="keyword">new</span> <span class="title class_">long</span>[<span class="number">2000</span>];</span><br><span class="line">        <span class="type">long</span> <span class="variable">expectedSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            array[i] = random();</span><br><span class="line">            expectedSum += array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Expected sum: &quot;</span> + expectedSum);</span><br><span class="line">        <span class="comment">// fork/join:</span></span><br><span class="line">        ForkJoinTask&lt;Long&gt; task = <span class="keyword">new</span> <span class="title class_">SumTask</span>(array, <span class="number">0</span>, array.length);</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> ForkJoinPool.commonPool().invoke(task);</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;Fork/join sum: &quot;</span> + result + <span class="string">&quot; in &quot;</span> + (endTime - startTime) + <span class="string">&quot; ms.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">random</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> random.nextInt(<span class="number">10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SumTask</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Long&gt; &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THRESHOLD</span> <span class="operator">=</span> <span class="number">500</span>;</span><br><span class="line">    <span class="type">long</span>[] array;</span><br><span class="line">    <span class="type">int</span> start;</span><br><span class="line">    <span class="type">int</span> end;</span><br><span class="line"></span><br><span class="line">    SumTask(<span class="type">long</span>[] array, <span class="type">int</span> start, <span class="type">int</span> end) &#123;</span><br><span class="line">        <span class="built_in">this</span>.array = array;</span><br><span class="line">        <span class="built_in">this</span>.start = start;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Long <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (end - start &lt;= THRESHOLD) &#123;</span><br><span class="line">            <span class="comment">// 如果任务足够小,直接计算:</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; end; i++) &#123;</span><br><span class="line">                sum += <span class="built_in">this</span>.array[i];</span><br><span class="line">                <span class="comment">// 故意放慢计算速度:</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 任务太大,一分为二:</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> (end + start) / <span class="number">2</span>;</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;split %d~%d ==&gt; %d~%d, %d~%d&quot;</span>, start, end, start, middle, middle, end));</span><br><span class="line">        <span class="type">SumTask</span> <span class="variable">subtask1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SumTask</span>(<span class="built_in">this</span>.array, start, middle);</span><br><span class="line">        <span class="type">SumTask</span> <span class="variable">subtask2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SumTask</span>(<span class="built_in">this</span>.array, middle, end);</span><br><span class="line">        invokeAll(subtask1, subtask2);</span><br><span class="line">        <span class="type">Long</span> <span class="variable">subresult1</span> <span class="operator">=</span> subtask1.join();</span><br><span class="line">        <span class="type">Long</span> <span class="variable">subresult2</span> <span class="operator">=</span> subtask2.join();</span><br><span class="line">        <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> subresult1 + subresult2;</span><br><span class="line">        System.out.println(<span class="string">&quot;result = &quot;</span> + subresult1 + <span class="string">&quot; + &quot;</span> + subresult2 + <span class="string">&quot; ==&gt; &quot;</span> + result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>观察上述代码的执行过程，一个大的计算任务0<del>2000首先分裂为两个小任务0</del>1000和1000<del>2000，这两个小任务仍然太大，继续分裂为更小的0</del>500，500<del>1000，1000</del>1500，1500~2000，最后，计算结果被依次合并，得到最终结果。</p>
<blockquote>
<p>该例子并不适用，因为本质是同源的，多线程最大的优势是在应用不同源。</p>
</blockquote>
<blockquote>
<p>同源：每次切换一个线程加一点数，和一次加完所有的数是一样的（也不一定，多核CPU下，当然是一个任务能占据更多核速度最快）。</p>
<p>不同源：每次切换一个线程和不同“服务”通信，所有服务并行执行。</p>
</blockquote>
<p>Fork&#x2F;Join线程池在Java标准库中就有应用。</p>
<p>Java标准库提供的<code>java.util.Arrays.parallelSort(array)</code>可以进行并行排序，它的原理就是内部通过Fork&#x2F;Join对大数组分拆进行并行排序，在多核CPU上就可以大大提高排序的速度。</p>
<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>多线程是Java实现多任务的基础。</p>
<p><strong>获取多线程id</strong></p>
<p><code>Thread</code>对象代表一个线程，我们可以在代码中调用<code>Thread.currentThread()</code>获取当前线程。</p>
<p><strong>传递状态</strong></p>
<p>通常一个任务需要多个方法完成，对象如何在多个方法中传递相同的状态？</p>
<p>定义一个对象属性？多线程共享会不一致该怎么办？</p>
<p>Java标准库提供了一个特殊的<code>ThreadLocal</code>，它可以确保每一个线程中都维护各自的一个对象属性值。</p>
<p><code>ThreadLocal</code>实例通常总是以<strong>静态字段初始化</strong>如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> ThreadLocal&lt;User&gt; threadLocalUser = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p><strong>使用方式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载器</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">processUser</span><span class="params">(user)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        threadLocalUser.set(user);</span><br><span class="line">        step1();</span><br><span class="line">        step2();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        threadLocalUser.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以把<code>ThreadLocal</code>看成一个全局<code>Map&lt;Thread, Object&gt;</code>：每个线程获取<code>ThreadLocal</code>变量时，总是使用<code>Thread</code>自身作为key：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">threadLocalValue</span> <span class="operator">=</span> threadLocalMap.get(Thread.currentThread());</span><br></pre></td></tr></table></figure>

<p>因此，<code>ThreadLocal</code>相当于给每个线程都开辟了一个独立的存储空间，各个线程的<code>ThreadLocal</code>关联的实例互不干扰。</p>
<p>最后，特别注意<code>ThreadLocal</code>一定要在<code>finally</code>中清除：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    threadLocalUser.set(user);</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    threadLocalUser.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是因为当前线程执行完相关代码后，很可能会被重新放入线程池中，如果<code>ThreadLocal</code>没有被清除，该线程执行其他代码时，会把上一次的状态带进去。</p>
<p>而且 ThreadLocal 可以维护的线程数是有限的，如果超出了限制，会造成内存污染，共用一个对象的情况。</p>
<p><strong>实现 AutoCloseable 接口</strong></p>
<p>为了保证能释放<code>ThreadLocal</code>关联的实例，我们可以通过<code>AutoCloseable</code>接口配合<code>try (resource) &#123;...&#125;</code>结构，让编译器自动为我们关闭。</p>
<p>例如，将用于保存当前用户名的<code>ThreadLocal</code>封装为一个<code>UserContext</code>对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserContext</span> <span class="keyword">implements</span> <span class="title class_">AutoCloseable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; ctx = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserContext</span><span class="params">(String user)</span> &#123;</span><br><span class="line">        ctx.set(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">currentUser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ctx.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        ctx.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用的时候，我们借助<code>try (resource) &#123;...&#125;</code>结构，可以这么写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">try (var ctx = new UserContext(&quot;Bob&quot;)) &#123;</span><br><span class="line">    // 可任意调用UserContext.currentUser():</span><br><span class="line">    String currentUser = UserContext.currentUser();</span><br><span class="line">&#125; // 在此自动调用UserContext.close()方法释放ThreadLocal关联对象</span><br></pre></td></tr></table></figure>

<p>将 UserContext 实例对象的作用限定在 try {} 中，当离开作用域时自动回收该实例，并调用 close 方法移除 ThreadLocal 关联对象（有点像析构方法接口）。</p>
<h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><h2 id="易混概念"><a href="#易混概念" class="headerlink" title="易混概念"></a>易混概念</h2><ol>
<li>主类: 所有定义了main方法的类叫做主类，开发者常在类中定义main方法，用来调试代码</li>
<li>在基本数据类型变量声明时，不能用占用内存大的值赋给占用内存小的变量类型，如 float a &#x3D; 1.19; 1.19 默认是double型，因此该语句会编译出错; &#x3D;&#x3D;2e9&#x3D;&#x3D;科学计数，默认也是double型!!!</li>
<li>使用…声明可变长参数，如int sort(int… a);</li>
<li>命令行参数</li>
</ol>
<blockquote>
<p>各个类的main方法可以相互调用</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(String str: args) &#123;</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] strs = &#123;<span class="string">&quot;hello&quot;</span>，<span class="string">&quot;world&quot;</span>&#125;;</span><br><span class="line">        B.main(strs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>重载是&#x3D;&#x3D;多态&#x3D;&#x3D;的一种。</li>
<li>不管是继承还是实现接口，重写方法时都不可以降低方法的可见性（Visiability）</li>
</ol>
<blockquote>
<p>如：继承的public方法不能重写为protected方法，但是protected方法重写后可改为public。</p>
</blockquote>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"><i class="fa fa-tag"></i> Java</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/03/29/240329/" rel="prev" title="Redisson分布式锁、联锁">
      <i class="fa fa-chevron-left"></i> Redisson分布式锁、联锁
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/04/07/240407/" rel="next" title="Redis的Stream消息队列应用">
      Redis的Stream消息队列应用 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.</span> <span class="nav-text">介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E7%82%B9"><span class="nav-number">1.1.</span> <span class="nav-text">特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JRE-%E5%92%8C-JDK-%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.2.</span> <span class="nav-text">JRE 和 JDK 介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8D%E8%AF%8D%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.3.</span> <span class="nav-text">名词介绍</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95%E8%A7%84%E5%88%99"><span class="nav-number">2.</span> <span class="nav-text">语法规则</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99"><span class="nav-number">2.1.</span> <span class="nav-text">命名规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Hello-world%E5%88%86%E6%9E%90"><span class="nav-number">2.2.</span> <span class="nav-text">Hello world分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E7%B1%BB"><span class="nav-number">2.3.</span> <span class="nav-text">主类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E7%BC%96%E8%AF%91"><span class="nav-number">2.4.</span> <span class="nav-text">反编译</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E9%87%8A"><span class="nav-number">2.5.</span> <span class="nav-text">注释</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.</span> <span class="nav-text">数据类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E7%AE%97"><span class="nav-number">4.</span> <span class="nav-text">运算</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">4.1.</span> <span class="nav-text">运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B4%E6%95%B0%E8%BF%90%E7%AE%97"><span class="nav-number">4.2.</span> <span class="nav-text">整数运算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E8%BF%90%E7%AE%97"><span class="nav-number">4.3.</span> <span class="nav-text">浮点数运算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%83%E5%B0%94%E8%BF%90%E7%AE%97"><span class="nav-number">4.4.</span> <span class="nav-text">布尔运算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%B2%BE%E5%BA%A6"><span class="nav-number">4.5.</span> <span class="nav-text">运算精度</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6"><span class="nav-number">5.</span> <span class="nav-text">字符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">6.</span> <span class="nav-text">字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6"><span class="nav-number">6.1.</span> <span class="nav-text">转义字符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%89%B9%E6%80%A7"><span class="nav-number">6.2.</span> <span class="nav-text">不可变特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%9F%E8%83%BD"><span class="nav-number">6.3.</span> <span class="nav-text">功能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E5%BC%95%E7%94%A8%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">6.4.</span> <span class="nav-text">&#x3D;&#x3D; 在引用的使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84"><span class="nav-number">7.</span> <span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">7.1.</span> <span class="nav-text">初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E7%82%B9-1"><span class="nav-number">7.2.</span> <span class="nav-text">特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="nav-number">7.3.</span> <span class="nav-text">多维数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="nav-number">7.4.</span> <span class="nav-text">排序数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%94%A8"><span class="nav-number">7.5.</span> <span class="nav-text">应用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0"><span class="nav-number">8.</span> <span class="nav-text">命令行参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="nav-number">9.</span> <span class="nav-text">流程控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%93%E5%85%A5"><span class="nav-number">9.1.</span> <span class="nav-text">输入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%93%E5%87%BA"><span class="nav-number">9.2.</span> <span class="nav-text">输出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#if%E5%88%A4%E6%96%AD"><span class="nav-number">9.3.</span> <span class="nav-text">if判断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#switch%E6%96%B0%E7%94%A8%E6%B3%95"><span class="nav-number">9.4.</span> <span class="nav-text">switch新用法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF"><span class="nav-number">9.5.</span> <span class="nav-text">循环</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#while"><span class="nav-number">9.5.1.</span> <span class="nav-text">while</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#do-while"><span class="nav-number">9.5.2.</span> <span class="nav-text">do while</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#for"><span class="nav-number">9.5.3.</span> <span class="nav-text">for</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#for-each"><span class="nav-number">9.5.4.</span> <span class="nav-text">for each</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#break-%E5%92%8C-continue"><span class="nav-number">9.5.5.</span> <span class="nav-text">break 和 continue</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="nav-number">10.</span> <span class="nav-text">面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#0-%E7%89%B9%E7%82%B9"><span class="nav-number">10.0.0.1.</span> <span class="nav-text">0. 特点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%AD%97%E6%AE%B5"><span class="nav-number">10.0.0.2.</span> <span class="nav-text">1. 字段</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="nav-number">10.0.0.2.1.</span> <span class="nav-text">静态方法</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">10.0.0.3.</span> <span class="nav-text">2. 构造函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-this%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">10.0.0.4.</span> <span class="nav-text">3. this关键字</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E5%8C%85"><span class="nav-number">10.0.0.5.</span> <span class="nav-text">4. 包</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-number">10.0.0.6.</span> <span class="nav-text">5. 修饰符</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="nav-number">10.0.0.7.</span> <span class="nav-text">6. 包装类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-%E4%B8%8A%E8%BD%AC%E5%9E%8B%E5%AF%B9%E8%B1%A1"><span class="nav-number">10.0.0.8.</span> <span class="nav-text">7. 上转型对象</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8-%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="nav-number">10.0.0.9.</span> <span class="nav-text">8. 抽象类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#9-%E6%8E%A5%E5%8F%A3"><span class="nav-number">10.0.0.10.</span> <span class="nav-text">9. 接口</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#10-Lambada%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88JDK8%E5%90%8E%EF%BC%89"><span class="nav-number">10.0.0.11.</span> <span class="nav-text">10. Lambada表达式（JDK8后）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#11-%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">10.0.0.12.</span> <span class="nav-text">11. 内部类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#12-%E5%8C%BF%E5%90%8D%E7%B1%BB"><span class="nav-number">10.0.0.13.</span> <span class="nav-text">12. 匿名类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#13-%E5%BC%82%E5%B8%B8%E7%B1%BB"><span class="nav-number">10.0.0.14.</span> <span class="nav-text">13. 异常类</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E7%B1%BB"><span class="nav-number">11.</span> <span class="nav-text">核心类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-String%E7%B1%BB"><span class="nav-number">11.0.0.1.</span> <span class="nav-text">1. String类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">11.0.0.2.</span> <span class="nav-text">2. 正则表达式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-Class%E7%B1%BB%E4%B8%8E%E5%8F%8D%E5%B0%84"><span class="nav-number">11.0.0.3.</span> <span class="nav-text">3. Class类与反射</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-number">12.</span> <span class="nav-text">异常处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D-1"><span class="nav-number">12.1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8"><span class="nav-number">12.2.</span> <span class="nav-text">捕获异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8"><span class="nav-number">12.3.</span> <span class="nav-text">抛出异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E2%80%9C%E8%BD%AC%E6%8D%A2%E2%80%9D"><span class="nav-number">12.4.</span> <span class="nav-text">异常“转换”</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%B1%8F%E8%94%BD"><span class="nav-number">12.5.</span> <span class="nav-text">异常屏蔽</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8"><span class="nav-number">12.6.</span> <span class="nav-text">自定义异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NPE%E5%BC%82%E5%B8%B8"><span class="nav-number">12.7.</span> <span class="nav-text">NPE异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%AD%E8%A8%80"><span class="nav-number">12.8.</span> <span class="nav-text">断言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BA"><span class="nav-number">12.9.</span> <span class="nav-text">日志输出</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84"><span class="nav-number">13.</span> <span class="nav-text">反射</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D-2"><span class="nav-number">13.1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="nav-number">13.2.</span> <span class="nav-text">基本使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84Class%E5%AE%9E%E4%BE%8B"><span class="nav-number">13.2.1.</span> <span class="nav-text">如何获取一个类的Class实例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E6%AF%94-instanceof"><span class="nav-number">13.2.2.</span> <span class="nav-text">对比 instanceof</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E7%B1%BB%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF"><span class="nav-number">13.2.3.</span> <span class="nav-text">获取类的基本信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%96%B0%E5%AE%9E%E4%BE%8B"><span class="nav-number">13.2.4.</span> <span class="nav-text">创建新实例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Field"><span class="nav-number">13.3.</span> <span class="nav-text">Field</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E6%96%B9%E6%B3%95%E4%BB%8B%E7%BB%8D%EF%BC%9A"><span class="nav-number">13.3.1.</span> <span class="nav-text">获取方法介绍：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Field%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E4%BB%8B%E7%BB%8D"><span class="nav-number">13.3.2.</span> <span class="nav-text">Field对象属性介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%AD%97%E6%AE%B5%E5%80%BC"><span class="nav-number">13.3.3.</span> <span class="nav-text">获取字段值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E5%AD%97%E6%AE%B5%E5%80%BC"><span class="nav-number">13.3.4.</span> <span class="nav-text">设置字段值</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Method"><span class="nav-number">13.4.</span> <span class="nav-text">Method</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E6%96%B9%E6%B3%95%EF%BC%88%E7%B1%BB%E4%BC%BCField%EF%BC%89"><span class="nav-number">13.4.1.</span> <span class="nav-text">获取方法（类似Field）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Method-%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7%E4%BB%8B%E7%BB%8D"><span class="nav-number">13.4.2.</span> <span class="nav-text">Method 实例属性介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B0%83%E7%94%A8%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="nav-number">13.4.3.</span> <span class="nav-text">调用实例方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B0%83%E7%94%A8%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="nav-number">13.4.4.</span> <span class="nav-text">调用静态方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B0%83%E7%94%A8%E9%9D%9E-public-%E6%96%B9%E6%B3%95"><span class="nav-number">13.4.5.</span> <span class="nav-text">调用非 public 方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E6%80%81"><span class="nav-number">13.4.6.</span> <span class="nav-text">多态</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Constructor"><span class="nav-number">13.5.</span> <span class="nav-text">Constructor</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E6%96%B9%E6%B3%95"><span class="nav-number">13.5.1.</span> <span class="nav-text">获取方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8"><span class="nav-number">13.5.2.</span> <span class="nav-text">使用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB"><span class="nav-number">13.6.</span> <span class="nav-text">获取继承关系</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E7%88%B6%E7%B1%BB%E7%9A%84Class"><span class="nav-number">13.6.1.</span> <span class="nav-text">获取父类的Class</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96interface"><span class="nav-number">13.6.2.</span> <span class="nav-text">获取interface</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E5%88%A4%E6%96%AD"><span class="nav-number">13.6.3.</span> <span class="nav-text">继承关系判断</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="nav-number">13.7.</span> <span class="nav-text">动态代理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%A8%E8%A7%A3"><span class="nav-number">14.</span> <span class="nav-text">注解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D-3"><span class="nav-number">14.1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3"><span class="nav-number">14.2.</span> <span class="nav-text">定义注解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0"><span class="nav-number">14.2.1.</span> <span class="nav-text">配置参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E6%A0%BC%E5%BC%8F"><span class="nav-number">14.2.2.</span> <span class="nav-text">定义格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%83%E6%B3%A8%E8%A7%A3"><span class="nav-number">14.2.3.</span> <span class="nav-text">元注解</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Target"><span class="nav-number">14.2.3.1.</span> <span class="nav-text">@Target</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Retention"><span class="nav-number">14.2.3.2.</span> <span class="nav-text">@Retention</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Repeatable"><span class="nav-number">14.2.3.3.</span> <span class="nav-text">@Repeatable</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Inherited"><span class="nav-number">14.2.3.4.</span> <span class="nav-text">@Inherited</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89-Annotation-%E6%AD%A5%E9%AA%A4"><span class="nav-number">14.2.4.</span> <span class="nav-text">自定义 Annotation 步骤</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%8F%96%E5%A4%84%E7%90%86%E6%B3%A8%E8%A7%A3"><span class="nav-number">14.3.</span> <span class="nav-text">读取处理注解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%BB%E5%8F%96%E6%B3%A8%E8%A7%A3%EF%BC%9A"><span class="nav-number">14.3.1.</span> <span class="nav-text">读取注解：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E6%B3%A8%E8%A7%A3"><span class="nav-number">14.3.2.</span> <span class="nav-text">处理注解</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B"><span class="nav-number">15.</span> <span class="nav-text">泛型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B"><span class="nav-number">15.1.</span> <span class="nav-text">定义泛型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B"><span class="nav-number">15.1.1.</span> <span class="nav-text">向上转型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="nav-number">15.1.2.</span> <span class="nav-text">泛型方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E4%B8%AA%E6%B3%9B%E5%9E%8B"><span class="nav-number">15.1.3.</span> <span class="nav-text">多个泛型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B"><span class="nav-number">15.2.</span> <span class="nav-text">使用泛型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%A6%E6%8B%AD%E6%B3%95"><span class="nav-number">15.3.</span> <span class="nav-text">擦拭法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%A6%E6%9D%A5%E7%9A%84%E5%B1%80%E9%99%90"><span class="nav-number">15.3.1.</span> <span class="nav-text">带来的局限</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E8%83%BD%E8%A6%86%E5%86%99Object%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">15.3.2.</span> <span class="nav-text">不能覆写Object类的方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E7%BB%A7%E6%89%BF"><span class="nav-number">15.3.3.</span> <span class="nav-text">泛型继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E7%88%B6%E7%B1%BB%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B"><span class="nav-number">15.3.4.</span> <span class="nav-text">获取父类泛型类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E6%A0%87%E8%AF%86%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB"><span class="nav-number">15.3.5.</span> <span class="nav-text">类型标识继承关系</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#extends%E3%80%81super"><span class="nav-number">15.4.</span> <span class="nav-text">extends、super</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#extends"><span class="nav-number">15.4.1.</span> <span class="nav-text">extends</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#super"><span class="nav-number">15.4.2.</span> <span class="nav-text">super</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E6%AF%94extends%E5%92%8Csuper%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="nav-number">15.4.3.</span> <span class="nav-text">对比extends和super通配符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%A0%E9%99%90%E5%AE%9A%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="nav-number">15.4.4.</span> <span class="nav-text">无限定通配符</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E5%92%8C%E5%8F%8D%E5%B0%84"><span class="nav-number">15.5.</span> <span class="nav-text">泛型和反射</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B-Class"><span class="nav-number">15.5.1.</span> <span class="nav-text">泛型 Class</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B-Constructor"><span class="nav-number">15.5.2.</span> <span class="nav-text">泛型 Constructor</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E6%95%B0%E7%BB%84"><span class="nav-number">15.5.3.</span> <span class="nav-text">泛型数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B0%A8%E6%85%8E%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="nav-number">15.5.4.</span> <span class="nav-text">谨慎使用泛型可变参数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9B%86%E5%90%88"><span class="nav-number">16.</span> <span class="nav-text">集合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#List"><span class="nav-number">16.1.</span> <span class="nav-text">List</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-1"><span class="nav-number">16.1.1.</span> <span class="nav-text">使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#List-of"><span class="nav-number">16.1.2.</span> <span class="nav-text">List.of</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#List%E8%BD%ACArray"><span class="nav-number">16.1.3.</span> <span class="nav-text">List转Array</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Array%E8%BD%ACList"><span class="nav-number">16.1.4.</span> <span class="nav-text">Array转List</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Map"><span class="nav-number">16.2.</span> <span class="nav-text">Map</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-2"><span class="nav-number">16.2.1.</span> <span class="nav-text">使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashMap%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="nav-number">16.2.2.</span> <span class="nav-text">HashMap的本质</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#hashcode%E9%87%8D%E5%A4%8D"><span class="nav-number">16.2.3.</span> <span class="nav-text">hashcode重复</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E6%AF%94-Hashtable"><span class="nav-number">16.2.4.</span> <span class="nav-text">对比 Hashtable</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Set"><span class="nav-number">16.3.</span> <span class="nav-text">Set</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-3"><span class="nav-number">16.3.1.</span> <span class="nav-text">使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashSet%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="nav-number">16.3.2.</span> <span class="nav-text">HashSet的本质</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SortedSet"><span class="nav-number">16.3.3.</span> <span class="nav-text">SortedSet</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IO"><span class="nav-number">17.</span> <span class="nav-text">IO</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-File%E7%B1%BB"><span class="nav-number">17.0.0.1.</span> <span class="nav-text">1. File类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81"><span class="nav-number">17.0.0.2.</span> <span class="nav-text">2. 输入输出流</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E7%BC%93%E5%86%B2%E6%B5%81"><span class="nav-number">17.0.0.3.</span> <span class="nav-text">3. 缓冲流</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE%E6%96%87%E4%BB%B6%E6%B5%81"><span class="nav-number">17.0.0.4.</span> <span class="nav-text">4. 随机访问文件流</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A5%E6%9C%9F%E4%B8%8E%E6%97%B6%E9%97%B4"><span class="nav-number">18.</span> <span class="nav-text">日期与时间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">19.</span> <span class="nav-text">正则表达式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A0%E5%AF%86%E4%B8%8E%E5%AE%89%E5%85%A8"><span class="nav-number">20.</span> <span class="nav-text">加密与安全</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">21.</span> <span class="nav-text">多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="nav-number">21.1.</span> <span class="nav-text">进程与线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">21.2.</span> <span class="nav-text">JVM 多线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="nav-number">21.3.</span> <span class="nav-text">创建线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="nav-number">21.4.</span> <span class="nav-text">线程的状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AD%89%E5%BE%85%E7%BA%BF%E7%A8%8B"><span class="nav-number">21.5.</span> <span class="nav-text">等待线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B"><span class="nav-number">21.6.</span> <span class="nav-text">中断线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="nav-number">21.7.</span> <span class="nav-text">守护线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="nav-number">21.8.</span> <span class="nav-text">线程同步</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#synchronized"><span class="nav-number">21.8.1.</span> <span class="nav-text">synchronized</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%9D%E6%8C%81%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%90%8C%E6%AD%A5%E7%9A%84%E6%AD%A5%E9%AA%A4%EF%BC%9A"><span class="nav-number">21.8.2.</span> <span class="nav-text">保持线程之间同步的步骤：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="nav-number">21.8.3.</span> <span class="nav-text">原子操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1%E6%97%A0%E9%9C%80%E5%90%8C%E6%AD%A5"><span class="nav-number">21.8.4.</span> <span class="nav-text">不可变对象无需同步</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%BB%E7%BB%93%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">21.8.5.</span> <span class="nav-text">总结多线程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized-%E6%96%B9%E6%B3%95"><span class="nav-number">21.9.</span> <span class="nav-text">synchronized 方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81"><span class="nav-number">21.10.</span> <span class="nav-text">死锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#wait%E5%92%8Cnotify"><span class="nav-number">21.11.</span> <span class="nav-text">wait和notify</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ReentrantLock"><span class="nav-number">21.12.</span> <span class="nav-text">ReentrantLock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Condition"><span class="nav-number">21.13.</span> <span class="nav-text">Condition</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ReadWriteLock"><span class="nav-number">21.14.</span> <span class="nav-text">ReadWriteLock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#StampedLock"><span class="nav-number">21.15.</span> <span class="nav-text">StampedLock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Semaphore"><span class="nav-number">21.16.</span> <span class="nav-text">Semaphore</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Concurrent%E9%9B%86%E5%90%88"><span class="nav-number">21.17.</span> <span class="nav-text">Concurrent集合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Atomic-%E7%B1%BB"><span class="nav-number">21.18.</span> <span class="nav-text">Atomic 类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">21.19.</span> <span class="nav-text">线程池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Future"><span class="nav-number">21.20.</span> <span class="nav-text">Future</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CompletableFuture"><span class="nav-number">21.21.</span> <span class="nav-text">CompletableFuture</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ForkJoin"><span class="nav-number">21.22.</span> <span class="nav-text">ForkJoin</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadLocal"><span class="nav-number">21.23.</span> <span class="nav-text">ThreadLocal</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="nav-number">22.</span> <span class="nav-text">网络编程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%98%93%E6%B7%B7%E6%A6%82%E5%BF%B5"><span class="nav-number">23.</span> <span class="nav-text">易混概念</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Apong</p>
  <div class="site-description" itemprop="description">个人博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">18</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">35</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/BlueApong" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;BlueApong" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Apong</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>

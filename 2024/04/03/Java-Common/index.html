<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java基础 | Apong's Blog</title><meta name="author" content="Apong"><meta name="copyright" content="Apong"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Java 基础知识">
<meta property="og:type" content="article">
<meta property="og:title" content="Java基础">
<meta property="og:url" content="https://blueapong.github.io/2024/04/03/Java-Common/index.html">
<meta property="og:site_name" content="Apong&#39;s Blog">
<meta property="og:description" content="Java 基础知识">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blueapong.github.io/config/avatar.jpg">
<meta property="article:published_time" content="2024-04-03T13:10:14.000Z">
<meta property="article:modified_time" content="2024-04-11T00:54:26.748Z">
<meta property="article:author" content="Apong">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blueapong.github.io/config/avatar.jpg"><link rel="shortcut icon" href="/config/favicon.png"><link rel="canonical" href="https://blueapong.github.io/2024/04/03/Java-Common/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java基础',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-11 08:54:26'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/config/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">8</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/categories/daily/"><i class="fa-fw fas fa-mug-saucer"></i><span> 每日总结</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/config/default_top_img.png')"><nav id="nav"><span id="blog-info"><a href="/" title="Apong's Blog"><span class="site-name">Apong's Blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/categories/daily/"><i class="fa-fw fas fa-mug-saucer"></i><span> 每日总结</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java基础</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-04-03T13:10:14.000Z" title="发表于 2024-04-03 21:10:14">2024-04-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-04-11T00:54:26.748Z" title="更新于 2024-04-11 08:54:26">2024-04-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">16.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>58分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java基础"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>Java是基于jvm虚拟机运行的跨平台语言</li>
<li>内置垃圾收集，不用考虑内存管理</li>
</ul>
<h3 id="JRE-和-JDK-介绍"><a href="#JRE-和-JDK-介绍" class="headerlink" title="JRE 和 JDK 介绍"></a>JRE 和 JDK 介绍</h3><p><strong>JRE：</strong> 用于运行 被编译为字节码class 的 Java 代码</p>
<p><strong>JDK：</strong>提供编译器，调试器等用于编写 Java 代码工具</p>
<blockquote>
<p>JRE: Java Runtime Environment</p>
<p>JDK: Java Development Kit</p>
</blockquote>
<p><strong>命令行常用命令</strong></p>
<ul>
<li>Java: 启动jvm虚拟机，运行编译为class字节码的代码。</li>
<li>Javac: 编译Java代码</li>
<li>Javadoc: 注释文档</li>
<li>jdb: 调试器</li>
</ul>
<p><strong>JDK与JRE的关系</strong></p>
<p>JDK &#x3D; JRE + 开发工具（Javac.exe等）</p>
<p>JRE &#x3D; JVM + Java API</p>
<blockquote>
<p>开发程序，需要用到JDk，因为要用Javac编译.Java文件</p>
<p>运行程序，只需要用到JRE，包含了Java API</p>
</blockquote>
<h3 id="名词介绍"><a href="#名词介绍" class="headerlink" title="名词介绍"></a>名词介绍</h3><ol>
<li>JSR规范: Java Specification Request</li>
<li>JCP组织: Java Community Process</li>
</ol>
<blockquote>
<p> JSR规范用于保证 Java 语言的规范性。</p>
<p> 凡是想给 Java 平台添加一个功能，比如说访问数据库的功能，需要先创建一个 JSR规范，定义好接口。</p>
<p> 各个数据库平台必须按照规范实现该接口，开发者就用同样的API访问各个数据库平台。</p>
</blockquote>
<ol start="5">
<li>RI: Reference Implementation</li>
<li>TCK: Technology Compability Kit</li>
<li>IDE: Integrated Development Environment</li>
</ol>
<h2 id="语法规则"><a href="#语法规则" class="headerlink" title="语法规则"></a>语法规则</h2><h3 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h3><ul>
<li>变量、类名 必须以英文字母开头，后接字母，数字和下划线的组合</li>
<li>**类名 **习惯首字母大写</li>
<li>如果单个源文件中有多个类，那么只能有一个类是public类，表示该文件的主入口</li>
</ul>
<blockquote>
<p>在java编程思想（第四版）一书中有这样3段话（6.4 类的访问权限）：</p>
<p>每个编译单元（文件）都只能有一个public类，使得每个编译单元都有单一的公共接口，用public类来表现。该接口可以按要求包含众多的 支持包访问权限 的类。</p>
<p>如果在某个编译单元内有一个以上的public类，就不知道使用哪个类导致无法编译。</p>
<p>同时允许编译单元内完全不带public类，这时候可能会并入其他编译单元编译，并且启动该文件时需手动指定数据来源（文件内存在的多个class）</p>
</blockquote>
<ul>
<li>源文件的名字必须与 public 类的类名相同</li>
<li>如果源文件中没有 public 类，则文件名可以是任意的</li>
</ul>
<h3 id="Hello-world分析"><a href="#Hello-world分析" class="headerlink" title="Hello world分析"></a>Hello world分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>main方法必须声明为静态方法，作为程序执行入口</li>
<li>在书写完Java文件后，使用Javac命令编译源文件</li>
</ul>
<blockquote>
<p>  javac -encoding&#x3D;utf-8 Hello.java</p>
<p>  如果文件编码非utf-8需使用encoding选项指定编码格式</p>
</blockquote>
<ul>
<li>运行代码</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java Hello <span class="comment"># 不需要带.class扩展名</span></span><br></pre></td></tr></table></figure>



<h3 id="主类"><a href="#主类" class="headerlink" title="主类"></a>主类</h3><p>Java程序的执行入口是main方法，&#x3D;&#x3D;包含有main方法的类称为主类&#x3D;&#x3D;</p>
<ul>
<li>一个Java源文件中可以有零个或多个主类。</li>
</ul>
<blockquote>
<p>  假如一个Java文件中有3个类，则在编译后会生成3个class文件</p>
<p>  只有包含main方法的主类才能使用Java命令运行</p>
</blockquote>
<ul>
<li>如果程序中包含主类，则称为Java应用程序。没有就叫做Java库程序，通常被用来让其他Java程序调用.</li>
</ul>
<h3 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h3><blockquote>
<p>从源代码到可执行代码，称为编译，也称为正向工程。</p>
<p>从可执行代码到源代码，称为反编译，也称为逆向工程。</p>
</blockquote>
<p>可用 javap命令实现反编译。</p>
<blockquote>
<p> 但并没有实现完全的反编译，只反编译到<strong>方法声明</strong>这一层，<u>无法反编译方法内的代码。</u></p>
</blockquote>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><ol>
<li>&#x2F;&#x2F;…          单行注释</li>
<li>&#x2F;* … *&#x2F;   多行注释</li>
<li>&#x2F;** … *&#x2F; 文档注释</li>
</ol>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ol>
<li>整数类型：byte，short，int，long</li>
<li>浮点数类型：float，double</li>
<li>字符类型：char</li>
<li>布尔类型： boolean</li>
</ol>
<blockquote>
<p>只有 true 和 false 两个值。</p>
<p>Java语言对布尔类型的存储并没有做规定。</p>
<p>理论上存储布尔类型只需要1 bit，但是通常 JVM 内部会把boolean表示为4字节整数&#x3D;&#x3D;。</p>
</blockquote>
<ol start="5">
<li><u>引用类型</u>，类似如C语言的指针。</li>
</ol>
<blockquote>
<p>在Java中，对象的实例化变量常为引用类型</p>
</blockquote>
<ol start="6">
<li><p>常量，使用final关键字声明。</p>
</li>
<li><p>var关键字</p>
<p>当类型名太长可以用var来进行声明，编译器会根据赋值语句来自动推断出该变量的类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>特殊规则</strong></p>
<ul>
<li>Java只定义了带符号的整型，即最高位为符号位。如，<u>int 最大值为 2^31-1</u></li>
<li>支持使用 _ 来连接数字，结果和原数一致。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">2_000</span>;</span><br><span class="line">System.out.println(x);</span><br><span class="line"><span class="comment">// 输出: 2000</span></span><br></pre></td></tr></table></figure>

<ul>
<li>0前缀表示八进制</li>
<li>0x前缀表示十六进制</li>
<li>0b前缀表示二进制</li>
<li>long类型需在数字后加上字母大小写 “L”</li>
<li><strong>定义float类型变量时末尾一定要加上字母大小写”F”，因为默认浮点数为双精度（double）类型</strong></li>
</ul>
<h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ol>
<li><p><code>/</code> 除法运算符</p>
</li>
<li><p><code>%</code> 求余运算符</p>
</li>
<li><p><code>&gt;&gt;</code> 右移运算符，无法移动符号位，即负数右移后还是负数</p>
</li>
<li><p><code>&gt;&gt;&gt;</code> 可以移动符号位的右移运算符</p>
</li>
<li><p><code>&lt;&lt;</code> 左移运算符同理，不存在向左移动符号位的运算符。</p>
<blockquote>
<p>对<code>byte</code>和<code>short</code>类型进行移位时，会首先转换为<code>int</code>再进行位移。</p>
</blockquote>
</li>
<li><p><code>++</code>，<code>--</code> 自增自减运算符只能用于 整型 和 浮点型 变量。</p>
</li>
<li><p><code>instanceof</code> 运算符，判断前者是否为后者的实例化对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">a <span class="keyword">instanceof</span> Integer; <span class="comment">//得到true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>位运算：<code>&amp;</code>，<code>|</code>，<code>~</code>，<code>^</code> 分别是与，或，非，异或运算。</p>
</li>
<li><p>逻辑运算符：<code>&amp;&amp;</code>，<code>||</code>，<code>！</code> 的操作元必须是boolean型数据。</p>
</li>
</ol>
<h3 id="整数运算"><a href="#整数运算" class="headerlink" title="整数运算"></a>整数运算</h3><ol>
<li>两个整数相除只能得到结果的整数部分（即舍弃余数得到整数）</li>
<li>整数的除法对于除数为0时运行时将报错，但编译不会报错。</li>
</ol>
<p><strong>溢出：</strong></p>
<p>整数由于存在范围限制，如果计算结果超出了范围，就会产生溢出，而溢出<em>不会出错</em>，却会得到一个奇怪的结果。（占据符号位，成为负数）</p>
<h3 id="浮点数运算"><a href="#浮点数运算" class="headerlink" title="浮点数运算"></a>浮点数运算</h3><p><strong>浮点数比较正确做法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">r</span> <span class="operator">=</span> Math.abs(x - y); <span class="comment">// 取绝对值</span></span><br><span class="line"><span class="comment">// 精度范围</span></span><br><span class="line"><span class="keyword">if</span> (r &lt; <span class="number">0.00001</span>) &#123;</span><br><span class="line">    <span class="comment">// 认为相等</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 不相等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<p>在一个复杂的四则运算中，两个整数的运算不会出现自动提升的情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">1.2</span> + <span class="number">24</span> / <span class="number">5</span>; <span class="comment">// d = 1.2 + 4</span></span><br></pre></td></tr></table></figure>

<p>原因：类型提升指的是最后赋值的时候，而算式中 24 &#x2F; 5 依然遵循整数运算规则。</p>
<p><strong>溢出：</strong></p>
<p>整数运算在除数为<code>0</code>时会报错，而浮点数运算在除数为<code>0</code>时，不会报错，但会返回几个特殊值：</p>
<ul>
<li><code>NaN</code>表示Not a Number</li>
<li><code>Infinity</code>表示无穷大</li>
<li><code>-Infinity</code>表示负无穷大</li>
</ul>
<h3 id="布尔运算"><a href="#布尔运算" class="headerlink" title="布尔运算"></a>布尔运算</h3><p><strong>短路运算：</strong>如果一个布尔运算的表达式能提前确定结果，则后续的计算不再执行，直接返回结果。</p>
<h3 id="运算精度"><a href="#运算精度" class="headerlink" title="运算精度"></a><strong>运算精度</strong></h3><ul>
<li>如果表达式中最高精度低于Int型整数，则按int精度计算</li>
</ul>
<blockquote>
<p>如 ‘a’ + ‘b’ &#x3D; int型数字</p>
<p>byte x&#x3D;7; 则执行表达式 ‘B’+x; 的结果是int型。</p>
</blockquote>
<ul>
<li>char型数据和整型数据运算结果的精度是int精度</li>
<li>Java允许把不超出取值范围的算术表达式赋值给对应类型，<strong>但是当算术表达式中含有变量的时候，只会检查变量的类型</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">z</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">2</span> + z; <span class="comment">// 将int转化为byte类型，报错</span></span><br></pre></td></tr></table></figure>

<p>类型遵循自动&#x3D;&#x3D;小转大&#x3D;&#x3D;，不支持&#x3D;&#x3D;大转小&#x3D;&#x3D;（可以强制转型）</p>
<p><strong>强制转型：</strong>超出范围的强制转型会得到错误的结果</p>
<p>如 int -&gt; short：<code>int</code>的两个高位字节直接被扔掉，仅保留了低位的两个字节</p>
<ul>
<li>较小类型和较大类型运算，结果会自动转化为较大类型。</li>
</ul>
<h2 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h2><p>Java 在内存中总是使用 Unicode 表示字符。</p>
<p>所以 char 类型占用两个字节。</p>
<p>可以用转义字符 <code>\u</code> + Unicode编码（十六进制）表示一个字符</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意是十六进制:</span></span><br><span class="line"><span class="type">char</span> <span class="variable">c3</span> <span class="operator">=</span> <span class="string">&#x27;\u0041&#x27;</span>; <span class="comment">// &#x27;A&#x27;，因为十六进制0041</span></span><br></pre></td></tr></table></figure>





<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><ul>
<li><code>\&quot;</code> 表示字符<code>&quot;</code></li>
<li><code>\&#39;</code> 表示字符<code>&#39;</code></li>
<li><code>\\</code> 表示字符<code>\</code></li>
<li><code>\n</code> 表示换行符</li>
<li><code>\r</code> 表示回车符</li>
<li><code>\t</code> 表示Tab</li>
<li><code>\u####</code> 表示一个Unicode编码的字符</li>
</ul>
<h3 id="不可变特性"><a href="#不可变特性" class="headerlink" title="不可变特性"></a>不可变特性</h3><p>字符串的内容是常量，不可改变，<strong>无法通过索引元素改变其值</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串变了吗？</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">s1 = <span class="string">&quot;world&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>字符串变量为引用类型</p>
<p>对其再次赋值，仅仅改变其指向的内存，原内容依旧存在。</p>
<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a><strong>功能</strong></h3><ol>
<li><p>可以使用 “+” 连接字符串</p>
<p>也可以用 “+” 连接字符串和其他数据类型，结果为字符串类型，被拼接的其他数据类型自身不会改变。</p>
</li>
<li><p>‘’’ … ‘’’ 三引号用于表示多行字符串，<strong>Java 13 以后</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">...........SELECT * FROM</span></span><br><span class="line"><span class="string">...........  users</span></span><br><span class="line"><span class="string">...........WHERE id &gt; 100</span></span><br><span class="line"><span class="string">...........ORDER BY name DESC</span></span><br><span class="line"><span class="string">...........&quot;&quot;&quot;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong>字符串s占据&#x3D;&#x3D;5行&#x3D;&#x3D;，因为在desc后面还有一个’\n’，如果不想要5行，可以直接把三引号写在结尾</p>
<p><strong>排版：</strong>最后会根据每行字符的相对位置来显示，共同的空格会被忽略，不规则排版则是以最短的空格为基准。</p>
</li>
<li><p>null 与 “” 的区别</p>
<p>null：一个引用空值。</p>
<p>“”：一个空的字符串，并不是空值。</p>
</li>
</ol>
<h3 id="在引用的使用"><a href="#在引用的使用" class="headerlink" title="== 在引用的使用"></a><code>==</code> 在引用的使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;HELLO&quot;</span>.toLowerCase();</span><br><span class="line">System.out.println(a == b); <span class="comment">// false</span></span><br><span class="line"><span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> a;</span><br><span class="line">System.out.println(a == c); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>原因是：<code>==</code> 用于判断两者是否为同一个引用，而不是判断内容是否一致。</p>
<p>判断字符串内容相等可以使用String类型的equals方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.equals(b)</span><br></pre></td></tr></table></figure>



<p><strong>低内存的特殊</strong></p>
<p>对于数值占用内存较少的情况，JVM 为了节省内存空间，在创建不同变量的时候指向的内存地址都是一样的。</p>
<p>如在128以内（不包括128）的数字</p>
<p>当有多个引用指向它们时，地址是一样的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">System.out.println(a == b); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>



<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>Java 中为了保存 C 语言开发的习惯，保留了<code>int arr[]</code> 和 <code>int[] arr</code> 声明数组类型的形式。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ol>
<li><p>new关键字</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>可以把 <code>int[]</code> 看做一整个数组类，new 出一个 int[] 的对象。</p>
</li>
<li><p>数组常量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>数组常量只能用于初始化，不能声明再赋值。</p>
</li>
</ol>
<h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ol>
<li><p>int[] 括号内不需要指定数字，在初始化的时候会自动推断。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &#123;&#125;内指定了数组元素，这里的3可以省略</span></span><br><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>

<p>如果没有指定，也没有指定数字（数组长度），那这个数组长度只有就是0。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个长度为 10 的数组，默认值为 0</span></span><br><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化后，数组的长度将不可改变，超出长度的索引会报异常。</p>
</li>
<li><p>创建的数组元素，如果没有赋予初值，会被赋予默认值</p>
<ul>
<li><p>数值型基本数据类型的默认值是 0</p>
</li>
<li><p>char 类型的默认值为 ‘\u0000’ </p>
</li>
<li><p>boolean 类型默认值为 false。</p>
</li>
</ul>
</li>
<li><p>通过访问 length 属性可以获得数组的长度。</p>
</li>
</ol>
<p><strong>注意：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    String[] names = &#123;<span class="string">&quot;ABC&quot;</span>, <span class="string">&quot;XYZ&quot;</span>, <span class="string">&quot;zoo&quot;</span>&#125;;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> names[<span class="number">1</span>];</span><br><span class="line">    names[<span class="number">1</span>] = <span class="string">&quot;cat&quot;</span>;</span><br><span class="line">    System.out.println(s);	<span class="comment">// s是被赋值为XYZ了，而不是names[1]的引用</span></span><br><span class="line">    System.out.println(Arrays.toString(names)); <span class="comment">// [ABC, cat, Zoo]</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>names[1] 是一个元素，不是引用。</p>
<h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><p><strong>初始化</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] ns = &#123;</span><br><span class="line">    &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;,</span><br><span class="line">    &#123; <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span> &#125;,</span><br><span class="line">    &#123; <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// new</span></span><br><span class="line"><span class="type">int</span>[][] ns = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;</span><br><span class="line">    &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;,</span><br><span class="line">    &#123; <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span> &#125;,</span><br><span class="line">    &#123; <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>打印多维数组</strong></p>
<p>打印多维数组可以使用<code>Arrays.deepToString()</code>；</p>
<h3 id="排序数组"><a href="#排序数组" class="headerlink" title="排序数组"></a>排序数组</h3><p>使用 Arrays 类的成员函数sort，可对数组进行排序</p>
<p><strong>默认小到大排列</strong>: Arrays.sort(arr);</p>
<p><strong>逆序</strong>: Arrays.sort(arr，Collections.reverseOrder())</p>
<p>sort 不能直接用于排列多维数组，&#x3D;&#x3D;使用什么可以排序多维数组呢&#x3D;&#x3D;</p>
<p>多维数组不需要排序，本质是处理每个一维数组。</p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ol>
<li>使用 Scanner 类初始化数组</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> n: arr)&#123;</span><br><span class="line">    n = scanner.nextInt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>随机打乱</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[index];</span><br><span class="line">    arr[index] = arr[arr.length - <span class="number">1</span>];</span><br><span class="line">    arr[arr.length - <span class="number">1</span>] = temp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line"> 		<span class="comment">// 随机位置与数组的最后一个元素交换</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (<span class="type">int</span>)(Math.random() * arr.length);</span><br><span class="line">        swap(arr, index);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Arrays.toString(arr));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：使用传递&#x3D;&#x3D;数组引用&#x3D;&#x3D;的方式才能在 不同作用域 交换数组内的值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Swap</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr，<span class="type">int</span> i，<span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String args[ ])</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>，<span class="number">2</span>&#125;;</span><br><span class="line">        Swap.swap(arr，<span class="number">0</span>，<span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr)); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>复制数组</p>
<ol>
<li><p>使用Java.util.Arrays的静态方法copyOf复制数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newArr = Arrays.copyOf(oldArr，neededLength);</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用System类中的静态方法arraycopy</p>
</li>
<li><p>使用clone方法复制数组</p>
</li>
</ol>
</li>
<li><p>for each循环</p>
<p>对于可迭代对象，使用for循环的”for each”形式会显得更加简洁</p>
<p>形式: for( varName :  arrayName) {…}</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span>，<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> n: arr)&#123;</span><br><span class="line">            System.out.println(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>这里的n，代表数组中的每个元素，而不是索引值</p>
</li>
<li><p>使用该方法遍历数组，无法控制访问顺序</p>
</li>
<li><p>for each循环还可用于List，Map等数据结构</p>
</li>
</ul>
</li>
<li><p>转 Stream 流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.stream(arr)</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h2><blockquote>
<p>在使用 java 命令执行 java 文件的时候</p>
</blockquote>
<p>可以传入 …String 类型的参数，由 public 类的入口函数 main 的 args 参数获取</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java Main &quot;123&quot; &quot;456&quot;</span><br><span class="line">// args: [&quot;123&quot;, &quot;456&quot;]</span><br></pre></td></tr></table></figure>





<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><blockquote>
<p> 通常使用Scanner类的实例对象来接受用户输入</p>
</blockquote>
<p>Scanner 类包含在 <code>java.util</code> 包内，需要先引入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">myScan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);	<span class="comment">// 传入输入流</span></span><br><span class="line">        <span class="comment">// 使用nextInt()获取整型数据</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> myScan.nextInt();</span><br><span class="line">        <span class="comment">// 使用nextLine()获取一行字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> myScan.nextLine();</span><br><span class="line">        <span class="comment">// next...等等</span></span><br><span class="line">        <span class="comment">// 使用完毕后，关闭输入流</span></span><br><span class="line">        myScan.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong> </p>
<p>nextInt 表示获取用户的下一个输入并转化为 int 类型，不是从输入中获取下一个 int 类型</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用户输入</span></span><br><span class="line">a 123</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">nextInt 会接收 a</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">并抛出 java.util.InputMismatchException 异常</span></span><br></pre></td></tr></table></figure>



<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>使用System.out输出流向输出端输出数据</p>
<ul>
<li>System.out.println() 输出一行</li>
<li>System.out.print()    直接输出</li>
<li>System.out.printf()   格式化输出</li>
</ul>
<p><strong>格式字符：</strong></p>
<p>%d 输出整型数据</p>
<p>%c 输出字符型数据</p>
<p>%f 输出浮点型数据</p>
<p>使用如%m.nd形式，可以控制输出的排版。</p>
<p>m：数字所占位数</p>
<p>n：小数位数</p>
<p><strong>注意</strong>：因为 % 表示占位符，所以连续两个 %% 才表示一个 % 字符本身。</p>
<h3 id="if判断"><a href="#if判断" class="headerlink" title="if判断"></a>if判断</h3><p>if 中表达式必须是 &#x3D;&#x3D;boolean类型&#x3D;&#x3D;，不能使用 0，1，null 代替</p>
<h3 id="switch新用法"><a href="#switch新用法" class="headerlink" title="switch新用法"></a>switch新用法</h3><p>switch 中 case 的条件必须是常量，枚举也可以。</p>
<p><strong>Java 12</strong> 开始，使用 <code>-&gt;</code> 符号可以<strong>无需break</strong>，直接指定执行单一路径，而不会继续向下执行其他语句</p>
<p>switch 将返回被执行 case 条件的结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">fruit</span> <span class="operator">=</span> <span class="string">&quot;apple&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">opt</span> <span class="operator">=</span> <span class="keyword">switch</span> (fruit) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;apple&quot;</span> -&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;pear&quot;</span> -&gt; <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">default</span> -&gt; <span class="number">0</span>;</span><br><span class="line">        &#125;;	<span class="comment">// 赋值语句后以 ; 结束</span></span><br><span class="line">        System.out.println(opt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果需要使用复杂的语句，可以使用花括号{}包裹，再通过yield关键字返回值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&quot;mango&quot;</span> -&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">code</span> <span class="operator">=</span> fruit.hashCode();</span><br><span class="line">    <span class="keyword">yield</span> code;		<span class="comment">// code作为该分支的返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>从 Java 13 开始允许使用yield返回值</p>
</blockquote>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><h4 id="while"><a href="#while" class="headerlink" title="while"></a><strong>while</strong></h4><p>while循环中的判断条件必须是一个 boolean 值，如 3 &gt; 2 的结果，而不能直接放一个数字</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">      <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123; <span class="comment">// 在C语言中可以直接写为 n</span></span><br><span class="line">         res += n--;</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(res);</span><br><span class="line">   &#125; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>对于循环条件判断，以及自增变量的处理，要特别注意边界条件。思考一下下面的代码为何没有获得正确结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">            n ++;</span><br><span class="line">            sum = sum + n;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum); <span class="comment">// 5151</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>n的边界是 0 -&gt; 100，当 n &#x3D; 100 时，会再次进入循环，n 变成了 101。</p>
<p>导致结果多加了一个 101，原本为 5050</p>
<p>将这个操作改为 for 循环则不会有这个问题，因为 自增变量 始终作为后置条件在循环体内执行完之后。</p>
<h4 id="do-while"><a href="#do-while" class="headerlink" title="do while"></a>do while</h4><p>改写 while 循环的 1 到 100 求和</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            sum = sum + n;</span><br><span class="line">            n ++;</span><br><span class="line">        &#125; <span class="keyword">while</span> (n &lt;= <span class="number">100</span>);</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4><p>改写 1 到 100 求和</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">100</span>; i++) &#123;</span><br><span class="line">            sum = sum + i;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>计数器定义位置</strong></p>
<p>如果变量 <code>i</code> 定义在 <code>for</code> 循环外：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int[] ns = &#123; 1, 4, 9, 16, 25 &#125;;</span><br><span class="line">int i;</span><br><span class="line">for (i=0; i&lt;ns.length; i++) &#123;</span><br><span class="line">    System.out.println(ns[i]);</span><br><span class="line">&#125;</span><br><span class="line">// 仍然可以使用i</span><br><span class="line">int n = i;</span><br></pre></td></tr></table></figure>

<p>破坏了<strong>变量应该把访问范围缩到最小</strong>的原则。</p>
<h4 id="for-each"><a href="#for-each" class="headerlink" title="for each"></a>for each</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] ns = &#123; <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span> &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> n : ns) &#123;</span><br><span class="line">            System.out.println(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和<code>for</code>循环相比，<code>for each</code>循环的变量n不再是计数器，而是直接对应到数组的每个元素。</p>
<p>除了数组外，<code>for each</code>循环能够遍历所有“可迭代”的数据类型，包括后面会介绍的<code>List</code>、<code>Map</code>等。</p>
<h4 id="break-和-continue"><a href="#break-和-continue" class="headerlink" title="break 和 continue"></a>break 和 continue</h4><p>break：跳出最近一层循环，多层循环只能跳出一层</p>
<p>continue：跳出本次循环，执行下一个符合条件的循环</p>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h5 id="0-特点"><a href="#0-特点" class="headerlink" title="0. 特点"></a>0. 特点</h5><ul>
<li>封装性</li>
<li>继承</li>
<li>多态</li>
</ul>
<h5 id="1-字段"><a href="#1-字段" class="headerlink" title="1. 字段"></a>1. 字段</h5><blockquote>
<p>字段即成员变量</p>
</blockquote>
<p>​	没有初始化的引用字段，默认为null值; 其他类型的也是默认值，如Int类型是0，boolean是false;</p>
<h6 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h6><ul>
<li>静态方法可以通过对应类的空对象访问</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="literal">null</span>;	<span class="comment">// 定义Test类空对象</span></span><br><span class="line">        test.f1();			<span class="comment">// 使用空对象访问静态方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>:</p>
<ul>
<li>在&#x3D;&#x3D;成员函数内部&#x3D;&#x3D;声明的局部变量不会自动初始化，需要初始化后才可引用</li>
<li>无论成员变量，和成员函数声明定义的顺序如何，&#x3D;&#x3D;成员变量是先与成员函数生成的&#x3D;&#x3D;，所以可以出现以下这种情况</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> m; <span class="comment">// m被定义为成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>不能在成员函数中定义<strong>与参数重名</strong>的变量</li>
<li>可以在成员函数中定义与成员变量同名的变量，定义的局部变量会覆盖成员变量。</li>
</ul>
<h5 id="2-构造函数"><a href="#2-构造函数" class="headerlink" title="2. 构造函数"></a>2. 构造函数</h5><blockquote>
<p>构造函数支持重载(Overload)</p>
</blockquote>
<p>​	Java中可以通过<strong>this引用</strong>可以在一个构造函数中调用其他构造函数，<u>但是C++不行</u>，因为可以有默认参数， 所以就没有构造函数的相互调用了，但是C++可以调用父类的构造函数</p>
<h5 id="3-this关键字"><a href="#3-this关键字" class="headerlink" title="3. this关键字"></a>3. this关键字</h5><ul>
<li>this是Java的一个关键字，表示某个对象<ul>
<li>在构造方法中，代表该构造方法所创建的对象。</li>
<li>实例方法中，代表正在调用该方法的当前对象。</li>
</ul>
</li>
<li>this不能用于类成员变量和类方法。</li>
<li>可用this调用被隐藏的成员变量</li>
</ul>
<blockquote>
<p>如：当局部变量和成员变量重名时，可以使用this.成员变量访问到它</p>
</blockquote>
<h5 id="4-包"><a href="#4-包" class="headerlink" title="4. 包"></a>4. 包</h5><p>包是一种用来管理类的机制，可以有效地区分名字相同的类</p>
<p><strong>使用方法</strong>：</p>
<ul>
<li>用package 包名;语句声明该源文件所在的包</li>
</ul>
<p><strong>注意事项</strong>：</p>
<ul>
<li>该语句必须作为源文件的第一行语句。</li>
<li>建议用域名反写的方式建包（目前还没有看懂）。</li>
<li>包的名字，必须为源文件所在路径，不能随意起名。</li>
</ul>
<blockquote>
<p>如tom&#x2F;jiafei&#x2F;路径下有Test.Java文件，则该文件的包名可以为tom.jiafei</p>
</blockquote>
<p><strong>运行方式</strong>：</p>
<p>​	如果主类的包名是tom.jiafei，就<strong>必须到</strong>tom\jiafei的上一层（即tom的父目录）目录中去运行主类。</p>
<blockquote>
<p>假设tom\jiafei的上一层目录是1000，那么必须用如下格式来运行： C:\1000&gt; Java tom.jiafei.主类名</p>
</blockquote>
<p><strong>import语句</strong></p>
<p>既然有包的建立，那必然有引用包。</p>
<blockquote>
<p>系统会自动导入Java.lang包中所有的类。</p>
</blockquote>
<p>通过import语句，可以使该源文件能够调用其他包中的类。</p>
<p>&#x3D;&#x3D;父包和子包没有关系，包含的类也没有关系&#x3D;&#x3D;</p>
<h5 id="5-修饰符"><a href="#5-修饰符" class="headerlink" title="5. 修饰符"></a>5. 修饰符</h5><p>Java使用四种修饰符，来限制类中的成员变量和成员函数被访问的权限</p>
<ul>
<li>public类。 该类成员可以被所有类访问</li>
<li>protected类。 该类成员只能被同一文件，同一包内的类或子类访问。</li>
<li>没有修饰符的称为default类。 只能被同一文件，和同一包内的类访问。</li>
</ul>
<blockquote>
<p>子类不能访问指：其他包通过引用该包，然后继承该包中的某一个类，该子类无法访问父类的成员。</p>
</blockquote>
<p>&#x3D;&#x3D;事实证明即使是default类，只要其子类在同一个文件或包，依旧能够访问父类成员。&#x3D;&#x3D;</p>
<ul>
<li>private类。 该类成员只能被自己访问。</li>
</ul>
<h5 id="6-包装类"><a href="#6-包装类" class="headerlink" title="6. 包装类"></a>6. 包装类</h5><p>为了方便基本数据类型的使用，Java提供了基本数据类型的相关类，实现了对其的封装。</p>
<p>如：Integer,Character,Byte等类。</p>
<p>构造方法如：Integer a &#x3D; new Integer(2);</p>
<p>返回类中包含的值：a.value();</p>
<h5 id="7-上转型对象"><a href="#7-上转型对象" class="headerlink" title="7. 上转型对象"></a>7. 上转型对象</h5><p>将子类的对象传递给父类引用，称为上转型对象。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Father</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line"><span class="comment">// 第二种情况</span></span><br><span class="line">Father f;</span><br><span class="line"><span class="type">Son</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">f = s;</span><br></pre></td></tr></table></figure>

<p><strong>使用</strong>：</p>
<ul>
<li>不可以使用子类新增的成员（变量、函数）</li>
<li>可以使用子类继承和重写的方法</li>
<li>可以使用子类隐藏的成员变量</li>
</ul>
<blockquote>
<p>如：父类有int a变量，而子类定义了同名变量double a，而上转型对象调用的是父类的a变量。</p>
</blockquote>
<p>&#x3D;&#x3D;不支持向下转型，会报出ClassCastException&#x3D;&#x3D;</p>
<p><strong>多态</strong></p>
<p>多态就是指父类的某个方法被子类重写后产生自己的功能行为，各个子类都不同。</p>
<h5 id="8-抽象类"><a href="#8-抽象类" class="headerlink" title="8. 抽象类"></a>8. 抽象类</h5><p>用于定义共有的属性（变量、方法），合理地使用抽象类，可以写出易维护、易扩展的程序。</p>
<p>&#x3D;&#x3D;抽象类可以没有abstract方法&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;不可以使用static修饰抽象类&#x3D;&#x3D;，因为抽象类没有实例吧。</p>
<p><strong>使用</strong>：</p>
<ul>
<li>具备一般类的基本能力，可以有字段、构造方法；<strong>但不能实例化abstract类对象</strong></li>
<li>不能用final修饰抽象类，因为定义抽象类就是要用来继承的。</li>
<li>抽象类的非抽象子类必须实现抽象父类的所有抽象方法。</li>
</ul>
<p><strong>缺点</strong>：&#x3D;&#x3D;Java中只能继承一个类，所以抽象类并不完善&#x3D;&#x3D;</p>
<h5 id="9-接口"><a href="#9-接口" class="headerlink" title="9. 接口"></a>9. 接口</h5><p>为了弥补只能继承一个类的缺陷，Java定义了接口概念。</p>
<p>接口和抽象类差不多，但是比抽象类更加标准化。接口还有一个优势：&#x3D;&#x3D;允许非同一父类的子类拥有相同名称的方法。&#x3D;&#x3D;</p>
<p><strong>使用</strong>：</p>
<p>通过interface 接口名{}，与定义一个类差不多的形式定义接口；</p>
<ul>
<li>接口中不存在变量。&#x3D;&#x3D;声明常量时必须初始化，不具有默认值&#x3D;&#x3D;</li>
</ul>
<p>类似int MAX &#x3D; 100;</p>
<p>等价于：(public static final) int MAX &#x3D; 100; 	括号内为缺省类型，即可以省略不写。</p>
<ul>
<li>接口中所有的方法默认都是抽象方法</li>
</ul>
<p>如void f(); &#x3D;&gt; 等价于 public abstract void f() {};</p>
<ul>
<li>可以用default关键字定义实例方法（JDK8后），必须是public方法，可省略不写。</li>
</ul>
<blockquote>
<p>default方法与普通类的实例方法一致，该接口的实现类可以选择是否重写，重写需去掉default关键字。</p>
</blockquote>
<ul>
<li>允许使用static关键字定义静态方法（JDK8后）</li>
<li>允许使用private关键字定义私有方法，接口的实现类无法访问private方法，目的是配合default方法使用实现一些算法的封装。（JDK9）</li>
</ul>
<p><strong>注意</strong>：</p>
<ul>
<li>接口没有构造函数</li>
<li>所有字段除了private， 其他的访问权限都是public</li>
</ul>
<p><strong>实现接口</strong></p>
<p>通过implements关键字可以实现一个或多个接口，接口之间用逗号隔开。</p>
<ul>
<li>非抽象类实现接口，必须重写所有抽象方法。</li>
<li>接口的实现了不拥有接口的<strong>静态</strong>和私有方法。</li>
<li>实现接口方法的访问权限必须是public， <strong>允许重载接口方法，并修改访问权限</strong></li>
</ul>
<blockquote>
<p>如接口有void cry(); 子类可以定义protected void cry(int m)方法。</p>
</blockquote>
<p><strong>接口回调</strong></p>
<p>将接口的实现类对象的引用赋值给接口变量，再通过接口变量调用实现类实现的方法，称为接口回调。</p>
<p>实际过程是：在接口变量调用方法时，根据地址通知对应的对象去调用对应的方法。</p>
<p><strong>接口与抽象类的比较</strong></p>
<ul>
<li>接口和abstract类的比较如下：<ul>
<li>abstract类和接口都可以有abstract方法。</li>
<li>接口中只可以有常量，不能有变量；而abstract类中即可以有常量也可以有变量。</li>
<li>abstract类中也可以有非abstract方法，接口不可以(JDK 7及以前的版本）。</li>
</ul>
</li>
</ul>
<h5 id="10-Lambada表达式（JDK8后）"><a href="#10-Lambada表达式（JDK8后）" class="headerlink" title="10. Lambada表达式（JDK8后）"></a>10. Lambada表达式（JDK8后）</h5><p>Lambada表达式，又称为匿名表达式；常用在单接口（只具有一个abstract方法的接口）的接口回调中。</p>
<p>形式：（参数列表） -&gt; {方法体}</p>
<p>Lambada表达式的值就是该方法的入口地址，可以将其赋给接口变量来实现单接口，用于接口回调。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        A obj;</span><br><span class="line">        obj = () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">        &#125;;			<span class="comment">// 分号不要忘记了</span></span><br><span class="line">        obj.f();	<span class="comment">// 输出 ok</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="11-内部类"><a href="#11-内部类" class="headerlink" title="11. 内部类"></a>11. 内部类</h5><p>在一个类中，再定义一个类，那么该类就叫做内部类。</p>
<blockquote>
<p>为了代码的易维护，和相关性，可以将需要用到的类写在另一个类中作为内部类。</p>
<p>对于拥有内部类的类，在编译后将生成多个class文件。</p>
</blockquote>
<p><strong>使用</strong>：</p>
<ul>
<li>外嵌类可以声明内部类对象</li>
<li>内部类不能定义静态成员。&#x3D;&#x3D;为什么内部类可以用static声明&#x3D;&#x3D;。</li>
</ul>
<h5 id="12-匿名类"><a href="#12-匿名类" class="headerlink" title="12. 匿名类"></a>12. 匿名类</h5><blockquote>
<p>有时候为了方便可以通过类体直接创建一个子类</p>
</blockquote>
<ul>
<li>可以是继承父类的子类</li>
<li>也可以是实现接口的子类</li>
<li>使用Lambada表达式做到的接口回调也是匿名类。</li>
</ul>
<p>形式：</p>
<p>new 父类构造方法 &#x2F; 接口名() {类体}</p>
<p>&#x3D;&#x3D;匿名类属于内部类&#x3D;&#x3D;</p>
<h5 id="13-异常类"><a href="#13-异常类" class="headerlink" title="13. 异常类"></a>13. 异常类</h5><p>用于提供程序运行出现错误的信息，及错误的捕捉</p>
<p>异常对象可以调用如下方法得到&#x2F;输出异常相关的信息</p>
<ul>
<li>public String getMessage();</li>
<li>public void printStackTrace();</li>
<li>public String toString();</li>
</ul>
<p><strong>捕捉异常</strong></p>
<p>Java使用try~catch~finally（可选）来捕捉处理异常，允许存在多条catch语句</p>
<p>&#x3D;&#x3D;多条catch语句可以分别处理异常，不是匹配一个就结束&#x3D;&#x3D;</p>
<p>注意：子类异常必须放在父类异常前面，因为父类异常包含子类。</p>
<p><strong>抛出异常</strong></p>
<p>在方法体内使用throw抛出异常对象: throw new Exception();</p>
<p>使用throws声明异常，声明该方法可能会出现的异常</p>
<h2 id="核心类"><a href="#核心类" class="headerlink" title="核心类"></a>核心类</h2><h5 id="1-String类"><a href="#1-String类" class="headerlink" title="1. String类"></a>1. String类</h5><p>String类不可继承。</p>
<p>String常量：用双引号括起来的字符序列。Java把String常量放在常量池内。</p>
<p>&#x3D;&#x3D;重点&#x3D;&#x3D;</p>
<ul>
<li>将一个String常量赋给变量时，如果内容相同的String常量在常量池里已经存在，则不会创建新的字符串常量，而是将已存在的字符串常量引用赋给该变量。</li>
</ul>
<blockquote>
<p>即：String a &#x3D; “hello”; String b &#x3D; “hello”;</p>
<p>a &#x3D;&#x3D; b &#x2F;&#x2F;输出true</p>
</blockquote>
<ul>
<li><p>而使用new关键字创建字符串对象，是在堆内申请一份新内存，因此内容相同但不是同一个引用。</p>
</li>
<li><p>String类对象在生成后，无法改变其中的值。</p>
</li>
</ul>
<blockquote>
<p>String a &#x3D; “hello”;</p>
<p>a[1] &#x3D; ‘a’;	&#x2F;&#x2F; 错误，并且只能通过charAt(index)方法访问。</p>
</blockquote>
<ul>
<li>通过+号可以使字符串进行并置运算。</li>
</ul>
<p>常量并置运算后依旧是常量，而一旦变量参与并置运算，就会重新在堆中创建新的String对象。</p>
<p><strong>与第一点共同思考</strong></p>
<blockquote>
<p>String str1 &#x3D; “helloJava”;</p>
<p>String str2 &#x3D; “hello” + “Java”;</p>
<p>str1 &#x3D;&#x3D; str2 	&#x2F;&#x2F; 得到true，运算后依旧是常量</p>
<p>String a &#x3D; “hello”，b &#x3D; “Java”；</p>
<p>String c &#x3D; a + b;</p>
<p>c &#x3D;&#x3D; str1; 		&#x2F;&#x2F; 得到false，因为a，b为String类变量，所以在并置运算后得到新的字符串对象。</p>
</blockquote>
<p><strong>与字符数组</strong></p>
<p>可以使用字符数组创建String类对象，也可限制范围；</p>
<ul>
<li>String(char a[],int startIndex,int count)；</li>
</ul>
<p>也可以String转字符数组</p>
<ul>
<li>public void getChars(int start,int end,char c[],int offset ) </li>
<li>public char[] toCharArray()</li>
</ul>
<p><strong>与字节数组</strong></p>
<p>String转字节数组</p>
<ul>
<li>public byte[] getBytes()。使用平台默认的字符编码。 </li>
<li>public byte[] getBytes(String charsetName)。指定字符编码</li>
</ul>
<p>&#x3D;&#x3D;GB2312编码中，一个汉字占两个字节。&#x3D;&#x3D;</p>
<h5 id="2-正则表达式"><a href="#2-正则表达式" class="headerlink" title="2. 正则表达式"></a>2. 正则表达式</h5><h5 id="3-Class类与反射"><a href="#3-Class类与反射" class="headerlink" title="3. Class类与反射"></a>3. Class类与反射</h5><blockquote>
<p>​	任何类默认有一个public的静态的(static)Class对象，该对象的名字是class（用关键字做了名字，属于Java系统特权），该对象封装当前类的有关信息（即类型的信息），如该类有哪些构造方法，哪些成员变量，哪些方法等。也可以让类的对象调用getClass()方法（从Java.lang.Object类继承的方法）返回这个Class对象：class。</p>
</blockquote>
<p>Class对象(class)调用方法可以获取当前类的有关信息，比如，类的名字、类中的方法名称、成员变量的名称等等，这一机制也称为Java反射。</p>
<p><strong>用Class类和反射机制创建新对象</strong>（有点问题）</p>
<ol>
<li>使用用Class类的类方法forName(String className)返回对应类的Class对象。</li>
<li>再让这个Class对象调用getDeclaredConstructor()方法得到 对应类 的 无参数的<strong>构造方法</strong>对象。</li>
<li>然后构造方法对象再调用newInstance()返回该类的对象</li>
</ol>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>通过代码块捕获 异常class类，来知道发生了什么错误，并进行下一步处理。</p>
<h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>类的继承关系如下：</p>
<p><img src="/../assets/image-20240403211146797.png" alt="image-20240403211146797"></p>
<p><code>Error</code>表示严重的错误，程序对此一般无能为力</p>
<ul>
<li><code>OutOfMemoryError</code>：内存耗尽</li>
<li><code>NoClassDefFoundError</code>：无法加载某个Class</li>
<li><code>StackOverflowError</code>：栈溢出</li>
</ul>
<p>而<code>Exception</code>则是运行时的错误，它可以被捕获并处理。</p>
<p>某些异常是应用程序逻辑处理的一部分，应该捕获并处理。例如：</p>
<ul>
<li><code>NumberFormatException</code>：数值类型的格式错误</li>
<li><code>FileNotFoundException</code>：未找到文件</li>
<li><code>SocketException</code>：读取网络失败</li>
</ul>
<p><strong>Java规定（编辑器也会提示）：</strong></p>
<ol>
<li><p>必须捕获的异常（Checked Exception），包括<code>Exception</code>及其子类，但不包括<code>RuntimeException</code>及其子类。</p>
<p>Checked Exception：需要检查的异常</p>
<p>不包括在内的异常，可以由开发者自由选择是否捕获。</p>
<p>如 <code>NullPointerException</code> ，你可以自己选择是否捕获并处理该异常。</p>
<p>而 <code>IOException</code>，在 Java 环境中是必须要声明捕获的。 </p>
</li>
<li><p>不需要捕获的异常，包括<code>Error</code>及其子类，<code>RuntimeException</code>及其子类。</p>
</li>
</ol>
<p><strong>异常处理建议：</strong>异常不应该在产生的代码层级 <strong>空捕获不处理</strong>，即使真的什么也做不了，也应该把异常记录下来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">byte</span>[] toGBK(String s) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">        <span class="comment">// 先记下来再说:</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有异常都可以调用<code>printStackTrace()</code>方法打印异常栈（先进后出）。</p>
<p>因为是栈，所以异常栈最下面才是触发异常的源头。</p>
<h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><p><strong>catch 语句</strong></p>
<p>可以使用多个 <code>catch</code> 语句。</p>
<p>从上到下匹配对应异常类，但是只有一个能被执行。</p>
<p>因此顺序应保持：子类必须写在前面。</p>
<p>因为如果父类（范围大的异常）写在子类前面，就捕获不到子类了，等于没写。</p>
<p><strong>finally 语句</strong></p>
<p>无论异常是否发生，被捕获到，finally中的语句都会被执行。</p>
<p>特点：</p>
<ol>
<li>非必须</li>
<li>总是在 try ~ catch 之后，最后被执行</li>
</ol>
<p>finally 用于保证一些代码必须被执行，防止因为异常跳出了代码原本的运行逻辑。</p>
<p><strong>合并处理异常</strong></p>
<p>每个异常类应该是在不同 bit 位上，因此可以用 <code>|</code> 或运算符联合多个异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process1();</span><br><span class="line">        process2();</span><br><span class="line">        process3();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException | NumberFormatException e) &#123; <span class="comment">// IOException或NumberFormatException</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Bad input&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Unknown error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>完整示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process1();</span><br><span class="line">        process2();</span><br><span class="line">        process3();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bad encoding&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;IO error&quot;</span>);</span><br><span class="line">    <span class="comment">// 常用于保证同步读写操作流的关闭</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;END&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h3><p><strong>异常传播</strong></p>
<p>当某个方法抛出异常后，如果当前方法没有捕获异常，异常就会被抛到上层调用方法，直到被捕获为止。</p>
<p><strong>抛出异常</strong></p>
<ol>
<li>创建某个 <code>Exception</code> 的实例</li>
<li>用 <code>throw</code> 语句抛出</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">process2</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">NullPointerException</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大部分情况下会合并写成一行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">process2</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="异常“转换”"><a href="#异常“转换”" class="headerlink" title="异常“转换”"></a><strong>异常“转换”</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">process1</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process2();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">process2</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>process1在捕获到process2的异常后，抛出了另一个异常 <code>IllegalArgumentException</code>。</p>
<p>那么原异常信息就会丢失，“转换”成了另一个异常暴露给外部</p>
<p>如果想要在抛出新的异常下，同时保留原始的异常信息，就需要把原始异常的实例作为新的异常构建参数传入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">process1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process2();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">        <span class="comment">// 传入原异常实例</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">process2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样在输出的异常栈信息中，就会包括原始的异常信息。</p>
<p><strong>捕获到异常并再次抛出时，一定要留住原始异常，否则很难定位第一案发现场！</strong></p>
<h3 id="异常屏蔽"><a href="#异常屏蔽" class="headerlink" title="异常屏蔽"></a>异常屏蔽</h3><p><strong>finally 与 catch 的执行顺序</strong></p>
<p>finally 语句的内容是一定会执行的，相比于 catch 语句的执行顺序呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Integer.parseInt(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;catched&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;finally&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">catched</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.RuntimeException: java.lang.NumberFormatException: For input string: <span class="string">&quot;abc&quot;</span></span><br><span class="line">    at Main.main(Main.java:<span class="number">8</span>)</span><br><span class="line">Caused by: java.lang.NumberFormatException: For input string: <span class="string">&quot;abc&quot;</span></span><br><span class="line">    at ...</span><br></pre></td></tr></table></figure>

<p>第一行打印了<code>catched</code>，第二行打印了<code>finally</code>。</p>
<p>说明先进入 catch 语句，再执行 finally 语句，并且 catch 中抛出的异常不会影响到 finally 执行</p>
<p><strong>异常屏蔽</strong></p>
<p>如果在执行 <code>finally</code> 语句时抛出异常，那么，<code>catch</code> 语句的异常还能否继续抛出？</p>
<p>答案：catch 中抛出的异常最终会被 finally 中抛出的异常“覆盖”。</p>
<p>本质猜测：</p>
<p>在 JVM 中有一个全局异常处理Handler，在执行目标类中的代码时，虽然 catch 先抛出了异常，但是要等 finally 执行完，handler 中的 catch 才对异常进行捕获，这时候 finally 中抛出的异常也会进入异常栈，覆盖原始异常，类似上述的异常“转换”，从而丢失原来的异常。</p>
<blockquote>
<p>catch 中只能抛出一个异常，没有被抛出的异常称为“被屏蔽”的异常（Suppressed Exception）。</p>
</blockquote>
<p><strong>如何获取所有的异常信息</strong></p>
<p>方法：先保存原始异常实例，然后调用 <code>Throwable.addSuppressed()</code>，把原始异常添加进来，最后在 <code>finally </code> 抛出。</p>
<p>为什么要在 finally 中抛出？</p>
<p>因为 catch 抛出一条异常就结束了，只能存好这一条异常，留在 finally 中添加了</p>
<h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>在项目开发中，为了方便处理不同业务的异常，会自定义异常，以便能精准的捕获。</p>
<p>自定义异常通常继承 <code>RuntimeException</code>。</p>
<p>这一类异常是 JVM 非强制捕获的异常，具有更好的扩展性，并且能自由的空值。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaseException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BaseException</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BaseException</span><span class="params">(String message, Throwable cause)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message, cause);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BaseException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BaseException</span><span class="params">(Throwable cause)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基本都是原样照抄<code>RuntimeException</code>。这样，抛出异常的时候，就可以选择合适的构造方法。通过IDE可以根据父类快速生成子类的构造方法。</p>
<p>真正的目的是区分不同的异常类。</p>
<h3 id="NPE异常"><a href="#NPE异常" class="headerlink" title="NPE异常"></a>NPE异常</h3><p>NPE 即 <code>NullPointerException</code> 空指针异常。</p>
<p>避免NPE的好习惯</p>
<ol>
<li><p>成员变量在定义时就初始化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>返回空字符串<code>&quot;&quot;</code>、空数组而不是<code>null</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] readLinesFromFile(String file) &#123;</span><br><span class="line">    <span class="keyword">if</span> (getFileSize(file) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 返回空数组而不是null:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Java 8</strong> 后，提供了 <code>Optional&lt;T&gt;</code> 工具类用于判断</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Optional&lt;String&gt; <span class="title function_">readFromFile</span><span class="params">(String file)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!fileExist(file)) &#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.empty();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过调用 Optional.isPresent() 可以判断结果</p>
</li>
</ol>
<p><strong>定位 NPE</strong></p>
<p>在执行类似如下代码时，Java 默认是不会指出哪个对象是null，只会暴露出目标文件所在行数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.b.c.x()</span><br></pre></td></tr></table></figure>

<p>Java 14 以后，只要开启如下 JVM 参数就可以检测出具体的 null 对象。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+ShowCodeDetailsInExceptionMessages Main.java</span><br></pre></td></tr></table></figure>

<p>本质猜测：开启后，每一步对象的嵌套调用都会被记录，当出现错误的时候就显示当前层级，可能会降低性能。</p>
<h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><p>使用 <code>assert</code> 关键字来实现断言。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> x &gt;= <span class="number">0</span> : <span class="string">&quot;x must &gt;= 0&quot;</span>;</span><br></pre></td></tr></table></figure>

<p><code>:</code> 冒号后添加可选的断言消息。</p>
<p>如果断言判断失败，会抛出 <code>AssertionError</code> 异常结束程序，并带上断言消息。</p>
<p>断言常用于测试，只要错误就代表测试失败。</p>
<p>JVM 默认关闭断言指令，即遇到<code>assert</code>语句就自动忽略了，不执行。</p>
<p>需要开启 <code>-enableassertions</code> （可简写为<code>-ea</code>）参数启用断言。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java -ea Main.java</span><br><span class="line">Exception <span class="keyword">in</span> thread <span class="string">&quot;main&quot;</span> java.lang.AssertionError</span><br><span class="line">	at Main.main(Main.java:5)</span><br></pre></td></tr></table></figure>

<p>还可以对特定的类启用断言<code> -ea:com.itranswarp.sample.Main</code></p>
<p>或者特定的包 <code>-ea:com.itranswarp.sample...</code>，用结尾的 … 表示这是一个包。</p>
<h3 id="日志输出"><a href="#日志输出" class="headerlink" title="日志输出"></a>日志输出</h3><p>对比 <code>System.out.println()</code> 有如下好处：</p>
<ol>
<li>可以设置输出样式，避免自己每次都写<code>&quot;ERROR: &quot; + var</code>；</li>
<li>可以设置输出级别，禁止某些级别输出。例如，只输出错误日志；</li>
<li>可以被重定向到文件，这样可以在程序运行结束后查看日志；</li>
<li>可以按包名控制日志级别，只输出某些包打的日志；</li>
<li>可以…… 等等</li>
</ol>
<p>Java 内置了 <code>java.util.logging</code>，可以直接使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.logging.Level;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.Logger;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> Logger.getGlobal();</span><br><span class="line">        logger.info(<span class="string">&quot;start process...&quot;</span>);</span><br><span class="line">        logger.warning(<span class="string">&quot;memory is running out...&quot;</span>);</span><br><span class="line">        logger.fine(<span class="string">&quot;ignored.&quot;</span>);</span><br><span class="line">        logger.severe(<span class="string">&quot;process will be terminated...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Mar 02, 2019 6:32:13 PM Hello main</span><br><span class="line">INFO: start process...</span><br><span class="line">Mar 02, 2019 6:32:13 PM Hello main</span><br><span class="line">WARNING: memory is running out...</span><br><span class="line">Mar 02, 2019 6:32:13 PM Hello main</span><br><span class="line">SEVERE: process will be terminated...</span><br></pre></td></tr></table></figure>

<p>可以看出 fine 的日志没有打印出来。</p>
<p>默认日志级别是 INFO，该级别以下的日志不会被打印出来。</p>
<p>JDK 的 Logging 定义了7个日志级别，从严重到普通：</p>
<ul>
<li>SEVERE</li>
<li>WARNING</li>
<li>INFO</li>
<li>CONFIG</li>
<li>FINE</li>
<li>FINER</li>
<li>FINEST</li>
</ul>
<p><strong>局限</strong></p>
<p>Logging 系统在 JVM 启动时读取配置文件并完成初始化，一旦开始运行<code>main()</code>方法，就无法修改配置；</p>
<p>配置不方便，需要在JVM启动时传递参数<code>-Djava.util.logging.config.file=&lt;config-file-name&gt;</code>。</p>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><blockquote>
<p>File类，与输入输出流都存放在Java.io包内。</p>
</blockquote>
<p>&#x3D;&#x3D;所有的输入输出类，都必须被异常处理包裹，捕捉FileNotFoundException&#x3D;&#x3D;</p>
<h5 id="1-File类"><a href="#1-File类" class="headerlink" title="1. File类"></a>1. File类</h5><p>File对象主要用来获取文件本身的一些信息，不涉及对文件的读写操作。</p>
<p><strong>构造函数</strong></p>
<ul>
<li>File(String filename);</li>
<li>File(String directoryPath,String filename);</li>
<li>File(File f，String filename);</li>
</ul>
<p>&#x3D;&#x3D;即使文件不存在，也不会报出异常&#x3D;&#x3D;</p>
<p><strong>常用方法</strong></p>
<ul>
<li>public String getName() 获取文件的名字。</li>
<li>public boolean canRead() 判断文件是否是可读的。</li>
<li>public boolean canWrite() 判断文件是否可被写入。</li>
<li>public boolean exits() 判断文件是否存在。</li>
<li>public <strong>long</strong> length() 获取文件的长度（单位是字节）。</li>
</ul>
<p>即长度为该文件内容为多少个字节，返回类型是long。</p>
<p>假如文件内容为：我是who12(整型)1000（long类型），那么读取到的length为4+3+4+8 &#x3D; 19个字节。</p>
<ul>
<li>public String getAbsolutePath() 获取文件的绝对路径。</li>
<li>public boolean isFile() 判断文件是否是一个普通文件，而不是目录。</li>
<li>public boolean isDirectroy() 判断文件是否是一个目录。</li>
</ul>
<h5 id="2-输入输出流"><a href="#2-输入输出流" class="headerlink" title="2. 输入输出流"></a>2. 输入输出流</h5><ul>
<li>FileInputStream</li>
</ul>
<p>以字节的形式读取文件</p>
<p>FileInputStream(String name);<br>FileInputStream(File file);<br>int read() 读取单个字节的数据<br>int read(byte b[]) 读取到字节数组b中，返回读取的实际字节长度，如果到达文件末尾则返回-1。<br>int read(byte b[]，int off，int len) 读取文件内容从off位置len个字节到字节数组b中</p>
<ul>
<li>FileOutputStream</li>
</ul>
<p>以字节的形式写入文件</p>
<p><strong>区别</strong> void write(byte b[],int off,int len) 从字节数组中偏移量off处取len个字节写到目的地。</p>
<ul>
<li>FileReader</li>
</ul>
<p>以字符的形式读取文件</p>
<p>nt read() 读取单个字符的数据<br>int read(char b[]) 读取到字符数组b中<br>int read(char b[]，int off，int len) 读取从off位置len个字符到字符数组b中</p>
<ul>
<li>FileWriter</li>
</ul>
<p>以字符的形式写入文件</p>
<p>使用方法类比即可</p>
<h5 id="3-缓冲流"><a href="#3-缓冲流" class="headerlink" title="3. 缓冲流"></a>3. 缓冲流</h5><p>缓冲流只能指向FileWriter或FileReader类对象，相较于提供了更多输入输出的方法，可以提高大文件（数据）的读写速度。</p>
<ul>
<li>BufferedReader，BufferedWriter</li>
</ul>
<p>readLine() 读取文本行<br>write(String s,int off,int len) 把字符串s写到文件中<br>newLine(); 向文件写入一个回行符</p>
<h5 id="4-随机访问文件流"><a href="#4-随机访问文件流" class="headerlink" title="4. 随机访问文件流"></a>4. 随机访问文件流</h5><p>RandomAccessFile类可以同时实现输入和输出操作。</p>
<p>构造函数：</p>
<p>RandomAccessFile(String name,String mode) ;<br>RandomAccessFile(File file,String mode) ;</p>
<p>mode指对文件的操作方式，如：r 表示只读，rw表示读和写，w表示写入。</p>
<p>使用方法：</p>
<p>read();</p>
<p>writeInt(); writeLong();</p>
<p>seek(long a)  定位RandomAccessFile流的读写位置<br>getFilePointer() 获取流的当前读写位置</p>
<p><strong>还有对象流（用来输入输出对象）等一些乱七八糟的</strong></p>
<h2 id="日期与时间"><a href="#日期与时间" class="headerlink" title="日期与时间"></a>日期与时间</h2><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><h2 id="加密与安全"><a href="#加密与安全" class="headerlink" title="加密与安全"></a>加密与安全</h2><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>多线程可以让程序同时执行多个任务。</p>
<p>但它的本质是<strong>多个任务轮流进行</strong>，比如让浏览器执行0.001秒，让QQ执行0.001秒，再让音乐播放器执行0.001秒，在人看来，CPU就是在同时执行多个任务。</p>
<p>即使是多核CPU，因为任务的数量往往多于CPU的核数，所以任务也是交替进行的。 </p>
<p><strong>为什么多线程操作在程序中往往比单线程快？</strong></p>
<p>以MySQL插入数据为例</p>
<p>因为MySQL内部将调度任务分为了多个线程，如果插入操作是单线程的，就无法占满所有的线程。</p>
<p>相当于给你10个工人，你却只用了一个工人。</p>
<blockquote>
<p>为什么MySQL内部需要多线程？</p>
<p>可能是因为有一些操作需要同时进行，如守护线程 :question:</p>
</blockquote>
<p>总之：在应用多线程中间件（到达目的地的管道）时，同时使用多线程操作才会比单线程快。</p>
<h3 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a><strong>进程与线程</strong></h3><p><img src="/../assets/image-20240409104301471.png" alt="image-20240409104301471"></p>
<p>在计算机中，<strong>一个任务整体称为一个进程</strong>。</p>
<p>例如，浏览器就是一个进程，视频播放器是另一个进程，类似的，音乐播放器和Word都是进程。</p>
<p>一个任务整体（进程）里可以包含多个子任务（线程）。</p>
<p>例如，浏览器可以打开多个窗口，同时查看不同网站的内容，此时浏览器进程程执行了多个显示窗口的线程。</p>
<p><strong>进程与线程的关系</strong>：一个进程可以包含一个或多个线程，但<strong>至少</strong>会有一个线程。</p>
<blockquote>
<p><strong>操作系统调度的最小任务单位其实不是进程，而是线程。</strong></p>
</blockquote>
<p><strong>多进程和多线程对比</strong>：</p>
<p>多进程的缺点：</p>
<ol>
<li><p>开销大，创建进程开销大，尤其是在Windows系统上；</p>
</li>
<li><p>通信慢，进程间通信 比 线程间通信要慢，因为线程间通信就是读写同一个变量，速度很快。</p>
</li>
</ol>
<p>多进程的优点：</p>
<ol>
<li><p>稳定性高，多进程稳定性比多线程高，</p>
<p>因为在多进程的情况下，一个进Java程崩溃不会影响其他进程，而在多线程的情况下，任何一个线程崩溃会直接导致整个进程崩溃。</p>
</li>
</ol>
<h3 id="JVM-多线程"><a href="#JVM-多线程" class="headerlink" title="JVM 多线程"></a>JVM 多线程</h3><p>Java 语言内置了多线程支持，一个Java程序实际上是一个JVM进程。</p>
<p>JVM进程用一个主线程来执行<code>main()</code>方法，在<code>main()</code>方法内部也可以启动多个子线程。</p>
<p>此外，JVM还有负责垃圾回收的其他工作线程等。</p>
<p>和单线程相比，<strong>多线程编程的特点</strong>在于：多线程经常需要读写共享数据，并且需要同步。</p>
<h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><p><strong>创建步骤：</strong></p>
<ol>
<li>实例化一个Thread类对象，重写 run() 方法。</li>
<li>再调用Thread对象的start()方法，开启一个新线程。</li>
<li>线程启动后，会自动调用Thread对象的 run() 方法。</li>
</ol>
<p>在这种创建方法中，run方法体的内容就代表这该线程需要执行的任务。</p>
<p><strong>重写 run 的几种方法：</strong></p>
<ol>
<li>继承<code>Thread</code>类，重写<code>run()</code>方法：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start new thread!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>创建<code>Thread</code>实例时，传入一个<code>Runnable</code>实例：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">        t.start(); <span class="comment">// 启动新线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start new thread!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>或者直接传入Runable接口匿名类</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>也可以使用 Java 8 后的 lambda 表达式</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>又或者使用T创建 Thread 匿名类，重写run方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：</p>
<ul>
<li><p>在通过start()方法启动新线程后，该线程不一定立即执行。</p>
</li>
<li><p>直接调用线程的run()方法，无法启动新线程，只是执行一个普通方法而已。</p>
<p>线程的开启由 start() 方法代理，执行 run() 方法内容。</p>
</li>
</ul>
<p><strong>线程休眠</strong></p>
<p>通过调用 <code>Thread.sleep(milliseconds)</code> 静态方法，可以使线程休眠 x 毫秒</p>
<p>线程休眠方法会抛出 <code>InterruptedException</code> checked异常，必须显式捕获异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>设置线程的优先级</strong></p>
<p>可以在线程内部调用 <code>Thread.setPriority(n)</code>设置线程的优先级（1 - 10），默认值是5。</p>
<p>优先级高的线程被操作系统调度的优先级较高。</p>
<p>操作系统对高优先级线程可能调度更频繁，<strong>但无法确保高优先级的线程一定会先执行。</strong></p>
<h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><p>一个新的线程开启后，只会执行一次 run 方法，执行完毕代表该线程结束。</p>
<p>线程的状态有以下几种：</p>
<ul>
<li>New：新创建的线程，尚未执行；</li>
<li>Runnable：运行中的线程，正在执行<code>run()</code>方法的Java代码；</li>
<li>Blocked：运行中的线程，因为某些操作被阻塞而挂起；</li>
<li>Waiting：运行中的线程，因为某些操作在等待中；</li>
<li>Timed Waiting：运行中的线程，因为执行<code>sleep()</code>方法正在计时等待；</li>
<li>Terminated：线程已终止，因为<code>run()</code>方法执行完毕。</li>
</ul>
<p><img src="/../assets/image-20240409113233199.png" alt="image-20240409113233199"></p>
<p>当线程启动后，它可以在<code>Runnable</code>、<code>Blocked</code>、<code>Waiting</code>和<code>Timed Waiting</code>这几个状态之间切换，直到最后变成<code>Terminated</code>状态，线程终止。</p>
<p><strong>线程终止的原因</strong>有：</p>
<ul>
<li>线程正常终止：<code>run()</code>方法执行到<code>return</code>语句返回；</li>
<li>线程意外终止：<code>run()</code>方法因为未捕获的异常导致线程终止；</li>
<li>对某个线程的<code>Thread</code>实例调用<code>stop()</code>方法强制终止（强烈不推荐使用）。</li>
</ul>
<h3 id="等待线程"><a href="#等待线程" class="headerlink" title="等待线程"></a><strong>等待线程</strong></h3><p>一个线程还可以等待另一个线程直到其运行结束。</p>
<p>例如，<code>main</code>线程在启动<code>t</code>线程后，可以通过<code>t.join()</code>等待<code>t</code>线程结束后再继续运行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;start&quot;</span>);</span><br><span class="line">        t.start();</span><br><span class="line">        t.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>join</code> <strong>含义理解</strong>：</p>
<p>t 线程加入 main 线程任务中，作为任务执行的一个步骤，只有等 t 执行完毕，main 线程任务的步骤才可以继续往下执行。</p>
<p>&#x3D;&#x3D;改正：不是等 t 执行完毕，而是等该线程调度结束，例如，死循环线程不会一直执行。&#x3D;&#x3D;</p>
<p>如果<code>t</code>线程已经结束，对实例<code>t</code>调用<code>join()</code>会立刻返回。</p>
<p>此外，<code>join(long)</code>的重载方法也可以指定一个等待时间，超过等待时间后就不再继续等待（就不要它加入了嘿嘿）。</p>
<h3 id="中断线程"><a href="#中断线程" class="headerlink" title="中断线程"></a>中断线程</h3><p>如果线程需要执行一个 <strong>长时间任务</strong>，就可能需要能<strong>控制的</strong>中断线程，确保这个任务是可控的。</p>
<p>中断线程有三种方法：</p>
<ol>
<li><strong>调用线程对象的<code>interrupt()</code>方法</strong></li>
</ol>
<p>通过调用interrupt方法，给线程传递一个中断的信号。</p>
<p><strong>目标线程需要通过调用继承 Thread 的 <code>isInterrupted()</code> 方法，反复检测自身状态是否是 interrupted 状态。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        t.start();</span><br><span class="line">        Thread.sleep(<span class="number">1</span>); 	<span class="comment">// 暂停 Main 线程1毫秒，确保线程 t 运行一次再结束。</span></span><br><span class="line">        t.interrupt(); 		<span class="comment">// 中断 t 线程</span></span><br><span class="line">        t.join(); 			<span class="comment">// 将 t 线程加入到 main 线程中，确保 “end” 最后输出</span></span><br><span class="line">        System.out.println(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 检测中断信号</span></span><br><span class="line">        <span class="keyword">while</span> (! isInterrupted()) &#123;</span><br><span class="line">            n ++;</span><br><span class="line">            System.out.println(n + <span class="string">&quot; hello!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong>首先开启了一个新的线程 t，该线程监听中断信号不断循环输出 hello（模拟长时间任务），然后 main 线程发出中断信号，同时 t 线程中的循环监听到了中断信号，随后停止运行，重新回到 main 线程继续执行，最后输出 “end”。</p>
<p><strong>注意：</strong>如果线程内没有检测中断信号，只是调用 <code>interrupt()</code> 方法线程是不会中断的。</p>
<p><strong>应用场景：</strong></p>
<p>首先需要注意的是，通过 interrupt 方法中断线程的前提，是目标线程必须时刻监听中断信号。</p>
<p>因此，目标线程应该将<strong>长时间任务转化为分片的任务</strong>，循环进行，同时监听中断信号。</p>
<ol start="2">
<li><strong>监听目标线程内其他线程的 join 方法。</strong></li>
</ol>
<p>假设有两个线程 A，B。</p>
<p>A 线程中对 B 线程调用了 join() 方法，而此时 A 线程又收到了 interrupt 信号</p>
<p>那么 join 方法就会抛出一个 <code>InterruptedException</code> 异常，A 线程就会结束运行。</p>
<p><strong>结束点</strong>：目标线程内部其他线程的 join 时刻</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        <span class="comment">// 开启线程 A</span></span><br><span class="line">        a.start();</span><br><span class="line">        a.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        <span class="comment">// 开启线程 B</span></span><br><span class="line">        b.start();</span><br><span class="line">        <span class="comment">// 捕获异常，但不做处理</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            b.join();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;&#125;</span><br><span class="line">        <span class="comment">// 中断线程 B</span></span><br><span class="line">        b.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(!isInterrupted())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;run&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">break</span>;	<span class="comment">// 如果不加break，概率导致死循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>为什么线程 B 监听了中断信号，在捕获异常时还需要 break？</strong></p>
<p>因为在对 B 线程调用 interrupt 方法时，如果线程 B 本身就在 waiting，sleeping 状态时，内部的 sleep 方法会抛出 InterrputedException 异常，并重置中断状态（isInterrupted&#x3D;false），所以要在捕获到异常时break。</p>
<p>:question: 上方答案存疑</p>
<ol start="3">
<li><strong>定义标志变量结束线程</strong></li>
</ol>
<p>例如，定义一个变量 running，然后在目标线程中监听其值来决定是否结束线程（类似 Thread 自身维护的 isInterrupt）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">HelloThread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloThread</span>();</span><br><span class="line">        t.start();</span><br><span class="line">        Thread.sleep(<span class="number">1</span>);</span><br><span class="line">        t.running = <span class="literal">false</span>; <span class="comment">// 将标志变量设置为false，结束线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HelloThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">running</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (running) &#123;</span><br><span class="line">            n ++;</span><br><span class="line">            System.out.println(n + <span class="string">&quot; hello!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;end!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>running 在此处代码中，同时作为了 main 和 t 线程之间共享的变量。</p>
<p><strong>变量的更新机制</strong></p>
<p>在Java虚拟机中，变量是保存在主内存的。</p>
<p>每个线程<strong>访问</strong>变量时，会先生成一个副本保存在自己的工作内存中。</p>
<p>如果线程<strong>修改</strong>了变量的值，虚拟机会在不确定的时刻再把修改后的值写回到主内存，存在线程之间变量不一致的问题！</p>
<p>例如，running &#x3D; false，然后 main 修改其为 true，但是没有写到主内存，那么此时线程 A 访问 running 仍会的到 true，而不会立刻结束线程，只有在回写到主内存后才会结束线程。</p>
<p>而 <code>volatile</code> 关键字的目的是告诉虚拟机：</p>
<ul>
<li>每次访问变量时，总是获取主内存的最新值；</li>
<li>每次修改变量后，立刻回写到主内存。</li>
</ul>
<p>这样就可以确保线程之间变量的一致性。</p>
<h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p>有一种线程的目的就是无限循环，无法设定结束条件。</p>
<p>例如，一个定时任务的线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TimerThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(LocalTime.now());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>已知 JVM 需要所有线程都运行结束后，才会退出。</strong> </p>
<p>如果存在这样一个无限执行的线程，且与任务无关，但是又需要在所有任务结束后，关闭 JVM 终止程序，该如何操作呢。</p>
<p>答案：守护线程。</p>
<p><strong>守护线程是指为其他线程服务的线程。</strong></p>
<p><strong>JVM 关闭时无需关心守护线程是否结束，只要其他线程结束就终止程序，同时顺带关闭守护线程</strong>。</p>
<p>创建守护线程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">t.setDaemon(<span class="literal">true</span>);</span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure>

<p>目标线程通过调用 setDeamon(true)；来将本线程设为守护线程。</p>
<p><strong>注意：</strong>守护线程不应该持有任何需要手动关闭的资源，如打开文件。因为该线程何时关闭是不确定的，无法释放资源。</p>
<h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><p><strong>同步：</strong>指两个变量始终保持一定的相对关系，可以是同时，也可以是完成同一个操作一前一后（你先做，再到我做）。</p>
<p>从 volatile 那一节中知道，如果多个线程同时读写共享的变量，会出现数据不一致的问题。</p>
<p>假设有两个加法线程，同时操作同一个变量，都执行加法操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n = n + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>这一行语句被 JVM 解析成 3 条指令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ILOAD</span><br><span class="line">IADD</span><br><span class="line">ISTORE</span><br></pre></td></tr></table></figure>

<p><img src="/../assets/image-20240410233303176.png" alt="image-20240410233303176"></p>
<p>如果线程 1 在LOAD后就被中断，转而执行线程 2，此时 n 还是 100，就会出现两个线程同时写入 101 给 n，而不是正常的 102。</p>
<p><strong>如何让线程 2 每次都基于线程 1 的结果继续运算呢？</strong></p>
<p>只需要保证当一个线程进行 LOAD, ADD, STORE 操作时，其他线程必须等待这一个线程执行完之后再依次执行，确保操作的<strong>原子性</strong>。</p>
<p>这样的操作被称为<strong>原子操作</strong></p>
<p><img src="/../assets/image-20240410233957456.png" alt="image-20240410233957456"></p>
<p>这样的操作称为加锁，解锁。</p>
<p>通过加锁和解锁的操作，就能保证3条指令执行期间只有一个线程，不会有其他线程会进入此指令区间。</p>
<p>只有在执行线程解锁，将锁释放后，其他线程才能获得锁并执行这 3 条指令。</p>
<h4 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a><strong>synchronized</strong></h4><p>Java 使用 <code>synchronized</code> 关键字对一个对象进行加锁，保证了代码块在任意时刻最多只有一个线程能执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">add</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AddThread</span>();</span><br><span class="line">        <span class="type">var</span> <span class="variable">dec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DecThread</span>();</span><br><span class="line">        add.start();</span><br><span class="line">        dec.start();</span><br><span class="line">        add.join();</span><br><span class="line">        dec.join();</span><br><span class="line">        System.out.println(Counter.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Counter.lock) &#123;</span><br><span class="line">                Counter.count += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DecThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Counter.lock) &#123;</span><br><span class="line">                Counter.count -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里以 lock 作为锁，每个线程执行加减操作时需要先获取锁，如果这把锁被其他线程占用了，就需要等待锁被释放后，重新获取锁才能执行。</p>
<h4 id="保持线程之间同步的步骤："><a href="#保持线程之间同步的步骤：" class="headerlink" title="保持线程之间同步的步骤："></a><strong>保持线程之间同步的步骤：</strong></h4><ol>
<li>划出需要同步的代码块；</li>
<li>选择同一个对象作为锁；</li>
<li>使用 <code>synchronized(lockObject) &#123; ... &#125;</code> 包裹代码块。</li>
</ol>
<p><strong>注意</strong>：</p>
<ul>
<li>锁的对象必须是同一个，如果不同就会有两把锁，出现两个线程异步执行的情况。</li>
<li>获取锁和释放锁需要消耗一定的时间，所以，<code>synchronized</code>会降低程序的执行效率、性能。</li>
<li>不用担心同步过程中会抛出异常，锁会被正确释放。</li>
</ul>
<h4 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a><strong>原子操作</strong></h4><p>具有原子性的操作被称为原子操作。原子：不可以再被分解的物质。</p>
<p><strong>原子操作是指不能被中断的一个或一系列操作。</strong></p>
<p>对于原子操作不需要使用锁，因为每一个原子操作，都是在“一下”完成的，不被其他线程打断。</p>
<p>JVM规范定义了几种原子操作：</p>
<ul>
<li>基本类型（<code>long</code>和<code>double</code>除外，没有明确规定）赋值，例如：<code>int n = m</code>；</li>
<li>引用类型赋值，例如：<code>List&lt;String&gt; list = anotherList</code>。</li>
</ul>
<p>但如果是多行赋值操作，就需要给操作加锁（对象本身）了。</p>
<p>锁的对象随实际需要改变，这里假设多个线程用到了同一个 Pair 实例对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> x，<span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.x = x;</span><br><span class="line">            <span class="built_in">this</span>.y = y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 同时，读的操作也许加锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] get() &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="type">int</span>[] copy = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">            copy[<span class="number">0</span>] = x;</span><br><span class="line">            copy[<span class="number">1</span>] = y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果“写”操作不加锁，就会出现当 A 线程给 pair 对象的 x 赋值时，被 B 线程打断并重新把 x 赋值为另一个值，这时候 A 线程的逻辑就会不严谨。</p>
<p> 假设当前坐标是<code>(100, 200)</code>。</p>
<p>那么当设置新坐标为<code>(110, 220)</code>时，如果“读”操作不加锁，读到的值可能有：</p>
<ul>
<li>(100, 200)：x，y更新前；</li>
<li>(110, 200)：x更新后，y更新前就调用了 pair 的 get 方法；</li>
<li>(110, 220)：x，y更新后。</li>
</ul>
<p>加锁可以保证读的值不被污染，并且是最新。</p>
<p><strong>有时也可以巧妙的将非原子操作转换为原子操作</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] pair;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> x，<span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="comment">// 局部变量不需要同步</span></span><br><span class="line">        <span class="type">int</span>[] ps = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; x，y &#125;; </span><br><span class="line">        <span class="built_in">this</span>.pair = ps;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] get() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;x, y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 ps 是局部变量，不被其他线程可见，不存在被其他线程中途修改的问题。</p>
<p><strong>每个线程都会有各自的局部变量，互不影响，并且互不可见，并不需要同步。</strong></p>
<p>将多行赋值改为引用赋值，确保操作被“一次”执行，保证原子性。</p>
<p>同理这里的读操作也转为了原子操作，x,y 每次都同步读取，不存在读了线程 A 设置的 x 后，y 又变成了线程 B 设置的。</p>
<p>缺点就是无法保证每次都是最新的状态，可以再添加 <code>volatile</code> 关键字，确保实时性。</p>
<p>看到这里应该就明白 <code>volatile</code> 和 <code>synchronized</code> 之间的区别的吧。</p>
<p>区别：</p>
<ol>
<li>volatile 只用于保证状态更新后能被实时写入主内存，保证状态的实时性。</li>
<li>synchronized 则用于保证一连串操作同时只有一个线程在执行。</li>
</ol>
<p>如果用 volatile 来限制 n &#x3D; n + 1，只能确保每个线程更新后能立马写回主内存，但无法确保每个线程用来更新的值是其他线程执行完之后的值，还是操作了同一个值。</p>
<p>总之，volatile 只注重变量被赋值后“真正”更新的实时性。</p>
<h4 id="不可变对象无需同步"><a href="#不可变对象无需同步" class="headerlink" title="不可变对象无需同步"></a>不可变对象无需同步</h4><p>如果多线程读写的是一个不可变对象（如String，List），那么无需同步。</p>
<p>因为不会修改这个对象的状态，而是修改对象本身。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Data &#123;</span><br><span class="line">    List&lt;String&gt; names;</span><br><span class="line">    void set(String[] names) &#123;</span><br><span class="line">        this.names = List.of(names);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;String&gt; get() &#123;</span><br><span class="line">        return this.names;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到<code>set()</code>方法内部创建了一个不可变<code>List</code>，这个<code>List</code>包含的对象也是不可变对象<code>String</code>，因此，整个<code>List&lt;String&gt;</code>对象都是不可变的，因此读写均无需同步。</p>
<p>对于读写的操作的同步问题</p>
<p>其实只需要多加思考如何保证写的操作是“阶段性”的，那么读就很容易保持阶段性（同步）。</p>
<h4 id="总结多线程"><a href="#总结多线程" class="headerlink" title="总结多线程"></a><strong>总结多线程</strong></h4><p>深入理解多线程还需理解变量在栈上的存储方式，基本类型和引用类型的存储方式也不同。</p>
<p>什么时候需要考虑多线程问题？</p>
<ol>
<li>并发高的场景</li>
<li>修改线程共享变量（对象变量等）的时候</li>
</ol>
<h3 id="synchronized-方法"><a href="#synchronized-方法" class="headerlink" title="synchronized 方法"></a>synchronized 方法</h3><p>在业务逻辑中，如果自由的自定义 <code>synchronized</code> 代码块，会显得代码逻辑混乱。</p>
<p>因此，常常将同步的行为整体封装为一个类，如计数器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">            count += n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dec</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">            count -= n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该计数器的加减操作以自身 this 实例为锁，支持同时创建多个实例，每个实例内部维护各自的 COUNT 不因为线程而错乱。</p>
<p>如果一个类被设计为允许 多线程 正确访问，我们就说这个类是<strong>线程安全</strong>的。</p>
<p>还有一些不变类，例如<code>String</code>，<code>Integer</code>，<code>LocalDate</code>，它们的所有成员变量都是<code>final</code>，多线程同时访问时只能读不能写，这些不变类也是线程安全的。</p>
<p>最后，类似<code>Math</code>这些只提供静态方法，没有成员变量的类，也是线程安全的。</p>
<p>事实上大部分情况下，大部分类，例如<code>ArrayList</code>，都是非线程安全的类，我们不能在多线程中安全的使用它们。</p>
<p><strong>即使是上升为 List 引用，也是线程非安全的，因为内部的作用域还是 ArrayList 本身</strong></p>
<blockquote>
<p>只能访问，不能插入和修改元素，因为 length 和 元素内存值 会不一致。</p>
</blockquote>
<p>&#x3D;&#x3D;没有特殊说明时，一个类默认是非线程安全的。&#x3D;&#x3D;</p>
<blockquote>
<p>因为内置线程安全会影响性能，应交由开发者自由控制。</p>
</blockquote>
<p><strong>synchronized 方法修饰符</strong></p>
<p>当锁的对象是 this 实例时，以下两种写法等价。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123; <span class="comment">// 锁住this</span></span><br><span class="line">        count += n;</span><br><span class="line">    &#125; <span class="comment">// 解锁</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> n)</span> &#123; <span class="comment">// 锁住this</span></span><br><span class="line">    count += n;</span><br><span class="line">&#125; <span class="comment">// 解锁</span></span><br></pre></td></tr></table></figure>

<p><strong>static 方法加锁</strong></p>
<p>由于 static 方法没有 this 实例，因此其锁住的是一个类的 Class 实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(Counter.class) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><h2 id="易混概念"><a href="#易混概念" class="headerlink" title="易混概念"></a>易混概念</h2><ol>
<li>主类: 所有定义了main方法的类叫做主类，开发者常在类中定义main方法，用来调试代码</li>
<li>在基本数据类型变量声明时，不能用占用内存大的值赋给占用内存小的变量类型，如 float a &#x3D; 1.19; 1.19 默认是double型，因此该语句会编译出错; &#x3D;&#x3D;2e9&#x3D;&#x3D;科学计数，默认也是double型!!!</li>
<li>使用…声明可变长参数，如int sort(int… a);</li>
<li>命令行参数</li>
</ol>
<blockquote>
<p>各个类的main方法可以相互调用</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(String str: args) &#123;</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] strs = &#123;<span class="string">&quot;hello&quot;</span>，<span class="string">&quot;world&quot;</span>&#125;;</span><br><span class="line">        B.main(strs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>重载是&#x3D;&#x3D;多态&#x3D;&#x3D;的一种。</li>
<li>不管是继承还是实现接口，重写方法时都不可以降低方法的可见性（Visiability）</li>
</ol>
<blockquote>
<p>如：继承的public方法不能重写为protected方法，但是protected方法重写后可改为public。</p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://github.com/blueapong">Apong</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blueapong.github.io/2024/04/03/Java-Common/">https://blueapong.github.io/2024/04/03/Java-Common/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blueapong.github.io" target="_blank">Apong's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post_share"><div class="social-share" data-image="/config/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/04/07/240407/" title="Redis的Stream消息队列应用"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Redis的Stream消息队列应用</div></div></a></div><div class="next-post pull-right"><a href="/2024/03/29/240329/" title="Redisson分布式锁、联锁"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Redisson分布式锁、联锁</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/config/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Apong</div><div class="author-info__description">Think less useless, Do more!</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">8</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/blueapong"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">1.1.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JRE-%E5%92%8C-JDK-%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.2.</span> <span class="toc-text">JRE 和 JDK 介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8D%E8%AF%8D%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.3.</span> <span class="toc-text">名词介绍</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E8%A7%84%E5%88%99"><span class="toc-number">2.</span> <span class="toc-text">语法规则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99"><span class="toc-number">2.1.</span> <span class="toc-text">命名规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hello-world%E5%88%86%E6%9E%90"><span class="toc-number">2.2.</span> <span class="toc-text">Hello world分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E7%B1%BB"><span class="toc-number">2.3.</span> <span class="toc-text">主类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E7%BC%96%E8%AF%91"><span class="toc-number">2.4.</span> <span class="toc-text">反编译</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A"><span class="toc-number">2.5.</span> <span class="toc-text">注释</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.</span> <span class="toc-text">数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%AE%97"><span class="toc-number">4.</span> <span class="toc-text">运算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">4.1.</span> <span class="toc-text">运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E8%BF%90%E7%AE%97"><span class="toc-number">4.2.</span> <span class="toc-text">整数运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E8%BF%90%E7%AE%97"><span class="toc-number">4.3.</span> <span class="toc-text">浮点数运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%83%E5%B0%94%E8%BF%90%E7%AE%97"><span class="toc-number">4.4.</span> <span class="toc-text">布尔运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%B2%BE%E5%BA%A6"><span class="toc-number">4.5.</span> <span class="toc-text">运算精度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6"><span class="toc-number">5.</span> <span class="toc-text">字符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">6.</span> <span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6"><span class="toc-number">6.1.</span> <span class="toc-text">转义字符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%89%B9%E6%80%A7"><span class="toc-number">6.2.</span> <span class="toc-text">不可变特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD"><span class="toc-number">6.3.</span> <span class="toc-text">功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E5%BC%95%E7%94%A8%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">6.4.</span> <span class="toc-text">&#x3D;&#x3D; 在引用的使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">7.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">7.1.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-1"><span class="toc-number">7.2.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">7.3.</span> <span class="toc-text">多维数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="toc-number">7.4.</span> <span class="toc-text">排序数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8"><span class="toc-number">7.5.</span> <span class="toc-text">应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0"><span class="toc-number">8.</span> <span class="toc-text">命令行参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">9.</span> <span class="toc-text">流程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5"><span class="toc-number">9.1.</span> <span class="toc-text">输入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA"><span class="toc-number">9.2.</span> <span class="toc-text">输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#if%E5%88%A4%E6%96%AD"><span class="toc-number">9.3.</span> <span class="toc-text">if判断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#switch%E6%96%B0%E7%94%A8%E6%B3%95"><span class="toc-number">9.4.</span> <span class="toc-text">switch新用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF"><span class="toc-number">9.5.</span> <span class="toc-text">循环</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#while"><span class="toc-number">9.5.1.</span> <span class="toc-text">while</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#do-while"><span class="toc-number">9.5.2.</span> <span class="toc-text">do while</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#for"><span class="toc-number">9.5.3.</span> <span class="toc-text">for</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#for-each"><span class="toc-number">9.5.4.</span> <span class="toc-text">for each</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#break-%E5%92%8C-continue"><span class="toc-number">9.5.5.</span> <span class="toc-text">break 和 continue</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">10.</span> <span class="toc-text">面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#0-%E7%89%B9%E7%82%B9"><span class="toc-number">10.0.0.1.</span> <span class="toc-text">0. 特点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%AD%97%E6%AE%B5"><span class="toc-number">10.0.0.2.</span> <span class="toc-text">1. 字段</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">10.0.0.2.1.</span> <span class="toc-text">静态方法</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">10.0.0.3.</span> <span class="toc-text">2. 构造函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-this%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">10.0.0.4.</span> <span class="toc-text">3. this关键字</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%8C%85"><span class="toc-number">10.0.0.5.</span> <span class="toc-text">4. 包</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">10.0.0.6.</span> <span class="toc-text">5. 修饰符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-number">10.0.0.7.</span> <span class="toc-text">6. 包装类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-%E4%B8%8A%E8%BD%AC%E5%9E%8B%E5%AF%B9%E8%B1%A1"><span class="toc-number">10.0.0.8.</span> <span class="toc-text">7. 上转型对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">10.0.0.9.</span> <span class="toc-text">8. 抽象类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-%E6%8E%A5%E5%8F%A3"><span class="toc-number">10.0.0.10.</span> <span class="toc-text">9. 接口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10-Lambada%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88JDK8%E5%90%8E%EF%BC%89"><span class="toc-number">10.0.0.11.</span> <span class="toc-text">10. Lambada表达式（JDK8后）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#11-%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">10.0.0.12.</span> <span class="toc-text">11. 内部类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#12-%E5%8C%BF%E5%90%8D%E7%B1%BB"><span class="toc-number">10.0.0.13.</span> <span class="toc-text">12. 匿名类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#13-%E5%BC%82%E5%B8%B8%E7%B1%BB"><span class="toc-number">10.0.0.14.</span> <span class="toc-text">13. 异常类</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%B1%BB"><span class="toc-number">11.</span> <span class="toc-text">核心类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-String%E7%B1%BB"><span class="toc-number">11.0.0.1.</span> <span class="toc-text">1. String类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">11.0.0.2.</span> <span class="toc-text">2. 正则表达式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-Class%E7%B1%BB%E4%B8%8E%E5%8F%8D%E5%B0%84"><span class="toc-number">11.0.0.3.</span> <span class="toc-text">3. Class类与反射</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">12.</span> <span class="toc-text">异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-1"><span class="toc-number">12.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8"><span class="toc-number">12.2.</span> <span class="toc-text">捕获异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8"><span class="toc-number">12.3.</span> <span class="toc-text">抛出异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E2%80%9C%E8%BD%AC%E6%8D%A2%E2%80%9D"><span class="toc-number">12.4.</span> <span class="toc-text">异常“转换”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%B1%8F%E8%94%BD"><span class="toc-number">12.5.</span> <span class="toc-text">异常屏蔽</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8"><span class="toc-number">12.6.</span> <span class="toc-text">自定义异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NPE%E5%BC%82%E5%B8%B8"><span class="toc-number">12.7.</span> <span class="toc-text">NPE异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%AD%E8%A8%80"><span class="toc-number">12.8.</span> <span class="toc-text">断言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BA"><span class="toc-number">12.9.</span> <span class="toc-text">日志输出</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-number">13.</span> <span class="toc-text">反射</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3"><span class="toc-number">14.</span> <span class="toc-text">注解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">15.</span> <span class="toc-text">泛型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88"><span class="toc-number">16.</span> <span class="toc-text">集合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO"><span class="toc-number">17.</span> <span class="toc-text">IO</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-File%E7%B1%BB"><span class="toc-number">17.0.0.1.</span> <span class="toc-text">1. File类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-number">17.0.0.2.</span> <span class="toc-text">2. 输入输出流</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E7%BC%93%E5%86%B2%E6%B5%81"><span class="toc-number">17.0.0.3.</span> <span class="toc-text">3. 缓冲流</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE%E6%96%87%E4%BB%B6%E6%B5%81"><span class="toc-number">17.0.0.4.</span> <span class="toc-text">4. 随机访问文件流</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F%E4%B8%8E%E6%97%B6%E9%97%B4"><span class="toc-number">18.</span> <span class="toc-text">日期与时间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">19.</span> <span class="toc-text">正则表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A0%E5%AF%86%E4%B8%8E%E5%AE%89%E5%85%A8"><span class="toc-number">20.</span> <span class="toc-text">加密与安全</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">21.</span> <span class="toc-text">多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="toc-number">21.1.</span> <span class="toc-text">进程与线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">21.2.</span> <span class="toc-text">JVM 多线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-number">21.3.</span> <span class="toc-text">创建线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">21.4.</span> <span class="toc-text">线程的状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%89%E5%BE%85%E7%BA%BF%E7%A8%8B"><span class="toc-number">21.5.</span> <span class="toc-text">等待线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B"><span class="toc-number">21.6.</span> <span class="toc-text">中断线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="toc-number">21.7.</span> <span class="toc-text">守护线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">21.8.</span> <span class="toc-text">线程同步</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#synchronized"><span class="toc-number">21.8.1.</span> <span class="toc-text">synchronized</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%9D%E6%8C%81%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%90%8C%E6%AD%A5%E7%9A%84%E6%AD%A5%E9%AA%A4%EF%BC%9A"><span class="toc-number">21.8.2.</span> <span class="toc-text">保持线程之间同步的步骤：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="toc-number">21.8.3.</span> <span class="toc-text">原子操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1%E6%97%A0%E9%9C%80%E5%90%8C%E6%AD%A5"><span class="toc-number">21.8.4.</span> <span class="toc-text">不可变对象无需同步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">21.8.5.</span> <span class="toc-text">总结多线程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized-%E6%96%B9%E6%B3%95"><span class="toc-number">21.9.</span> <span class="toc-text">synchronized 方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-number">22.</span> <span class="toc-text">网络编程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%93%E6%B7%B7%E6%A6%82%E5%BF%B5"><span class="toc-number">23.</span> <span class="toc-text">易混概念</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/04/11/240411/" title="无题">无题</a><time datetime="2024-04-11T02:23:16.000Z" title="发表于 2024-04-11 10:23:16">2024-04-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/04/07/240407/" title="Redis的Stream消息队列应用">Redis的Stream消息队列应用</a><time datetime="2024-04-07T08:55:47.000Z" title="发表于 2024-04-07 16:55:47">2024-04-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/04/03/Java-Common/" title="Java基础">Java基础</a><time datetime="2024-04-03T13:10:14.000Z" title="发表于 2024-04-03 21:10:14">2024-04-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/29/240329/" title="Redisson分布式锁、联锁">Redisson分布式锁、联锁</a><time datetime="2024-03-29T08:44:05.000Z" title="发表于 2024-03-29 16:44:05">2024-03-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/28/240328/" title="Linux，分布式锁">Linux，分布式锁</a><time datetime="2024-03-28T13:35:34.000Z" title="发表于 2024-03-28 21:35:34">2024-03-28</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2024 By Apong</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>
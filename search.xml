<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ThreadLocal解析</title>
    <url>/2024/06/30/ThreadLocal%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="ThreadLocal-——-线程变量"><a href="#ThreadLocal-——-线程变量" class="headerlink" title="ThreadLocal —— 线程变量"></a>ThreadLocal —— 线程变量</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>创建一个在不同线程之间读写相互隔离的变量。</p>
<p>大白话：同一个变量，在不同线程的环境下，访问和修改它的值都互不影响，不同线程允许拥有不同的值。</p>
<span id="more"></span>

<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>声明为一个静态的类属性。</p>
<p>以存储 User 信息为例：</p>
<p>提供方法</p>
<ul>
<li>saveUser 设置 User 信息</li>
<li>getUser 获取 User 信息</li>
<li>removeUser 移除 User 信息</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserHolder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;UserDTO&gt; tl = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">saveUser</span><span class="params">(UserDTO user)</span>&#123;</span><br><span class="line">        tl.set(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UserDTO <span class="title function_">getUser</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tl.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">removeUser</span><span class="params">()</span>&#123;</span><br><span class="line">        tl.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>ThreadLocal 对象内部的数据是由 ThreadLocalMap <strong>维护</strong>的，</p>
<p>而每个 Thread 又有各自的 ThreadLocalMap。</p>
<p>因此“表面上”线程共享的类属性变量，实际上在每个 Thread 中读写的对象并不是同一个。</p>
<p>假设这有两个线程 A，B 操作一个线程变量 tl。</p>
<p>在 A 线程中 tl 的值是 1。</p>
<p>如果 B 线程想要修改它的值，就需要先找到<strong>当前 Thread</strong> 的 ThreadLocalMap，然后修改 map 中 tl 这个 key 所匹配的 value。</p>
<h3 id="什么叫做维护呢？"><a href="#什么叫做维护呢？" class="headerlink" title="什么叫做维护呢？"></a>什么叫做维护呢？</h3><p>这里以上述的 tl 表示 ThreadLocal 实例，并贴出该类的源码。</p>
<h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p>当 tl 进行 set 操作时，以自身实例作为 key，存储对象作为 value，存入了 ThreadLocalMap 中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><p>同理进行 get 操作时，以自身实例作为 key，索引 ThreadLocalMap 中的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h4><p>remove 操作也是如此，以自身实例为 key，移除这一对键值对。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">m</span> <span class="operator">=</span> getMap(Thread.currentThread());</span><br><span class="line">    <span class="keyword">if</span> (m != <span class="literal">null</span>) &#123;</span><br><span class="line">        m.remove(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h3><p>并不是 ThreadLocal 为每个线程提供了不同的变量副本，而是其借助不同线程中的 ThreadLocalMap 存储了当前线程的变量副本。</p>
<h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p><strong>内存泄漏：</strong>指程序中已分配的内存未能成功释放，导致可用内存逐渐减少的现象。</p>
<p>为什么线程变量通常声明为一个静态类属性，而不是局部变量呢？</p>
<p>因为 <strong>垃圾回收</strong> 机制。</p>
<p>如果将 ThreadLocal 实例声明为一个局部变量，在作用域结束时，会回收掉这个变量引用，导致 ThreadLocalMap 中存储了一个 key 为 null 的键值对，无法进行访问，也不能主动销毁。</p>
<p>从而发生内存泄漏。</p>
<p><strong>疑问:question:</strong></p>
<p>虽然引用被回收了，但是内存空间不会被释放吧，key 不至于为 null 吧？因为 map 的 key 保存了这个实例？</p>
<p><strong>答：</strong></p>
<p> Map 的 keys 保留了这个实例对象，所以这个 key 并不是 null；</p>
<p>只不过丢失了对这个 key 的引用，无法主动的查询对应的值，但是可以通过 map 的 keys，一一返回 value。</p>
<p>所以上述解释 <em>“导致 ThreadLocalMap 中存储了一个 key 为 null 的键值对”</em> 改为：<em>“导致 ThreadLocalMap 中存储了一个“消失的” key 的键值对”</em></p>
<p><strong>上述解释仍存疑:question:</strong></p>
<p>弱引用？和垃圾回收的关系？</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL-索引</title>
    <url>/2024/08/02/MySQL-%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<p>介绍</p>
<p>类似书的目录一样对数据进行分类，加快数据查找速度。</p>
<p>分类</p>
<ul>
<li>按数据结构分类</li>
<li>按物理存储分类</li>
<li>按字段特性分类</li>
<li>按字段个数分类</li>
</ul>
<p>数据结构分类</p>
<p><img src="/../assets/%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB.drawio.png" alt="img"></p>
<p>InnoDB选择索引的方式</p>
<ul>
<li>有主键</li>
<li>无主键，全有效列</li>
<li>都没有，隐式自增id</li>
</ul>
<p>B+树</p>
<p>多叉树，叶子结点存放数据，非叶子结点存放索引</p>
<p>每个结点按主键顺序存放，非叶子结点，则用来划分区域</p>
<p><img src="/../assets/btree.drawio.png" alt="主键索引 B+Tree"></p>
<p>存储千万级的数据最多需要 3-4 次磁盘IO ？？？</p>
<p><strong>对于二级索引</strong></p>
<p>叶子结点只存储主键值。</p>
<p>使用二级索引查询后，需要再查一次主键的 B+树，称作【回表】</p>
<p>如果只查询二级索引树存储的值，如主键，就能直接返回结果——【覆盖索引】</p>
<p>对比B+树、B树、二叉树、哈希的区别</p>
<ol>
<li>B树非叶子结点也要存数据，而是是单链表；空间消耗大，无法查询范围。</li>
<li>二叉树只能存两个子结点，高度相比多叉树会高出很多。</li>
<li>hash无法做范围查询</li>
</ol>
<p>物理存储分类</p>
<p>主键和二级索引的叶子结点存储结构不同</p>
<p>字段特性分类</p>
<p>主键索引：即以主键为索引</p>
<p>唯一索引：以唯一 UNIQUE 字段为索引，允许空值</p>
<p>普通索引：以普通的字段为索引</p>
<p>前缀索引：以字符类型的字段的前几个字符建立索引，可以减少索引占用的存储空间。</p>
<p>字段个数分类</p>
<p>单列索引</p>
<p>联合索引（多列、复合索引）</p>
<p>需要遵循最左匹配原则，where从左边开始匹配，顺序打乱索引会失效。</p>
<p>进行到范围查询时，之后的字段会失效。</p>
<p>key_len 记录使用了多少个</p>
<p><code>&gt;, &gt;=, BETWEEN...AND..., like j%</code></p>
<p>索引下推</p>
<p>Extra: <code>using index condition</code></p>
<p>索引区分度</p>
<p><img src="/../assets/%E5%8C%BA%E5%88%86%E5%BA%A6.png" alt="区分度计算公式"></p>
<p>性别就很小，不适合放在前面</p>
<p>查询优化器：全表扫描</p>
<p>什么时候需要、不需要索引？</p>
<p>缺点：</p>
<ol>
<li>空间消耗</li>
<li>维护耗时</li>
</ol>
<p>适用场景：</p>
<ol>
<li>唯一性限制</li>
<li>经常条件查询的</li>
<li>经常 group by 和 order by 的，无需二次排序。</li>
</ol>
<p>不适用场景：</p>
<ol>
<li><p>适用场景反例</p>
</li>
<li><p>经常需要修改的字段</p>
</li>
</ol>
<p>优化方式：</p>
<ol>
<li><p>前缀索引优化</p>
</li>
<li><p>覆盖索引优化</p>
</li>
<li><p>自增索引，减少树结构的维护时间</p>
<p>页分裂问题</p>
</li>
<li><p>非 NULL</p>
</li>
<li><p>防止索引失效</p>
<ol>
<li>左边、左右模糊匹配</li>
<li>对索引列进行计算</li>
<li>联合索引违背最左原则</li>
<li>OR两边有一边不是索引列</li>
</ol>
<p>可以通过 explain 的 key查看实际用的索引、key_len 查看生效的索引长度、type查看扫描类型</p>
</li>
</ol>
<p>EXPLAIN type 介绍</p>
<ol>
<li>All 全表扫描</li>
<li>Index 全索引扫描，只返回索引列</li>
<li>Range 索引范围扫描</li>
<li>ref 非唯一索引扫描</li>
<li>eq_ref 唯一索引扫描，通常发生在基于唯一索引的连表查询（相等的）</li>
<li>const 结果只有一条的唯一主键或唯一索引扫描</li>
</ol>
<p>extra</p>
<ul>
<li>using filesort</li>
<li>using temporary</li>
<li>using index 覆盖索引</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>TCP详解</title>
    <url>/2024/08/01/TCP%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>OSI七层模型</p>
<p>应用层</p>
<p>表示层</p>
<p>会话层</p>
<p>传输层</p>
<p>网络层</p>
<p>数据链路层</p>
<p>物理层</p>
<p>tcp，udp位于传输层</p>
<p>tcp&#x2F;ip 标识：源IP、端口号，目的IP、端口号，协议号</p>
<p><strong>端口范围</strong></p>
<p>0-1023 知名端口号</p>
<p>1024-65535 动态分配的端口号</p>
<p><strong>常见知名端口号</strong></p>
<p>ssh: 22</p>
<p>ftp: 21</p>
<p>http: 80</p>
<p>telnet: 23</p>
<p>https: 443</p>
<blockquote>
<p>在 linux 中使用 cat &#x2F;etc&#x2F;services 查看已记录端口号</p>
</blockquote>
<h2 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h2><p>结构图</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/00d1821abded524b2e9429691b0cc153.png" alt="在这里插入图片描述"></p>
<p><strong>特点：</strong></p>
<ul>
<li>无连接</li>
<li>不可靠：没有确认和重传机制</li>
<li>面向数据报：只能一次性发送全部报文</li>
</ul>
<p><strong>缓冲区：</strong></p>
<p>存在接收缓冲区，没有发送缓存区</p>
<p>因为 UDP 不保证可靠性，即使报文丢失，也不需要重发。</p>
<p>而 TCP 必须要有，当报文丢失，需要重新发送。</p>
<p>虽然具有接收缓冲区，但是无法保证接收的顺序，当缓冲区满了的时候再到达的报文会被丢弃。</p>
<p>UDP 是全双工协议，最多传送 64 k【计算方式？？】，如果超过需要手动分包。</p>
<p>基于 UDP 的应用层协议：</p>
<p>NFS：网络文件协议</p>
<p>TFTP：简单文件传输协议</p>
<p>DHCP：动态主机配置协议</p>
<p>BOOTP：无盘设备启动协议</p>
<p>DNS：域名解析协议</p>
<h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h2><p><img src="https://i-blog.csdnimg.cn/blog_migrate/26bb30f0808ad9fd94ba350157f278e7.png" alt="在这里插入图片描述"></p>
<p><strong>源端口号&#x2F;目的端口号：</strong>表示数据从哪个进程来，要到那个进程去</p>
<p><strong>32位序号：</strong>TCP将要传输的每段数据组进行了编号，序号是本报文段发送的数据组的第一个字节的编号，可以保证传输信息的有效性。</p>
<p>比如：一个报文段的序号为300，此报文段数据部分共有100字节，则下一个报文段的序号为401。</p>
<p><strong>32位确认序号：</strong>每一个ACK一个确认号：表示下一个期待收到的字节序号，且该序号之前的所有数据已经正确无误的收到。</p>
<p>确认号只有当ACK标志为1时才有效。比如建立连接时，<strong>SYN报文</strong>的ACK标志位为0。</p>
<p><strong>4位首部长度(数据偏移)：</strong> 表示该TCP头部有多少个32位bit(有多少个4字节)，可以将TCP报头和有效载荷分离。</p>
<p>TCP报文首部固定为20个字节即偏移量 5，最大能扩充到 15*4 &#x3D; 60个字节。</p>
<p><strong>6位标志位：</strong></p>
<ul>
<li>URG：标志<strong>紧急指针</strong>是否有效。</li>
<li>ACK：标识<strong>确认号</strong>是否有效。</li>
<li>PSH：提示<strong>接收端</strong>应用程序立即将<strong>接收缓冲区</strong>的数据拿走。</li>
<li>RST：它是为了<strong>处理异常连接</strong>的， 告诉连接不一致的一方，我们的连接还没有建立好， 要求对方重新建立连接。我们把携带RST标识的称为<strong>复位报文段</strong>。</li>
<li>SYN: 请求<strong>建立连接</strong>; 我们把携带SYN标识的称为<strong>同步报文段</strong>。</li>
<li>FIN：通知对方, 本端要<strong>关闭连接</strong>了, 我们称携带FIN标识的为<strong>结束报文段</strong>。</li>
</ul>
<p><strong>16位的紧急指针：</strong>指定<strong>优先被处理</strong>的报文段，这时就可以设置紧急指针，指向该报文段【序号？？】即可，然后将紧急标志设置为1。<br><strong>16位窗口大小：</strong>用于控制<strong>发送方</strong>发送的流量。接收方将自己接收<strong>缓冲器剩余空间</strong>的大小告诉发送方叫做16位窗口大小。</p>
<p>发送发可以根据窗口大小来适配发送的速度和大小，窗口大小最大是2的16次方，表示最多能表示发送64KB，但也可以根据选项中的某些位置扩展，最大扩展1G。<br><strong>16位校验和：</strong>发送端填充，<strong>CRC校验</strong>。如果接收端校验不通过， 则认为数据有问题</p>
<p>(此处的检验和不光包含TCP首部也包含TCP数据部分？？？)。</p>
<h3 id="确认应答机制"><a href="#确认应答机制" class="headerlink" title="确认应答机制"></a>确认应答机制</h3><p>发送端向接收端发送消息后，如果接收端成功收到了信息，会返回 ACK 和下一个报文段的确认号。</p>
<blockquote>
<p>如，主机A给主机B发送了1-1000的数据，ACK应答，携带了1001序列号。告诉主机A，我已经接受到了1-1000数据，下一次你从1001开始发送数据。</p>
</blockquote>
<h3 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h3><p>当接收端没有接受到消息，或者发出的 ACK 消息丢失了，发送端就会在特定的时间间隔内重发信息。</p>
<p>因此接收端会产生重复信息，需要根据【16位序列号？？？？】去重。</p>
<p><strong>如何确定超时的时间？</strong></p>
<p>太短会导致频繁发送重复的包，太长会影响重传效率，因此 TCP 为了保证高性能，会动态计算这个时间。</p>
<p>如 linux，以 500 ms 为单位进行控制，以整数倍递增，倍数以指数型递增。</p>
<p>当首次重发后，仍然超时就会等待 2*500ms、4*500ms…</p>
<h3 id="连接管理机制"><a href="#连接管理机制" class="headerlink" title="连接管理机制"></a>连接管理机制</h3><p><strong>三次握手</strong>：确保两端都有发送和接收的能力，两次握手只能确认一端能够发送，另一端能够回应，但无法确认另一端发送后，这一端也能正常回应。</p>
<p><img src="/../assets/image-20240801223020726.png" alt="image-20240801223020726"></p>
<p><strong>四次挥手</strong></p>
<p><img src="/../assets/851c5465701a9220100681120c61609e.png" alt="img"></p>
<p>收到 FIN 的时候无法立即关闭，需要等待 2 TTL（发收都完成），因此需要先返回确认 ACK，表示收到。</p>
<p>然后处理完成后，再发送 FIN 给客户端（第三次挥手），最后客户端回应，连接正确断开。</p>
<p><strong>TIME_WAIT 状态</strong></p>
<p>当我们实现一个TCP服务器时，我们把这个服务器运行起来。</p>
<p>然后将服务器关闭掉，再次重新启动服务器会发现一个问题：</p>
<p>就是不能马上再次绑定这个端口号和ip，需要等一会才可以重新绑定，其实等的这一会就是<strong>TIME_WAIT</strong> 状态。</p>
<p>TCP协议规定主动关闭连接的一方要处于TIME_WAIT状态，等待<strong>两个MSL</strong>的时间后才能回到CLOSED状态。<br>当我们使用Ctrl-C终止了server，server是主动关闭连接的一方在TIME_WAIT期间仍然<strong>不能再次监听同样的server端口。</strong></p>
<p><strong>MSL</strong></p>
<p>MSL在RFC1122中规定为<strong>两分钟</strong>(120s)，但是各操作系统的实现不同。</p>
<p>在Centos7上默认配置的值是60s可以通过cat &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_fin_timeout查看MSL的值。</p>
<p><strong>为什么TIME_WAIT时间一定是2MSL：</strong></p>
<p>保证两端都发送和接收都已完成。</p>
<p>首先，TIME_WAIT是为了防止最后一个ACK丢失，如果没有TIME_WAIT，那么主动断开连接的一方就已经关闭连接，但是另一方还没有断开连接，它收不到确认ACK会认为自己上次发送的FIN报文丢失会重发该报文，但是另一方已经断开连接了，这就会造成连接不一致的问题，所以TIME_WAIT是必须的。</p>
<p><strong>MSL是TCP报文在发送缓冲区的最大生存时间</strong>，如果TIME_WAIT持续存在2MSL的话就能保证在两个传输方向上的尚未被接收或迟到的报文段都已经消失。</p>
<p>(否则如果服务器立刻重启，可能会收到来自上一个进程的<strong>迟到的</strong>数据，但是这种数据很可能是错误的)。</p>
<p>同时也是在理论上保证最后一个报文可靠到达。</p>
<p>(假设最后一个ACK丢失, 那么服务器会再重发一个FIN，这时虽然客户端的进程不在了，但是TCP连接还在，仍然可以重发LAST_ACK，这就会导致问题) ？？？？</p>
<p><strong>解决TIME_WAIT状态引起的bind失败的方法：</strong></p>
<p>在server的TCP连接没有完全断开之前不允许重新绑定，也就是TIME_WAIT时间没有过，但是这样不允许立即绑定在某些情况下是不合理的：</p>
<p>比如：服务器需要处理<strong>大量的</strong>、<strong>短暂的</strong>客户端的连接<br>(每个连接的生存时间可能很短，但是每秒都有很大数量的客户 端来请求)<br>这个时候如果由服务器端主动关闭连接(比如某些客户端不活跃，就需要被服务器端主动清理掉)，</p>
<p>这样服务器端就会有大量的端口产生大量TIME_WAIT状态，无法立刻重用，需要等待。<br>每个连接都会占用一个通信五元组(源ip, 源端口, 目的ip, 目的端口, 协议)。其中服务器的ip和端口和协议是固定的，如果新来的客户端连接的ip和端口号和TIME_WAIT占用的<strong>连接重复</strong>就造成等待。<br><strong>解决方法：</strong>使用setsockopt()设置socket描述符的选项SO_REUSEADDR为1，表示允许创建端口号相同但IP地址不同的多个socket描述符。</p>
<p><strong>CLOSE_WAIT 状态</strong></p>
<p>在两次挥手过后，如果服务器还没有第三次挥手，此时就是 CLOSE_WAIT 状态。</p>
<h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>确认应答策略要求每一个发送的数据段都要给一个ACK，收到后再发送下一个数据段。</p>
<p>相当于 2L 的时间发送一段数据，性能较差，尤其是数据往返的时间较长的时候。</p>
<p>滑动窗口可以同时发送多条消息，将多个段的等待时间重叠在一起。</p>
<p>想当于 1L 的时间发送多条数据，大大的提高了吞吐率。</p>
<p><img src="/../assets/177935b496ee7d7f11ed9c9a9e894dcf.png" alt="在这里插入图片描述"></p>
<p><strong>窗口大小</strong>：指的是无需等待确认应答而可以继续发送数据的最大值。</p>
<p>上图的窗口大小就是4000个字节(四个数据段段)。</p>
<blockquote>
<p>和 TCP 协议头的窗口大小是一个东西吗？？控制发送流量</p>
</blockquote>
<p>发送前四个段的时候，不需要等待任何ACK直接发送即可。</p>
<p>当收到第一个ACK后滑动窗口向后移动，继续发送第五个段的数据，然后依次类推。</p>
<p>操作系统内核通过<strong>发送缓冲区</strong>来记录当前还有哪些数据没有应答。</p>
<p>只有确认应答过的数据，才能从缓冲区删掉，窗口越大，则网络的吞吐率就越高。</p>
<p>滑动窗口左边代表已经发送过并且确认，可以从发送缓冲区中删除了，</p>
<p>滑动窗口里边代表发送出去但是没有确认。</p>
<p>滑动窗口右边代表还没有发送的数据。</p>
<p><img src="/../assets/df5e0a10e3053d58d6db9e339defdda3.png" alt="在这里插入图片描述"></p>
<p>如果在这种情况中出现了丢包现象，应该如何重发呢？</p>
<p><strong>ACK丢失：</strong>数据到达接收方，但是 ACK 报文丢失：可以根据后边的ACK确认。</p>
<blockquote>
<p>因为接收方也是一段一段同步接收的，所以如果丢失了前面的 ACK，后面的可以帮忙确定。</p>
</blockquote>
<p>假设发送方发送1-1000的数据，接收方收到返回确认ACK，但是返回的ACK丢失了，</p>
<p>另一边发送1001-2000收到的确认ACK 2001，就可以认为1-1000数据接收成功 。</p>
<p><strong>数据段丢失：</strong> 当某一段报文段丢失之后，发送端会<strong>持续</strong>收到 1001 这样的ACK，就像是在提醒发送端 “我想要的是 1001” 一样。</p>
<p>如果发送端主机连续<strong>三次</strong>收到了同样一个”1001” 这样的应答，就会将对应的数据 1001 - 2000 重新发送；</p>
<p>并且这个时候接收端收到了 1001 之后， 再次返回的ACK就是7001了。</p>
<p>因为2001 - 7000接收端其实之前就已经收到了，被放到了接收端操作系统内核的接收缓冲区中。</p>
<p>这种机制被称为 “<strong>高速重发控制</strong>”(也叫 “<strong>快重传</strong>“)。</p>
<p><img src="/../assets/400205f0f6d346180974888623079274.png" alt="在这里插入图片描述"></p>
<p><strong>快重传</strong>要求接收方在收到一个失序的报文段后就立即发出重复确认</p>
<blockquote>
<p> （为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。</p>
</blockquote>
<p>快重传算法规定：发送方只要一连收到<strong>三个重复确认</strong>就应当立即重传对方尚未收到的报文段，而<strong>不必继续等待设置的重传计时器</strong>时间到期。</p>
<p>由于不需要等待设置的重传计时器到期，能尽早重传未被确认的报文段，能提高整个网络的吞吐量。</p>
<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a><strong>流量控制</strong></h3><p>接收端处理数据的速度是有限的，如果发送端发的太快，导致接收端的<strong>缓冲区被装满</strong>；</p>
<p>这个时候如果发送端继续发送，就会造成<strong>丢包</strong>，然后引起丢包重传等等一系列连锁反应。</p>
<p>因此TCP支持根据接收端的处理能力，来决定发送端的发送速度，这个机制就叫做流量控制(Flow Control)。-&gt; 窗口字段</p>
<p>接收端将自己可以接收的缓冲区大小放入TCP首部中的”窗口大小”字段，通过ACK确认报文通知发送端<br>窗口大小字段越大，说明网络的吞吐量越高</p>
<p>接收端一旦发现自己的缓冲区快满了，就会将窗口大小设置成一个更小的值通知给发送端;<br>发送端接受到这个窗口之后，就会减慢自己的发送速度;</p>
<p>如果接收端缓冲区满了， 就会将窗口置为0。</p>
<p>这时发送方不再发送数据，但是需要定期发送一个<strong>窗口探测数据段</strong>，使接收端把窗口大小告诉发送端。<br>除了窗口大小，TCP首部的 40 字节选项中还包含了一个窗口扩大因子M，实际窗口大小是 窗口字段的值左移M位。</p>
<p>接收端窗口如果更新，会向发送端发送一个更新通知，如果这个更新通知在中途丢失了，会导致无法继续通信，所以发送端要定时发送窗口探测包。</p>
<blockquote>
<p>这个窗口探测数据段的数据是无意义的，目的是得到返回的窗口大小。</p>
</blockquote>
<h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a><strong>拥塞控制</strong></h3><p>虽然 TCP 有了滑动窗口能够同时发送大量的数据，但是如果在刚开始阶段就发送大量的数据，仍然可能引发问题。</p>
<p>因为网络上有很多的计算机，可能当前的网络状态就已经比较拥堵，在不清楚当前网络状态下，贸然发送大量的数据是很有可能引起雪上加霜的，造成网络更加堵塞。</p>
<p>TCP引入<strong>慢启动机制</strong>，先发少量的数据探探路，摸清当前的网络拥堵状态，再决定按照多大的速度传输数据。</p>
<p><img src="/../assets/bd3f071631a537919e41921a104fc8bc.png" alt="在这里插入图片描述"></p>
<p>图中的 cwnd 表示拥塞窗口大小，开始时大小为1，根据应答情况进行递增或重置。</p>
<p>每次发送数据包的时候，将拥塞窗口和接收端主机反馈的窗口大小做比较，<strong>取较小的值</strong>作为实际发送的窗口。</p>
<p>像上面这样的拥塞窗口增长速度，是指数级别的。</p>
<p>“慢启动”只是指初使时慢，但是增长速度非常快。</p>
<p>为了控制增长的速率，引入一个叫做<strong>慢启动的阈值</strong>。</p>
<p>当拥塞窗口超过这个阈值的时候，不再按照指数方式增长， 而是按照线性方式增长。</p>
<p><img src="/../assets/41d1659ebe0b087e7fbb4912ae2c6929.png" alt="在这里插入图片描述"></p>
<p>当TCP开始启动的时候，慢启动阈值等于窗口最大值？？</p>
<blockquote>
<p>哪个阶段的窗口最大值，第二次握手获得的窗口大小？？</p>
</blockquote>
<p>在每次<strong>超时重发</strong>后，慢启动阈值会变成原来的一半同时拥塞窗口置回 1<br>区别于超时重传：是少量的丢包。</p>
<p>大量的丢包，我们就认为网络拥塞。当TCP通信开始后，网络吞吐量会逐渐上升。</p>
<p>随着网络发生拥堵，吞吐量会立刻下降。</p>
<p>拥塞控制归根结底是TCP协议想尽可能快的把数据传输给对方，但是又要避免给网络造成太大压力的折中方案。</p>
<p><img src="/../assets/0eea54ca2d2109be4248007f60e564cd.png" alt="在这里插入图片描述"></p>
<h4 id="拥塞控制与流量控制的区别："><a href="#拥塞控制与流量控制的区别：" class="headerlink" title="拥塞控制与流量控制的区别："></a><strong>拥塞控制与流量控制的区别：</strong></h4><p><strong>拥塞控制</strong>是防止过多的数据突然注入到网络中，考虑到了网络中的路由器或链路过载，是一个<strong>全局性</strong>的过程。 <strong>流量控制</strong>是基于<strong>缓冲区</strong>的，某个时间点的通信量控制，主要就是控制发送端发送数据的速率，以便接收端来得及接收。</p>
<h4 id="拥塞控制的标志："><a href="#拥塞控制的标志：" class="headerlink" title="拥塞控制的标志："></a><strong>拥塞控制的标志：</strong></h4><ul>
<li>重传计时器超时</li>
<li>接收到三个重复确认</li>
</ul>
<p>拥塞避免并非完全能够避免拥塞，只是尽量使网络不容易出现拥塞。</p>
<p>拥塞避免的思路是让拥塞窗口 cwnd 缓慢地增大。</p>
<p>无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞</p>
<p>（其根据就是没有收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理）</p>
<p>这时就把慢开始门限设置为出现拥塞时的门限的一半。然后把拥塞窗口设置为1，执行慢开始算法。</p>
<p><img src="/../assets/cf57209e259ba0966c38cd1a6949463b.png" alt="在这里插入图片描述"></p>
<p><strong>线性-加法增大：</strong>执行拥塞避免算法后，拥塞窗口线性缓慢增大，防止网络过早出现拥塞<br><strong>超时-乘法减小：</strong>无论是慢开始阶段还是拥塞避免，只要出现了网络拥塞（超时），那就把慢开始门限值ssthresh减半</p>
<h4 id="快恢复（与快重传配合使用）"><a href="#快恢复（与快重传配合使用）" class="headerlink" title="快恢复（与快重传配合使用）"></a><strong>快恢复（与快重传配合使用）</strong></h4><p>采用快恢复算法时，慢启动只在TCP开始连接建立时和网络出现超时时才使用。</p>
<p>当发送方连续收到三个重复确认时，就执行“乘法减小”算法，但是只把 ssthresh 门限减半，并把 cwnd 设置为 ssthresh 的大小。</p>
<p>因为考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为<strong>网络可能没有出现拥塞。</strong></p>
<h3 id="延迟应答"><a href="#延迟应答" class="headerlink" title="延迟应答"></a><strong>延迟应答</strong></h3><p>如果接收数据的主机立刻返回ACK应答，这时候返回的窗口可能比较小。</p>
<blockquote>
<p>可能会根据本次接收的数据大小来控制窗口。</p>
</blockquote>
<p>假设接收端缓冲区为1M 一次收到了 500 K 的数据。如果立刻应答，返回的窗口就是500K。</p>
<p> 但实际上可能处理端处理的速度很快，10ms之内就把500K数据从缓冲区消费掉了，在这种情况下，接收端处理还远没有达到自己的极限，即使窗口再放大一些也能处理过来。</p>
<p>如果接收端稍微等一会再应答，比如等待200ms再应答，那么这个时候返回的窗口大小就是1M。</p>
<p>因为窗口越大，网络吞吐量就越大，传输效率就越高。</p>
<p>所以我们的目标是在保证网络不拥塞的情况下尽量提高传输效率。</p>
<p><strong>延迟策略：</strong></p>
<ul>
<li>数量限制: 每隔N个包就应答一次</li>
<li>时间限制: 超过延迟时间就应答一次</li>
</ul>
<blockquote>
<p>具体的数量和超时时间, 依操作系统不同也有差异; 一般N取2, 超时时间取200ms</p>
</blockquote>
<h3 id="捎带应答"><a href="#捎带应答" class="headerlink" title="捎带应答"></a><strong>捎带应答</strong></h3><p>在延迟应答的基础上，存在很多情况下，客户端服务器在应用层也是”一发一收” 的。 </p>
<p>意味着客户端给服务器说了”How are you”， 服务器也会给客户端回一个”Fine, thank you”。那么这个时候ACK就可以搭顺风车，和服务器回应的 “Fine, thank you” 一起回给客户端</p>
<p>就是发送 ACK 的同时顺便带上这边要发送的数据（3次握手）</p>
<h3 id="面向字节流"><a href="#面向字节流" class="headerlink" title="面向字节流"></a><strong>面向字节流</strong></h3><p>当我们创建一个TCP的socket，会同时在内核中创建一个<strong>发送缓冲区</strong>和一个<strong>接收缓冲区</strong>。</p>
<p>调用 <strong>write</strong> 时，内核将数据会先写入发送缓冲区中，</p>
<p>如果发送的字节数太长，会被拆分成多个TCP的数据包发出，</p>
<p>如果发送的字节数太短，就会先在缓冲区里等待， 等到缓冲区长度达到设置长度，然后等到其他合适的时机发送出去。<br>调用 <strong>read</strong> 接收数据的时候， 数据也是从网卡驱动程序到达内核的接收缓冲区。</p>
<p>然后应用程序可以调用read从接收缓冲区拿数据。</p>
<p>TCP的一个连接，既有发送缓冲区, 也有接收缓冲区，那么对于这一个连接，既可以读数据，也可以写数据。所以是<strong>全双工</strong>的。</p>
<p><strong>并且由于缓冲区的存在，TCP程序的读和写不需要一一匹配。</strong></p>
<p>例如: </p>
<p>写100个字节数据时, 可以调用一次write写100个字节, 也可以调用100次write, 每次写一个字节; </p>
<p>读100个字节数据时, 也完全不需要考虑写的时候是怎么写的, 既可以一次read 100个字节, 也可以一次 read一个字节, 重复100次</p>
<h3 id="粘包问题"><a href="#粘包问题" class="headerlink" title="粘包问题"></a><strong>粘包问题</strong></h3><p>粘包问题中的 “包”是指的<strong>应用层的</strong>数据包。</p>
<p>在TCP的协议头中，没有如同<strong>UDP</strong>一样的 “<strong>报文长度</strong>“这样的字段，只有一个序号这样的字段。</p>
<p>站在传输层的角度， TCP是一个一个报文过来的，按照序号排好序放在缓冲区中，但是站在应用层的角度，它看到的只是一串连续的字节数据。</p>
<p>但是不知道从哪个部分开始到哪个部分结束是一个<strong>完整的</strong>应用层数据包，这就是粘包问题。</p>
<p><strong>如何避免粘包问题呢?</strong> </p>
<p>明确两个包之间的边界。</p>
<ul>
<li>对于<strong>定长</strong>的包，保证每次都按<strong>固定大小</strong>读取即可。</li>
</ul>
<blockquote>
<p>例如一个Request结构, 是固定大小的, 那么就从缓冲区从头开始按sizeof(Request)依次读取即可</p>
</blockquote>
<ul>
<li>对于<strong>变长</strong>的包，可以在包头的位置，<strong>约定一个包总长度的字段</strong>，从而就知道了包的结束位置。</li>
<li>对于<strong>变长</strong>的包，还可以在包和包之间使用明确的<strong>分隔符</strong></li>
</ul>
<p>(应用层协议是程序员自己来定义的, 只要保证分隔符不和正文冲突即可)。</p>
<p><strong>对比UDP协议</strong></p>
<p>UDP是一个一个把数据交付给应用层，有明确的数据边界。</p>
<p>站在应用层的角度， 使用UDP的时候要么收到完整的UDP报文要么不收，不会出现”半个”的情况。</p>
<h3 id="TCP连接异常情况"><a href="#TCP连接异常情况" class="headerlink" title="TCP连接异常情况"></a><strong>TCP连接异常情况</strong></h3><ol>
<li><p><strong>进程终止：</strong>进程终止会释放文件描述符，仍然可以发送 FIN，和正常关闭没有什么区别。<strong>机器重启和进程终止一样。</strong></p>
</li>
<li><p><strong>机器掉电&#x2F;网线断开：</strong>接收端认为连接还在，一旦接收端有写入操作，接收端发现连接已经不在了，就会进行 reset。</p>
</li>
</ol>
<p>即使没有写入操作，TCP自己也内置了一个<strong>保活定时器</strong>，会定期询问对方是否还在。<br>如果对方不在，也会把连接释放。<br>应用层的某些协议, 也有一些这样的检测机制.例如HTTP长连接中, 也会定期检测对方的状态.</p>
<p>比如 QQ 断线之后, 也会定期尝试重新连接。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
        <category>TCP</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode top100详解</title>
    <url>/2024/07/27/leetcode-top100/</url>
    <content><![CDATA[<h2 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a>98. 验证二叉搜索树</h2><p><img src="/../assets/image-20240727163719314.png" alt="image-20240727163719314"></p>
<p><strong>解法一：</strong>递归</p>
<p>验证搜索树可以转换为每一颗子树的 小 &lt; 本身 &lt; 大 的思想。<br>根节点由于没有限制，只要满足 -inf - +inf 即可以，<br>然后随着左右子树的递归遍历，分别改变上界和下界。<br>如左子树必须满足 (-inf, root.val)，右子树：(root.val, +inf)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root, <span class="type">long</span> left, <span class="type">long</span> right)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       <span class="keyword">if</span>(root.val &gt;= right || root.val &lt;= left) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       <span class="keyword">return</span> isValidBST(root.left, left, root.val) &amp;&amp; isValidBST(root.right, root.val, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解法二：中序遍历</strong></p>
<p>由于二叉搜索树的中序遍历得到的一定是有序的数组。</p>
<p>只要判断中序遍历过程中，是否有序即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// 最小值为初始比较值</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">min</span> <span class="operator">=</span> Long.MIN_VALUE;</span><br><span class="line">        <span class="comment">// 构建栈，模仿递归</span></span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 以根节点开始</span></span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty() || root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 开始递归</span></span><br><span class="line">            <span class="keyword">while</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 中序遍历：取出当前“根节点”</span></span><br><span class="line">            root = stack.pop();</span><br><span class="line">            <span class="keyword">if</span>(root.val &lt;= min) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 迭代最小值</span></span><br><span class="line">            min = root.val;</span><br><span class="line">            <span class="comment">// 访问右子树</span></span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>模仿递归的一个关键因素是保证状态始终在 root 上变化。</p>
</blockquote>
<h2 id="230-二叉搜索树中第K小的元素"><a href="#230-二叉搜索树中第K小的元素" class="headerlink" title="230. 二叉搜索树中第K小的元素"></a>230. 二叉搜索树中第K小的元素</h2><p>最简单的思路就是：中序遍历，然后返回第 k-1 个元素。</p>
<p>迭代实现，不需要访问所有元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kthSmallest</span><span class="params">(TreeNode root, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            --k;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>记录子树的结点数</strong></p>
<p><strong>之所以需要中序遍历前 k 个元素，是因为不知道第 k 个元素是在树的什么位置。</strong></p>
<p>也就是不知道子树的结点数量，需要一层一层遍历，然后计数。</p>
<p>所以可以先记录每颗子树的结点数。</p>
<p>那么第 k 小元素的位置一定满足如下条件：</p>
<p>以 node 作为根结点，开始搜索：</p>
<p>如果 node 的左子树的结点数 <strong>left &lt; k−1**，则第 k 小的元素一定在 node 的**右子树**中，令 node 等于其的右子结点，将左子树的结点数算在内，然后令 **k 等于 k−left−1**，并继续搜索；<br>如果 node 的左子树的结点数 **left &#x3D;&#x3D; k−1**，则**第 k 小的元素即为 node** ，结束搜索并返回 node 即可；<br>如果 node 的左子树的结点数 **left &gt; k−1</strong>，则第 k 小的元素一定在 node 的<strong>左子树</strong>中，令 node 等于其左子结点，并继续搜索。<br>为了提高效率，选择将每个子树的结点数存在哈希表中。</p>
<p><strong>递归思想：一颗子树的左右结点数，分别是左右两颗子树的总结点数，只要不断往下遍历就能找到。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kthSmallest</span><span class="params">(TreeNode root, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">MyBst</span> <span class="variable">myBst</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyBst</span>(root);</span><br><span class="line">        <span class="keyword">return</span> myBst.kthSmallest(k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyBst</span> &#123;</span><br><span class="line">    TreeNode root;</span><br><span class="line">    Map&lt;TreeNode, Integer&gt; nodeNum;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyBst</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.root = root;</span><br><span class="line">        <span class="built_in">this</span>.nodeNum = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        countNodeNum(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据子树的结点数分支遍历返回第 k 个结点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kthSmallest</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span>(node != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 当左右子树为空时，需返回0</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> nodeNum.getOrDefault(node.left, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(left &lt; k-<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 不够数，减去左边和根看右边</span></span><br><span class="line">                node = node.right;</span><br><span class="line">                k -= left+<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left == k-<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">// 刚好，退出循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 超了，在左边</span></span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node != <span class="literal">null</span> ? node.val : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归统计所有结点作为子树的结点数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">countNodeNum</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        nodeNum.put(node, <span class="number">1</span>+countNodeNum(node.left)+countNodeNum(node.right));</span><br><span class="line">        <span class="keyword">return</span> nodeNum.get(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199. 二叉树的右视图"></a>199. 二叉树的右视图</h2><p><img src="/../assets/image-20240729151611620.png" alt="image-20240729151611620"></p>
<p>右视图就是从每一层的右边看过去的第一个节点。</p>
<p>由于不知道树的具体结构，所以可以全部遍历然后取【每一层的】右边第一个。</p>
<p>可以用深度优先遍历，每次优先访问最右边的，然后用一个哈希表记录每一层访问到的第一个元素，其它元素直接舍弃。</p>
<p><strong>DPS</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">rightSideView</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">        <span class="comment">// 总是向右走，每层遇到的第一个就是右视图</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">max_depth</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        Deque&lt;TreeNode&gt; nodeStack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        Deque&lt;Integer&gt; depthStack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// dps遍历</span></span><br><span class="line">        nodeStack.push(root);</span><br><span class="line">        depthStack.push(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span>(!nodeStack.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> nodeStack.pop();</span><br><span class="line">            <span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> depthStack.pop();</span><br><span class="line">            <span class="comment">// 维护二叉树的最大深度</span></span><br><span class="line">            max_depth = Math.max(max_depth, depth);</span><br><span class="line">            <span class="comment">// 只插入此深度的第一个节点</span></span><br><span class="line">            <span class="keyword">if</span>(!map.containsKey(max_depth)) map.put(max_depth, node.val);</span><br><span class="line">            <span class="comment">// 放入可访问的其它节点</span></span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                nodeStack.push(node.left);</span><br><span class="line">                depthStack.push(depth+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                nodeStack.push(node.right);</span><br><span class="line">                depthStack.push(depth+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 按深度取出所有节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=max_depth; i++)</span><br><span class="line">            ans.add(map.get(i));</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者用广度优先搜索，每一层的最后一个就是右边第一个。</p>
<p><strong>BFS</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">rightSideView</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">        ArrayList&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 每层遇到的右边第一个就是右视图</span></span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        q.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">            <span class="comment">// 根据每一层的个数，隔离每一层</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">layerNum</span> <span class="operator">=</span> q.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;layerNum; i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> q.poll();</span><br><span class="line">                <span class="comment">// 添加各层最后一个</span></span><br><span class="line">                <span class="keyword">if</span>(i == layerNum-<span class="number">1</span>) ans.add(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>) q.offer(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>) q.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="114-二叉树展开为链表"><a href="#114-二叉树展开为链表" class="headerlink" title="114. 二叉树展开为链表"></a>114. 二叉树展开为链表</h2><p><img src="/../assets/image-20240729160936745.png" alt="image-20240729160936745"></p>
<p>常规思路可以先按照先序遍历存储一条链表，然后从 root 开始逐一复制节点。</p>
<p>或者直接“拼接”。</p>
<p>只要按照先序遍历的顺序，找到左子树最后一个节点，然后拼接上右子树，</p>
<p>再把左子树整个移到右边去，如此循环处理每一个右节点，最后就变成直直的一条链表了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flatten</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 根据左边是否有节点，决定是否需要拼接</span></span><br><span class="line">            <span class="keyword">if</span>(root.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">// 先找到左子树最右边的节点</span></span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">last_right</span> <span class="operator">=</span> root.left;</span><br><span class="line">                <span class="keyword">while</span>(last_right.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    last_right = last_right.right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 把当前右子树插到左子树最右边</span></span><br><span class="line">                last_right.right = root.right;</span><br><span class="line">                <span class="comment">// 把左子树整个移到当前节点右边</span></span><br><span class="line">                root.right = root.left;</span><br><span class="line">                root.left = <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">// 拼接下一个节点的左右子树</span></span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 左边是空的，直接拼接下一个节点</span></span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   5</span><br><span class="line"> / \   \</span><br><span class="line">3   4   6</span><br><span class="line"></span><br><span class="line">//将 1 的左子树插入到右子树的地方</span><br><span class="line">    1</span><br><span class="line">     \</span><br><span class="line">      2         5</span><br><span class="line">     / \         \</span><br><span class="line">    3   4         6        </span><br><span class="line">//将原来的右子树接到左子树的最右边节点</span><br><span class="line">    1</span><br><span class="line">     \</span><br><span class="line">      2          </span><br><span class="line">     / \          </span><br><span class="line">    3   4  </span><br><span class="line">         \</span><br><span class="line">          5</span><br><span class="line">           \</span><br><span class="line">            6</span><br><span class="line">            </span><br><span class="line"> //将 2 的左子树插入到右子树的地方</span><br><span class="line">    1</span><br><span class="line">     \</span><br><span class="line">      2          </span><br><span class="line">       \          </span><br><span class="line">        3       4  </span><br><span class="line">                 \</span><br><span class="line">                  5</span><br><span class="line">                   \</span><br><span class="line">                    6   </span><br><span class="line">        </span><br><span class="line"> //将原来的右子树接到左子树的最右边节点</span><br><span class="line">    1</span><br><span class="line">     \</span><br><span class="line">      2          </span><br><span class="line">       \          </span><br><span class="line">        3      </span><br><span class="line">         \</span><br><span class="line">          4  </span><br><span class="line">           \</span><br><span class="line">            5</span><br><span class="line">             \</span><br><span class="line">              6         </span><br><span class="line">  </span><br><span class="line">  ......</span><br></pre></td></tr></table></figure>

<h2 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300. 最长递增子序列"></a>300. 最长递增子序列</h2><p><img src="/../assets/image-20240730132945810.png" alt="image-20240730132945810"></p>
<p><strong>动态规划</strong></p>
<p>定义状态：dp[i] 的值就代表以 nums[i] 结尾的最长子序列长度</p>
<p>转移方程：遍历之前的 dp[j]，当 nums[j] &lt; nums[i] 时表示可以接在后面，保留拼接后的最大值 dp[i] &#x3D; max(dp[i], dp[j]+1)</p>
<p>初始状态：每个数元素本身至少就是一个长度为 1 的序列。</p>
<p>返回值：记录 dp[i] 的最大值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="comment">// 每个数字本身都是一个序列</span></span><br><span class="line">        Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="comment">// 找到能继续连起来的最大的子序列</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] &lt; nums[i]) dp[i] = Math.max(dp[i], dp[j]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.max(res, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>动态规划 + 二分法</strong></p>
<p>普通的动态规划需要找到能接到上的最长的子序列，所以是 dp[i] &#x3D; max(dp[i], dp[j]+1)。</p>
<p>那如果维护一个 tails 数组，不断取出子序列 nums[1,k] 尾部元素更新 tails 数组，只保留更小的尾部，那么 tails 数组的长度就是最终答案。</p>
<p>优化的精髓在于：本身是一个有序序列，能够通过二分法更新 nums[1,k] 的尾部最小值，保证每次迭代都是基于之前子序列的最大可能有序序列。</p>
<blockquote>
<p>这个更新尾部最小值，很好的“拿出了”一长串递增序列中的无关元素。</p>
</blockquote>
<p>如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nums: 1 5 3</span><br><span class="line">取出 1</span><br><span class="line">tails: 1</span><br><span class="line">取出 5（能接上）</span><br><span class="line">tails: 1,5</span><br><span class="line">取出 3（替掉5，重新接上）</span><br><span class="line">tails: 1,3</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">// 始终维护每个子序列的尾部最小，并按升序排列</span></span><br><span class="line">        <span class="type">int</span>[] tails = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num: nums)&#123;</span><br><span class="line">            <span class="type">int</span> i=<span class="number">0</span>, j=res;</span><br><span class="line">            <span class="comment">// 二分法替换掉第一个尾部更大的（按顺序接上）</span></span><br><span class="line">            <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (i+j)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(tails[m] &lt; num) i = m+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> j = m;</span><br><span class="line">            &#125;</span><br><span class="line">            tails[i] = num;</span><br><span class="line">            <span class="comment">// 接在了最长的后面</span></span><br><span class="line">            <span class="keyword">if</span>(res == j) res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="105-从前序和中序遍历序列构造二叉树"><a href="#105-从前序和中序遍历序列构造二叉树" class="headerlink" title="105. 从前序和中序遍历序列构造二叉树"></a>105. 从前序和中序遍历序列构造二叉树</h2><p>通过后序和中序、前序和中序都能构造二叉树。</p>
<p>因为可以确定根的位置，然后从中序遍历中，将根的两边分为左右子树。</p>
<p>再不断递归划分左右子树，然后回溯就构建成功了。</p>
<p>前序遍历结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ 根节点, [左子树的前序遍历结果], [右子树的前序遍历结果] ]</span><br></pre></td></tr></table></figure>

<p>中序遍历结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ [左子树的中序遍历结果], 根节点, [右子树的中序遍历结果] ]</span><br></pre></td></tr></table></figure>

<p><strong>递归：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 减少索引结点位置时间</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> inorder.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;inorder.length; i++)&#123;</span><br><span class="line">            map.put(inorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> splitBuildTree(preorder, inorder, <span class="number">0</span>, n-<span class="number">1</span>, <span class="number">0</span>, n-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">splitBuildTree</span><span class="params">(<span class="type">int</span>[] pre, <span class="type">int</span>[] in, <span class="type">int</span> lp, <span class="type">int</span> rp, <span class="type">int</span> li, <span class="type">int</span> ri)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lp &gt; rp) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 只要从先序遍历中知道根节点，就可以在中序中分割出左右子树</span></span><br><span class="line">        <span class="comment">// 如此递归，直到建成最小的子树，然后返回根节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pre_root</span> <span class="operator">=</span> lp;</span><br><span class="line">        <span class="type">int</span> <span class="variable">in_root</span> <span class="operator">=</span> map.get(pre[lp]);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(pre[lp]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftNum</span> <span class="operator">=</span> in_root-li;</span><br><span class="line">        <span class="comment">// 从 左边界+1 开始的 leftNum 个，就是左子树</span></span><br><span class="line">        root.left = splitBuildTree(pre, in, lp+<span class="number">1</span>, lp+leftNum, li, in_root-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 从 左子树</span></span><br><span class="line">        root.right = splitBuildTree(pre, in, lp+<span class="number">1</span>+leftNum, rp, in_root+<span class="number">1</span>, ri);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="437-路径总和-Ⅲ"><a href="#437-路径总和-Ⅲ" class="headerlink" title="437. 路径总和 Ⅲ"></a>437. 路径总和 Ⅲ</h2><p><img src="/../assets/image-20240801171805324.png" alt="image-20240801171805324"></p>
<p>最简单的思路就是<strong>穷举法</strong>，以每一个结点为根，遍历所有可能的路径，如果满足就计数+1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">long</span> targetSum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> rootSum(root, targetSum);</span><br><span class="line">        <span class="comment">// 以每个结点为起点，穷举所有路径</span></span><br><span class="line">        ans += pathSum(root.left, targetSum);</span><br><span class="line">        ans += pathSum(root.right, targetSum);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 穷举法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rootSum</span><span class="params">(TreeNode root, <span class="type">long</span> targetSum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 判断当前节点是否满足</span></span><br><span class="line">        <span class="keyword">if</span> (root.val == targetSum) &#123;</span><br><span class="line">            ++ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 继续累减下去，看是否有满足的结点数（相比于累加，可以少维护一个变量）</span></span><br><span class="line">        ret += rootSum(root.left, targetSum - root.val);</span><br><span class="line">        ret += rootSum(root.right, targetSum - root.val);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>前缀和</strong></p>
<p>通过 map 记录从根节点开始到每个结点的和，只要在前面结点中能够找到一个结点 pre[i] 到当前结点 pre[j] 的路径和为 targetSum，问题就解决了。</p>
<p>省去了第二层遍历，因为所有的路径都被“记住”了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 存储所有路径总和的次数</span></span><br><span class="line">    Map&lt;Long, Integer&gt; prefix = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">long</span> targetSum)</span> &#123;</span><br><span class="line">        <span class="comment">// 用于计算相等时的路径</span></span><br><span class="line">        prefix.put(<span class="number">0L</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> dfs(root, <span class="number">0L</span>, targetSum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, <span class="type">long</span> cur, <span class="type">long</span> targetSum)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        cur += root.val;</span><br><span class="line">        <span class="comment">// 是否存在一段路径和为 targetSum = cur - (cur-targetSum)</span></span><br><span class="line">        <span class="comment">// 相当于：既然无法直接索引某个点去求差得到 targetSum，就直接去查这个点</span></span><br><span class="line">        ret = prefix.getOrDefault(cur-targetSum, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 加入这条路径</span></span><br><span class="line">        prefix.put(cur, prefix.getOrDefault(cur, <span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 继续访问其他路径</span></span><br><span class="line">        ret += dfs(root.left, cur, targetSum);</span><br><span class="line">        ret += dfs(root.right, cur, targetSum);</span><br><span class="line">        <span class="comment">// 回溯，删除这条路径</span></span><br><span class="line">        prefix.put(cur, prefix.getOrDefault(cur, <span class="number">0</span>)-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a>236. 二叉树的最近公共祖先</h2><p><img src="/../assets/image-20240801183056893.png" alt="image-20240801183056893"></p>
<p><strong>哈希回溯定位</strong></p>
<p>可以先遍历整个树，通过哈希表存储所有结点的父节点，这样就可以得到 p,q 的“继承”路线。</p>
<p>然后先回溯 p 的路线，并记录所有已访问的结点。</p>
<p>再回溯 q 的路线，同时匹配是否已访问，因为是自底向上，第一个存在的就是最近公共祖先。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    HashMap&lt;TreeNode, TreeNode&gt; parent = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    HashSet&lt;TreeNode&gt; visited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="comment">// 自底向上回溯一遍</span></span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">null</span>)&#123;</span><br><span class="line">            visited.add(p);</span><br><span class="line">            p = parent.get(p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当 q 回溯时，遇到第一个已访问的结点就是最近公共祖先</span></span><br><span class="line">        <span class="keyword">while</span>(q != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited.contains(q))&#123;</span><br><span class="line">                <span class="keyword">return</span> q;</span><br><span class="line">            &#125;</span><br><span class="line">            q = parent.get(q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="comment">// 排除空结点</span></span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            parent.put(root.left, root);</span><br><span class="line">            dfs(root.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            parent.put(root.right, root);</span><br><span class="line">            dfs(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>标记回溯</strong></p>
<p>最近公共祖先存在两种类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">分散在两边</span><br><span class="line">  0</span><br><span class="line"> / \</span><br><span class="line">p   q</span><br><span class="line">一方作为另一方的父结点</span><br><span class="line">  p</span><br><span class="line"> / \</span><br><span class="line">q</span><br></pre></td></tr></table></figure>

<p>第一种情况，可以用两个标记变量表示</p>
<p>left: 表示左边存在一个 p &#x2F; q</p>
<p>right: 表示右边存在一个 q &#x2F; p</p>
<blockquote>
<p>p 在左或在右都一样，第一种情况另一个一定在另一边。</p>
</blockquote>
<p>所以当满足 <code>left &amp;&amp; right</code> 此根节点就是 p，q 的祖先。</p>
<p>第二种情况类似，只需要额外判断自身是不是 p &#x2F; q。</p>
<p>满足条件：<code>(x == p || x == q) &amp;&amp; (left || right)</code> 即本身存在一个和左右存在一个。</p>
<p>再配合上递归回溯的特性，第一个满足的就是最近的祖先。</p>
<blockquote>
<p>是否会存在这个 true 使得祖先不满足最近的特点？</p>
<p>不会，因为如果已经在一个子树确定了结果，另一个子树是不可能为 true 的，也就是祖先不会上升。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    TreeNode ans;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        dfs(root, p, q);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> root.val;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">left</span> <span class="operator">=</span> dfs(root.left, p, q);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">right</span> <span class="operator">=</span> dfs(root.right, p, q);</span><br><span class="line">        <span class="keyword">if</span>((left &amp;&amp; right) || ((root == p || root == q) &amp;&amp; (left || right)))&#123;</span><br><span class="line">            ans = root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 只要一方满足就行</span></span><br><span class="line">        <span class="keyword">return</span> left || right || (root == p || root == q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>每日杂记 day9</title>
    <url>/2024/07/24/2024-7-24/</url>
    <content><![CDATA[<h2 id="树的名词"><a href="#树的名词" class="headerlink" title="树的名词"></a>树的名词</h2><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><h2 id="随机链表的复制"><a href="#随机链表的复制" class="headerlink" title="随机链表的复制"></a>随机链表的复制</h2><p><img src="/../assets/image-20240724171244188.png" alt="image-20240724171244188"></p>
<p>复制链表，可以通过建立一个头节点，一个一个节点新建然后再串起来。</p>
<p>但是 random 怎么串？它引用的节点可能此时还没创建（如图 11 -&gt; 1）</p>
<p><strong>怎么在还没创建的情况下，获得拷贝后链表的 random 映射关系？</strong></p>
<p>借助【旧链表】的 random 关系来找到【新的节点】，然后连接。</p>
<p>也就是说，我在通过 random 索引到【旧链表】的某个节点时，能够获得这个节点对应的拷贝后的节点。</p>
<p>所以，可以先一次遍历通过【哈希表】在创建新节点的同时，记录【新:旧】节点的这样一个关系。</p>
<p>然后再从头遍历，通过旧节点映射到新节点，分别连接 next 和 random，直至结束。</p>
<p><strong>解题代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node next;</span></span><br><span class="line"><span class="comment">    Node random;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">        this.next = null;</span></span><br><span class="line"><span class="comment">        this.random = null;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">copyRandomList</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        HashMap&lt;Node, Node&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 用哈希表记录（旧:新）的关系</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            map.put(cur, <span class="keyword">new</span> <span class="title class_">Node</span>(cur.val));</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 再次遍历连接 next 和 random（此时已拷贝完所有节点）</span></span><br><span class="line">        <span class="comment">// 通过旧的 random 去找新的 random</span></span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">dummyHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">0</span>), tail = dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">copy</span> <span class="operator">=</span> map.get(cur);</span><br><span class="line">            copy.random = map.get(cur.random);</span><br><span class="line">            tail.next = copy;</span><br><span class="line">            tail = tail.next;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="合并-K-个升序链表"><a href="#合并-K-个升序链表" class="headerlink" title="合并 K 个升序链表"></a>合并 K 个升序链表</h2><p><img src="/../assets/image-20240724200047683-17218224489991-17218224496733.png" alt="image-20240724200047683"></p>
<p>由于链表本身有序，借助两个有序链表合并的思路，可以新开一条链表 ans，数组中每一条链表依次合并进去。</p>
<p>时间复杂度分析：假设每个链表的最长长度是 n。第一次合并 ans 长度为 n，第二次为 2 x n，第 i 次是 i x n，数组总共有 k 组，总共就是 k 次，总时间为 O(k^2^n) 近似 O(n^3^)</p>
<p>经过分析，发现在一组一组的比较中，开头部分一直重复比较浪费时间，</p>
<p>而每个链表都是有序的，因此可以借助【优先队列】先有序存储每一组的链表的头节点，“一层一层”排序，</p>
<p>每次出队加入 ans 中，如果还有后继节点继续加入其中，保证每个节点只访问一次。</p>
<p>时间：总数 kn 个，堆排序时间 logk，总时间 O(kn x logk)。</p>
<p><strong>解题代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> lists.length;</span><br><span class="line">        PriorityQueue&lt;ListNode&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(Comparator.comparingInt(b -&gt; b.val));</span><br><span class="line">        <span class="comment">// 先传入每个链表的头节点，保证容器长度不会超过 k 。</span></span><br><span class="line">        <span class="keyword">for</span>(ListNode p: lists)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p != <span class="literal">null</span>) pq.offer(p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(), cur = dummy;</span><br><span class="line">        <span class="keyword">while</span>(!pq.isEmpty())&#123;</span><br><span class="line">            cur.next = pq.poll();</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            <span class="comment">// 如果这一组还有节点剩下，继续加入。</span></span><br><span class="line">            <span class="keyword">if</span>(cur.next != <span class="literal">null</span>)&#123;</span><br><span class="line">                pq.offer(cur.next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LRU-缓存"><a href="#LRU-缓存" class="headerlink" title="LRU 缓存"></a>LRU 缓存</h2><p>LRU是Least Recently Used的缩写，即最近最少使用。</p>
<p>当容量满的时候，需淘汰 LRU 元素。</p>
<p>【在 Java 中，LinkedHashMap 就遵循了该规则】</p>
<p><strong>什么是 LinkedHashMap ？</strong></p>
<p>答：在做到哈希表的同时，能够记录每个节点（键值对）相对的位置。</p>
<p><img src="/../assets/image-20240724213343570.png" alt="image-20240724213343570"></p>
<p>O(1) 的获取必然要用到哈希表。</p>
<p>如果超出容量就要移出最久未使用的，就必然要根据每次 get 和 put 保留操作元素的记录，然后得到最久未用的。</p>
<p>乍一看，可以用队列来存储操作记录，先入队的表示之前使用的，后入队的表示现在使用的；</p>
<p>这样的话，当溢出时，直接出队然后移除哈希表中的值就可以了？</p>
<p>但是存在： 1 2 3 2 这一种情况，即最新操作的节点记录在之前仍然存在，就会出现【误删】最新的节点。</p>
<p>所以在插入前，应该遍历队列删除这个 key，然后保留最新记录。</p>
<p>【但是这样违背了 put 操作 O(1) 的时间规定】</p>
<p>因此，可以将哈希表和双链表结合起来！</p>
<p>哈希表存储 key 对应的节点，做到元素 O(1) 的删除（先哈希索引，然后删除），需要自己实现链表的删除方法；</p>
<p>然后双链表充当队列，头部记录最新的操作节点，随着节点增加，尾部就作为【最久未使用】的节点了。</p>
<p>至此保证了 put 和 get 的 O(1) 时间。</p>
<blockquote>
<p>put 也算一次操作哦，需要更新最新操作节点记录。</p>
</blockquote>
<p><strong>解题代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">    <span class="comment">// 建立一个双链表，使得能够快速删除和索引前一个元素</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">DNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> key;</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        DNode pre;</span><br><span class="line">        DNode next;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">DNode</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">DNode</span><span class="params">(<span class="type">int</span> _key, <span class="type">int</span> _value)</span> &#123;key = _key; value = _value;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 存储 key:node 关系，方便更新操作记录，删除最久未使用节点</span></span><br><span class="line">    HashMap&lt;Integer, DNode&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 头存储最新操作节点，尾巴为最久</span></span><br><span class="line">    DNode head, tail;</span><br><span class="line">    <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        <span class="comment">// 建立伪头节点和尾节点，方便操作</span></span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">DNode</span>();</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="title class_">DNode</span>();</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.pre = head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">DNode</span> <span class="variable">node</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 更新操作记录</span></span><br><span class="line">        moveToHead(node);</span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="comment">// 先新增再移除，因为如果改变的是已有的key，是不需要移除的。</span></span><br><span class="line">        <span class="type">DNode</span> <span class="variable">p</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">        <span class="keyword">if</span>(p != <span class="literal">null</span>)&#123;</span><br><span class="line">            p.value = value;</span><br><span class="line">            <span class="comment">// 更新操作记录</span></span><br><span class="line">            moveToHead(p);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">DNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DNode</span>(key, value);</span><br><span class="line">            map.put(key, node);</span><br><span class="line">            <span class="comment">// 最新节点添加至链表头部</span></span><br><span class="line">            addToHead(node);</span><br><span class="line">            <span class="keyword">if</span>(map.size() &gt; <span class="built_in">this</span>.capacity)&#123;</span><br><span class="line">                <span class="type">DNode</span> <span class="variable">r</span> <span class="operator">=</span> removeTail();</span><br><span class="line">                map.remove(r.key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addToHead</span><span class="params">(DNode node)</span> &#123;</span><br><span class="line">        node.pre = head;</span><br><span class="line">        node.next = head.next;</span><br><span class="line">        head.next.pre = node;</span><br><span class="line">        head.next = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> DNode <span class="title function_">removeNode</span><span class="params">(DNode node)</span> &#123;</span><br><span class="line">        node.pre.next = node.next;</span><br><span class="line">        node.next.pre = node.pre;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveToHead</span><span class="params">(DNode node)</span> &#123;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        addToHead(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> DNode <span class="title function_">removeTail</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> removeNode(tail.pre);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.get(key);</span></span><br><span class="line"><span class="comment"> * obj.put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>每日总结</category>
      </categories>
      <tags>
        <tag>每日总结</tag>
      </tags>
  </entry>
  <entry>
    <title>每日杂记 day8</title>
    <url>/2024/07/23/2024-7-23/</url>
    <content><![CDATA[<h2 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h2><h3 id="链表的归并排序"><a href="#链表的归并排序" class="headerlink" title="链表的归并排序"></a>链表的归并排序</h3><p>关键在于分割点的寻找和边界的选择。</p>
<ol>
<li><strong>快慢指针</strong>找中点</li>
<li>起始以<strong>空节点</strong>为右侧边界，保证分割点始终置于右半区域。</li>
<li>当下一个节点为右边界时，此时只剩一个节点。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    public <span class="title class_">ListNode</span> <span class="title function_">sortList</span>(<span class="params">ListNode head</span>) &#123;</span><br><span class="line">        <span class="comment">// 空节点也可以视为链表的节点，用来控制左右边界</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">sortList</span>(head, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    public <span class="title class_">ListNode</span> <span class="title function_">sortList</span>(<span class="params">ListNode head, ListNode tail</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 一个元素时（排除tail），即永远取左边的值</span></span><br><span class="line">        <span class="keyword">if</span>(head.<span class="property">next</span> == tail)&#123;</span><br><span class="line">            <span class="comment">// 销毁后继节点</span></span><br><span class="line">            head.<span class="property">next</span> = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 快慢指针找中点</span></span><br><span class="line">        <span class="title class_">ListNode</span> slow, fast;</span><br><span class="line">        slow = fast = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != tail)&#123;</span><br><span class="line">            slow = slow.<span class="property">next</span>;</span><br><span class="line">            fast = fast.<span class="property">next</span>;</span><br><span class="line">            <span class="comment">// 一步一步走，当fast下一步是尾巴时，slow已经是中点了</span></span><br><span class="line">            <span class="keyword">if</span>(fast != tail)&#123;</span><br><span class="line">                fast = fast.<span class="property">next</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title class_">ListNode</span> mid = slow;</span><br><span class="line">        <span class="comment">// 继续分治</span></span><br><span class="line">        <span class="title class_">ListNode</span> l1 = <span class="title function_">sortList</span>(head, mid);</span><br><span class="line">        <span class="title class_">ListNode</span> l2 = <span class="title function_">sortList</span>(mid, tail);</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">merge</span>(l1, l2);</span><br><span class="line">    &#125;</span><br><span class="line">    public <span class="title class_">ListNode</span> <span class="title function_">merge</span>(<span class="params">ListNode l1, ListNode l2</span>)&#123;</span><br><span class="line">        <span class="comment">// 重新建立链表</span></span><br><span class="line">        <span class="title class_">ListNode</span> head = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="title class_">ListNode</span> cur = head, cur1 = l1, cur2 = l2;</span><br><span class="line">        <span class="keyword">while</span>(cur1 != <span class="literal">null</span> &amp;&amp; cur2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur1.<span class="property">val</span> &lt;= cur2.<span class="property">val</span>)&#123;</span><br><span class="line">                cur.<span class="property">next</span> = cur1;</span><br><span class="line">                cur1 = cur1.<span class="property">next</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur.<span class="property">next</span> = cur2;</span><br><span class="line">                cur2 = cur2.<span class="property">next</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.<span class="property">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur1 != <span class="literal">null</span>)&#123;</span><br><span class="line">            cur.<span class="property">next</span> = cur1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur.<span class="property">next</span> = cur2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="链表的归并排序【非递归版】"><a href="#链表的归并排序【非递归版】" class="headerlink" title="链表的归并排序【非递归版】"></a>链表的归并排序【非递归版】</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 本质是“主动的”分治</span></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">sortList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记录链表长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(node != <span class="literal">null</span>)&#123;</span><br><span class="line">            length++;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 构建假头节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummyHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        <span class="comment">// 将整体分割为 n 个长度 1 为的链表开始，一一排序merge构成n个长度2的链表。</span></span><br><span class="line">        <span class="comment">// 然后继续分割 n 个长度为 1*2 的链表（有序），再次merge（一定满足相对顺序）</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> subLen=<span class="number">1</span>; subLen &lt; length; subLen *= <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="comment">// cur为第一个节点</span></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummyHead, cur = dummyHead.next;</span><br><span class="line">            <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">// 拼接出第一个 subLen 链表</span></span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">head1</span> <span class="operator">=</span> cur;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;subLen &amp;&amp; cur.next != <span class="literal">null</span>; i++)&#123;</span><br><span class="line">                    cur = cur.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 先记录第二个的起点</span></span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">head2</span> <span class="operator">=</span> cur.next;</span><br><span class="line">                <span class="comment">// 断开第一个与剩下节点的连接</span></span><br><span class="line">                cur.next = <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">// 拼接第二个 subLen 链表</span></span><br><span class="line">                cur = head2;</span><br><span class="line">                <span class="comment">// cur.next != null 让 cur 至少是最后一个节点</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;subLen &amp;&amp; cur != <span class="literal">null</span> &amp;&amp; cur.next != <span class="literal">null</span>; i++)&#123;</span><br><span class="line">                    cur = cur.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 保留剩下的节点</span></span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">if</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">                    next = cur.next;</span><br><span class="line">                    <span class="comment">// 断开第二个的多余连接</span></span><br><span class="line">                    cur.next = <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// merge 两个有序链表并连接</span></span><br><span class="line">                pre.next = merge(head1, head2);</span><br><span class="line">                <span class="comment">// 移动 pre 到最后一个位置</span></span><br><span class="line">                <span class="keyword">while</span>(pre.next != <span class="literal">null</span>)&#123;</span><br><span class="line">                    pre = pre.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 继续切割下一组</span></span><br><span class="line">                cur = next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// ...重复切割，直到 subLen&gt;=length 完成整个链表的排序。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">merge</span><span class="params">(ListNode l1, ListNode l2)</span>&#123;</span><br><span class="line">        <span class="comment">// 重新建立链表</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head, cur1 = l1, cur2 = l2;</span><br><span class="line">        <span class="keyword">while</span>(cur1 != <span class="literal">null</span> &amp;&amp; cur2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur1.val &lt;= cur2.val)&#123;</span><br><span class="line">                cur.next = cur1;</span><br><span class="line">                cur1 = cur1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur.next = cur2;</span><br><span class="line">                cur2 = cur2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur1 != <span class="literal">null</span>)&#123;</span><br><span class="line">            cur.next = cur1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur.next = cur2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="K-个一组翻转链表"><a href="#K-个一组翻转链表" class="headerlink" title="K 个一组翻转链表"></a>K 个一组翻转链表</h3><p>关键在于如何反转完每一组后，新的尾节点能够接上下一组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseKGroup</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">hair</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        <span class="comment">// 用于连接新的头节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> hair;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">tail</span> <span class="operator">=</span> pre;</span><br><span class="line">            <span class="comment">// 移动到分组的最后一个元素</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;k; i++) &#123;</span><br><span class="line">                tail = tail.next;</span><br><span class="line">                <span class="comment">// 如果变为了空表示长度过短直接返回（始终是连着的）</span></span><br><span class="line">                <span class="keyword">if</span>(tail == <span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> hair.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 保留下一个分组的节点</span></span><br><span class="line">            <span class="comment">// ListNode nex = tail.next;</span></span><br><span class="line">            <span class="comment">// 反转分组链表，接收该分组新的头尾节点（尾节点已连接下一分组）</span></span><br><span class="line">            ListNode[] reverse = myReverse(head, tail);</span><br><span class="line">            head = reverse[<span class="number">0</span>];</span><br><span class="line">            tail = reverse[<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 连接反转后的分组链表</span></span><br><span class="line">            pre.next = head;</span><br><span class="line">            <span class="comment">// pre设为该分组的最后一个节点，用于连接下一分组</span></span><br><span class="line">            pre = tail;</span><br><span class="line">            <span class="comment">// 继续反转</span></span><br><span class="line">            head = tail.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hair.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> ListNode[] myReverse(ListNode head, ListNode tail)&#123;</span><br><span class="line">        <span class="comment">// 起始值顺势连接下一段分组</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> tail.next;</span><br><span class="line">        <span class="comment">// 开始反转</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">// 正常方向 tail 本是尾巴，但是从 head 开始逐一遍历反转连接时，pre 会移动到 tail 的位置。</span></span><br><span class="line">        <span class="keyword">while</span>(pre != tail)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> p.next;</span><br><span class="line">            p.next = pre;</span><br><span class="line">            pre = p;</span><br><span class="line">            p = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>[]&#123;tail, head&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>反转算法：</strong>以尾节点为条件，反转链表。</p>
]]></content>
      <categories>
        <category>每日总结</category>
      </categories>
      <tags>
        <tag>每日总结</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法总结</title>
    <url>/2024/07/22/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="各大排序算法比较"><a href="#各大排序算法比较" class="headerlink" title="各大排序算法比较"></a>各大排序算法比较</h2><table>
<thead>
<tr>
<th>排序算法</th>
<th>时间复杂度（平均）</th>
<th>时间复杂度（最差）</th>
<th>时间复杂度（最好）</th>
<th>空间复杂度</th>
<th>排序方式</th>
<th>稳定性</th>
</tr>
</thead>
<tbody><tr>
<td>冒泡排序</td>
<td>O(n^2^)</td>
<td>O(n^2^)</td>
<td>O(n)</td>
<td>O(1)</td>
<td>比较排序</td>
<td>稳定</td>
</tr>
<tr>
<td>选择排序</td>
<td>O(n^2^)</td>
<td>O(n^2^)</td>
<td>O(n^2^)</td>
<td>O(1)</td>
<td>比较排序</td>
<td>不稳定</td>
</tr>
<tr>
<td>插入排序</td>
<td>O(n^2^)</td>
<td>O(n^2^)</td>
<td>O(n)</td>
<td>O(1)</td>
<td>比较排序</td>
<td>稳定</td>
</tr>
<tr>
<td>希尔排序</td>
<td>O(nlogn)</td>
<td>O(n^2^)</td>
<td>O(nlogn)</td>
<td>O(1)</td>
<td>比较排序</td>
<td>不稳定</td>
</tr>
<tr>
<td>归并排序</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(n)</td>
<td>比较排序</td>
<td>稳定</td>
</tr>
<tr>
<td>快速排序</td>
<td>O(nlogn)</td>
<td>O(n^2^)</td>
<td>O(nlogn)</td>
<td>O(logn)</td>
<td>比较排序</td>
<td>不稳定</td>
</tr>
<tr>
<td>堆排序</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(1)</td>
<td>比较排序</td>
<td>不稳定</td>
</tr>
</tbody></table>
<h3 id="术语解释："><a href="#术语解释：" class="headerlink" title="术语解释："></a><strong>术语解释：</strong></h3><p><strong>内部排序</strong>：所有排序操作都在内存中完成，不需要额外的磁盘或其他存储设备的辅助。这适用于数据量小到足以完全加载到内存中的情况。</p>
<p><strong>外部排序</strong>：当数据量过大，不可能全部加载到内存中时使用。外部排序通常涉及到数据的分区处理，部分数据被暂时存储在外部磁盘等存储设备上。</p>
<p><strong>稳定</strong>：如果 A 原本在 B 前面，而 A&#x3D;B，排序之后 A 仍然在 B 的前面。</p>
<p><strong>不稳定</strong>：如果 A 原本在 B 的前面，而 A&#x3D;B，排序之后 A 可能会出现在 B 的后面。</p>
<blockquote>
<p><strong>是否稳定</strong>决定于，相同的元素在排序后是否还能保持原有位置。</p>
</blockquote>
<h3 id="排序分类"><a href="#排序分类" class="headerlink" title="排序分类"></a>排序分类</h3><p><img src="/../assets/sort2.png" alt="排序算法分类"></p>
<p>比较类又被称为非线性时间排序，因为时间无法突破O(nlogn)</p>
<p>非比较类排序又被称为线性时间排序，可以达到O(n)</p>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>重复遍历要排序序列，依次比较两个元素，一层一层往顶端方向缩短，越小的元素逐渐“浮”到尾端。</p>
<p><strong>算法步骤</strong></p>
<ol>
<li><p>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</p>
</li>
<li><p>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</p>
</li>
<li><p>然后向头部缩短一个位置，即排除当次遍历区间的最后一个数（已经确定）；</p>
</li>
<li><p>重复步骤 1~3，直到排序完成。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 冒泡排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> arr</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] bubbleSort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="comment">// 从 1 开始，因为是往后预知一位来比较</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 设置一个标志，用来确定当次遍历是否已经有序</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = tmp;</span><br><span class="line">                <span class="comment">// 出现乱序</span></span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果已经有序，就退出排序</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过设置 flag ，可以使得最好时间达到 O(n)。</p>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>首先在未排序序列中找到最小的元素，然后放到开头，</p>
<p>再继续从剩下的序列中找到最小的元素，放到开头的下一个，</p>
<p>如此重复。</p>
<p><strong>算法步骤</strong></p>
<ol>
<li>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</li>
<li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li>
<li>重复第 2 步，直到所有元素均排序完毕。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 选择排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> arr</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] selectionSort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 记录最小元素的索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;</span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 排除自己</span></span><br><span class="line">        <span class="keyword">if</span> (minIndex != i) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">            arr[i] = arr[minIndex];</span><br><span class="line">            arr[minIndex] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>为什么说选择排序不稳定？</strong></p>
<p>以 <code>[3a,7,6,5,3b,2]</code> 为例：</p>
<p>当第一层找到最小元素 2 时，因为3a &#x3D; 3b，本应该 3a 应该在前面，却被换到了 3b 后面。</p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>以第一个元素为基准，类似于扑克牌排序，将后面的数往大小往前面插入，当插好最后一张牌的时候就排好序了</p>
<p><strong>算法步骤：</strong></p>
<ol>
<li><p>从第一个元素开始，该元素可以认为已经被排序；</p>
</li>
<li><p>取出下一个元素，在已经排序的元素序列中从后向前扫描；</p>
</li>
<li><p>如果该元素（已排序）大于新元素，将该元素移到下一位置，目的是空出位置；</p>
</li>
<li><p>重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置；</p>
</li>
<li><p>将新元素插入到该位置后；</p>
</li>
<li><p>重复步骤 2~5。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> arr</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] insertionSort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="comment">// 从 1 开始，以第 0 个元素为基准</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 从已排序序列的最后一个开始</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">preIndex</span> <span class="operator">=</span> i - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 保留当前元素，防止位置被覆盖找不到</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        <span class="keyword">while</span> (preIndex &gt;= <span class="number">0</span> &amp;&amp; current &lt; arr[preIndex]) &#123;</span><br><span class="line">            <span class="comment">// 如果扫描到的元素更大，就往后移</span></span><br><span class="line">            arr[preIndex + <span class="number">1</span>] = arr[preIndex];</span><br><span class="line">            preIndex -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遇到小于或等于的元素，直接插入到后一个位置。</span></span><br><span class="line">        arr[preIndex + <span class="number">1</span>] = current;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最好时间为：O(n)，当有序的时候，无需向前扫描。</p>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>其实就是给插入排序做了一个“预处理”。</p>
<p>将一个完整的序列分为 n 个增量间隔子序列，分别进行插入排序，最后增量变为 1，重新形成一个完整的序列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 希尔排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> arr</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] shellSort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> n / <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">while</span> (gap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> gap; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> arr[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">preIndex</span> <span class="operator">=</span> i - gap;</span><br><span class="line">            <span class="comment">// Insertion sort</span></span><br><span class="line">            <span class="keyword">while</span> (preIndex &gt;= <span class="number">0</span> &amp;&amp; arr[preIndex] &gt; current) &#123;</span><br><span class="line">                arr[preIndex + gap] = arr[preIndex];</span><br><span class="line">                preIndex -= gap;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[preIndex + gap] = current;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        gap /= <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>不稳定：相同的元素会破坏顺序</strong></p>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>将序列不断分为两半，直到单位为 1 时开始回溯，将子序列进行有序合并，最后形成一个完整的有序序列。</p>
<blockquote>
<p>为保证有序合并，需单独创建一个 O(logn) 的空间。</p>
</blockquote>
<p><strong>算法步骤：</strong></p>
<ol>
<li><p>如果输入内只有一个元素，则直接返回，否则将序列一分为二；</p>
</li>
<li><p>分别对这两个子序列进行归并排序，使子序列变为有序状态；</p>
</li>
<li><p>设定两个指针，分别指向两个已经排序子序列的起始位置；</p>
</li>
<li><p>比较两个指针所指向的元素，选择相对小的元素放入到合并空间（用于存放排序结果），并移动指针到下一位置；</p>
</li>
<li><p>重复步骤 3 ~ 4 直到某一指针达到序列尾；</p>
</li>
<li><p>将另一序列<strong>剩下的</strong>所有元素直接复制到合并序列。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 归并排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> arr</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] mergeSort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> arr.length / <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span>[] arr_1 = Arrays.copyOfRange(arr, <span class="number">0</span>, middle);</span><br><span class="line">    <span class="type">int</span>[] arr_2 = Arrays.copyOfRange(arr, middle, arr.length);</span><br><span class="line">    <span class="comment">// 分治，回溯时完成排序</span></span><br><span class="line">    <span class="keyword">return</span> merge(mergeSort(arr_1), mergeSort(arr_2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 合并两个数组</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr_1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr_2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> sorted_arr</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] merge(<span class="type">int</span>[] arr_1, <span class="type">int</span>[] arr_2) &#123;</span><br><span class="line">    <span class="comment">// 创建一个能够容纳两个数组合并后所有元素的空间</span></span><br><span class="line">    <span class="type">int</span>[] sorted_arr = <span class="keyword">new</span> <span class="title class_">int</span>[arr_1.length + arr_2.length];</span><br><span class="line">    <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>, idx_1 = <span class="number">0</span>, idx_2 = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 有序合并</span></span><br><span class="line">    <span class="keyword">while</span> (idx_1 &lt; arr_1.length &amp;&amp; idx_2 &lt; arr_2.length) &#123;</span><br><span class="line">        <span class="comment">// 由于arr1属于左半边，arr2属于右半边，如果相同应保证左边元素先加入</span></span><br><span class="line">        <span class="keyword">if</span> (arr_1[idx_1] &lt;= arr_2[idx_2]) &#123;</span><br><span class="line">            sorted_arr[idx] = arr_1[idx_1];</span><br><span class="line">            idx_1 += <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sorted_arr[idx] = arr_2[idx_2];</span><br><span class="line">            idx_2 += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        idx += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 数组1还有元素</span></span><br><span class="line">    <span class="keyword">if</span> (idx_1 &lt; arr_1.length) &#123;</span><br><span class="line">        <span class="keyword">while</span> (idx_1 &lt; arr_1.length) &#123;</span><br><span class="line">            sorted_arr[idx] = arr_1[idx_1];</span><br><span class="line">            idx_1 += <span class="number">1</span>;</span><br><span class="line">            idx += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 数组2还有元素</span></span><br><span class="line">        <span class="keyword">while</span> (idx_2 &lt; arr_2.length) &#123;</span><br><span class="line">            sorted_arr[idx] = arr_2[idx_2];</span><br><span class="line">            idx_2 += <span class="number">1</span>;</span><br><span class="line">            idx += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回本次归并的有序序列。</span></span><br><span class="line">    <span class="keyword">return</span> sorted_arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>和归并排序相似，区别是<strong>在分治的同时</strong>进行<strong>分区</strong>，</p>
<p>而前者是<strong>在回溯的时候</strong>借助额外空间返回有序序列。</p>
<p>先选定一个基准，根据基准分隔成两个部分（分区1 &lt; 分区2），然后在基准的位置分裂进行分区。</p>
<p>只要保证每次分区左边的小于右边的，那么当分裂到 1 个时就排好序了。</p>
<p><strong>算法步骤：</strong></p>
<ol>
<li><p>从序列中<strong>随机</strong>挑出一个元素，做为 “基准”(<code>pivot</code>)；</p>
</li>
<li><p>改变序列分布，将所有比基准值小的元素摆放在基准前面，所有比基准值大的摆在基准的后面（相同的数可以到任一边）。</p>
</li>
<li><p>操作结束之后，该基准就分割了两片区域（分区1 &lt; 分区2）。</p>
</li>
<li><p>分别对两片区域继续进行递归分区。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    <span class="comment">// 默认以尾部为基准</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> array[high];</span><br><span class="line">    <span class="comment">// 从开头开始</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">pointer</span> <span class="operator">=</span> low;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> low; i &lt; high; i++) &#123;</span><br><span class="line">        <span class="comment">// 只要小于等于基准值的就移动到前半部分</span></span><br><span class="line">        <span class="keyword">if</span> (array[i] &lt;= pivot) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> array[i];</span><br><span class="line">            array[i] = array[pointer];</span><br><span class="line">            array[pointer] = temp;</span><br><span class="line">            pointer++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此时 pointer 为基准的分区位置，交换基准值过来</span></span><br><span class="line">    <span class="comment">// 如果默认选取中间值为基准，则无需移动。</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> array[pointer];</span><br><span class="line">    array[pointer] = array[high];</span><br><span class="line">    array[high] = temp;</span><br><span class="line">    <span class="keyword">return</span> pointer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="comment">// 先分区再分治</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">position</span> <span class="operator">=</span> partition(array, low, high);</span><br><span class="line">        quickSort(array, low, position - <span class="number">1</span>);</span><br><span class="line">        quickSort(array, position + <span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>最坏时间原因：当每次分治选取的基准值都是极值（max or min）时，时间等同于O(n^2^)</p>
<p>不稳定的原因：无相对位置的交换</p>
<ol>
<li>分区元素交换</li>
<li>基准值位置交换</li>
</ol>
<p>可能存在比基准值大的数，被交换到了尾部</p>
<p>如：<code>[1,2,3,4,6a,7,8,6b,5]</code></p>
<p>在确定了左半区（&lt;&#x3D;5）时，需要移动 5 到分区位置，此时 6a 被交换到了原先 5 的位置</p>
<p><code>[1,2,3,4,5,7,8,6b,6a]</code></p>
</blockquote>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>关键在于建立大顶堆，将顶部和最后一个元素交换，再重新堆化，重复取出最大元素放在尾部，直到只剩一个元素即排序完成。</p>
<ol>
<li><p>将初始待排序列 (R1,R2,…,Rn) 构建成大顶堆，此堆为初始的无序区；</p>
</li>
<li><p>将堆顶元素 R1 与最后一个元素 Rn 交换，此时得到新的无序区 (R1,R2,…,Rn−1) 和新的有序区 Rn, 且满足 Ri⩽Rn(i∈1,2,…,n−1)；</p>
</li>
<li><p>由于交换后新的堆顶 R1 可能违反堆的性质，因此需要对当前无序区 (R1,R2,…,Rn−1) 调整为新堆，然后再次将 R1 与无序区最后一个元素交换，得到新的无序区 (R1,R2,…,Rn−2) 和新的有序区 (Rn−1,Rn)。不断重复此过程直到有序区的元素个数为 n−1，则整个排序过程完成。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 交换</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建大顶堆</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">buildMaxHeap</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="comment">// 从最后一个非叶子结点开始，由底向上选举最大值。</span></span><br><span class="line">    <span class="comment">// 如果从上往下，无法确定顶部和隔层哪个更大，应该从底部一层一层往上。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arr.length / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        heapify(arr, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 堆化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> heapLen)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 选取最大值，构建大顶堆</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">largest</span> <span class="operator">=</span> i;</span><br><span class="line">    <span class="keyword">if</span> (right &lt; heapLen &amp;&amp; arr[right] &gt; arr[largest]) &#123;</span><br><span class="line">        largest = right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; heapLen &amp;&amp; arr[left] &gt; arr[largest]) &#123;</span><br><span class="line">        largest = left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">        swap(arr, largest, i);</span><br><span class="line">        <span class="comment">// 逐层选举最大值</span></span><br><span class="line">        heapify(arr, largest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 堆排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] heapSort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="comment">// 堆的线性长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">heapLen</span> <span class="operator">=</span> arr.length;</span><br><span class="line">    <span class="comment">// 构建大顶堆</span></span><br><span class="line">    buildMaxHeap(arr);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arr.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 逐一移动最大到数组尾部</span></span><br><span class="line">        swap(arr, <span class="number">0</span>, i);</span><br><span class="line">        <span class="comment">// 缩减堆空间，重新从顶向下堆化</span></span><br><span class="line">        heapLen -= <span class="number">1</span>;</span><br><span class="line">        heapify(arr, <span class="number">0</span>, heapLen);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>不稳定：因为在构建堆的时候比较最大值和相对位置无关，并且还有可能分在了不同子树上</strong></p>
]]></content>
      <categories>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>每日杂记 day7</title>
    <url>/2024/07/20/2024-7-20/</url>
    <content><![CDATA[<h2 id="并发常见面试题"><a href="#并发常见面试题" class="headerlink" title="并发常见面试题"></a>并发常见面试题</h2><h3 id="什么是进程、线程"><a href="#什么是进程、线程" class="headerlink" title="什么是进程、线程"></a>什么是进程、线程</h3><h3 id="用户线程和内核线程"><a href="#用户线程和内核线程" class="headerlink" title="用户线程和内核线程"></a>用户线程和内核线程</h3><h3 id="线程和进程的区别"><a href="#线程和进程的区别" class="headerlink" title="线程和进程的区别"></a>线程和进程的区别</h3><p><img src="/../assets/java-runtime-data-areas-jdk1.8.png" alt="Java 运行时数据区域（JDK1.8 之后）"></p>
<h3 id="程序计数器和栈信息为什么是私有的"><a href="#程序计数器和栈信息为什么是私有的" class="headerlink" title="程序计数器和栈信息为什么是私有的"></a>程序计数器和栈信息为什么是私有的</h3><h3 id="线程的生命周期切换的流程是？"><a href="#线程的生命周期切换的流程是？" class="headerlink" title="线程的生命周期切换的流程是？"></a>线程的生命周期切换的流程是？</h3><p><img src="/../assets/640.png" alt="Java 线程状态变迁图"></p>
<h3 id="线程之间是如何切换的？"><a href="#线程之间是如何切换的？" class="headerlink" title="线程之间是如何切换的？"></a>线程之间是如何切换的？</h3><p>时间分片，上下文切换。</p>
<h3 id="什么是上下文切换"><a href="#什么是上下文切换" class="headerlink" title="什么是上下文切换"></a>什么是上下文切换</h3><h3 id="sleep和wait的区别"><a href="#sleep和wait的区别" class="headerlink" title="sleep和wait的区别"></a>sleep和wait的区别</h3><ol>
<li>锁</li>
<li>目的</li>
<li>苏醒时间</li>
<li>挂载对象</li>
</ol>
<h3 id="为什么要使用多线程"><a href="#为什么要使用多线程" class="headerlink" title="为什么要使用多线程?"></a>为什么要使用多线程?</h3><ol>
<li>计算机底层：多核 CPU 时代意味着多个线程可以同时运行</li>
<li>应用环境趋势</li>
</ol>
<h3 id="Java-的线程调度方式"><a href="#Java-的线程调度方式" class="headerlink" title="Java 的线程调度方式"></a>Java 的线程调度方式</h3><p>操作系统：</p>
<ol>
<li>抢占式调度</li>
<li>协同式调度</li>
</ol>
<h3 id="单核CPU上多个线程效率一定会高吗"><a href="#单核CPU上多个线程效率一定会高吗" class="headerlink" title="单核CPU上多个线程效率一定会高吗"></a>单核CPU上多个线程效率一定会高吗</h3><ol>
<li>CPU密集型</li>
<li>IO密集型，利用响应时间</li>
</ol>
<h3 id="多线程会带来什么问题？"><a href="#多线程会带来什么问题？" class="headerlink" title="多线程会带来什么问题？"></a>多线程会带来什么问题？</h3><ol>
<li>内存泄漏</li>
<li>死锁</li>
<li>线程不安全</li>
</ol>
<h3 id="什么是死锁？产生的必要条件？"><a href="#什么是死锁？产生的必要条件？" class="headerlink" title="什么是死锁？产生的必要条件？"></a>什么是死锁？产生的必要条件？</h3><p>必要条件</p>
<ol>
<li>互斥条件</li>
<li>请求与保持</li>
<li>不剥夺</li>
<li>循环等待</li>
</ol>
<h3 id="如何破坏死锁？"><a href="#如何破坏死锁？" class="headerlink" title="如何破坏死锁？"></a>如何破坏死锁？</h3><p>破坏必要条件</p>
<p><strong>如何避免死锁</strong>：银行家算法</p>
<h3 id="双检锁单例为什么需要-volatile-关键字？"><a href="#双检锁单例为什么需要-volatile-关键字？" class="headerlink" title="双检锁单例为什么需要 volatile 关键字？"></a>双检锁单例为什么需要 volatile 关键字？</h3><h3 id="乐观锁和悲观锁，区别？"><a href="#乐观锁和悲观锁，区别？" class="headerlink" title="乐观锁和悲观锁，区别？"></a>乐观锁和悲观锁，区别？</h3><h3 id="CAS规则，ABA问题"><a href="#CAS规则，ABA问题" class="headerlink" title="CAS规则，ABA问题"></a>CAS规则，ABA问题</h3><p><strong>如何做到多个变量的原子性</strong>：引用类型CAS</p>
<h2 id="多益网络笔试题"><a href="#多益网络笔试题" class="headerlink" title="多益网络笔试题"></a>多益网络笔试题</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>哈希表，二叉树，链表</p>
<h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><p>希尔排序、堆排序、选择排序、插入排序。</p>
<h3 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h3><ol>
<li>一个 m*n 的矩阵，从左到右和从上到下都是递增的，判断某个数是否存在</li>
</ol>
<p>普通思路：两层遍历，一一比对。</p>
<p>利用数据变化特性：</p>
<p>从左上角开始，可以利用递增的特性往前和往后，但是<strong>无法具体确定横向还是纵向移动。</strong></p>
<p>而从右上角开始，就有唯一确定的移动方向：小于即左移，大于即下移。</p>
<ol start="2">
<li>螺旋遍历矩阵</li>
</ol>
<p>应该是边界与边界的控制问题，但是没解决。</p>
]]></content>
      <categories>
        <category>每日总结</category>
      </categories>
      <tags>
        <tag>每日总结</tag>
      </tags>
  </entry>
  <entry>
    <title>每日杂记 day6</title>
    <url>/2024/07/19/2024-7-19/</url>
    <content><![CDATA[<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>概念 -&gt; 使用 -&gt; 同步 -&gt; 锁 -&gt; 线程池 -&gt; 并发</p>
<p>多线程的本质是：多个任务“快速”的轮流进行。</p>
<p>进程：一个任务的基本单位，线程是CPU调度的基本单位。</p>
<p><strong>特性区别：</strong></p>
<p><strong>进程</strong></p>
<ol>
<li>资源独立</li>
<li>开销大</li>
<li>稳定性高</li>
<li>通信慢</li>
</ol>
<p><strong>线程</strong></p>
<ol>
<li>资源共享，局部变量不共享。</li>
<li>开销小</li>
<li>稳定性差</li>
</ol>
<p>使用线程的方法</p>
<ol>
<li>创建线程<ol>
<li>继承 Thread 类</li>
<li>new 匿名内部类</li>
<li>传入 Runnable 接口</li>
</ol>
</li>
<li>start 方法开启线程</li>
</ol>
<p>通过 join 方法还可以加入其他线程，其他线程需要等待该线程才能结束。</p>
<p>通过 interrupt 方法可以中断线程，但是这里仅是改变一个状态量，实际结束线程需通过 Thread 提供的方法 isInterrupted() 方法检测线程状态。</p>
<blockquote>
<p>如果线程处于等待状态，interrupt 会抛异常，导致状态更改失败。</p>
<p>等待状态：</p>
<ul>
<li>当前线程正在 sleep</li>
<li>当前线程正在等待其他 join 的线程</li>
</ul>
</blockquote>
<p>线程的状态分为 new -&gt; running, waiting -&gt; interrupted。</p>
<p><strong>守护线程</strong></p>
<p>“守护”其他所有线程的线程。</p>
<p>&#x3D;&#x3D;只有所有线程结束，它才会停止（包括 Main JVM主线程）&#x3D;&#x3D;</p>
<p><code>setDeamon(true)</code> 即可将线程设置为守护线程。</p>
<h3 id="同步问题"><a href="#同步问题" class="headerlink" title="同步问题"></a><strong>同步问题</strong></h3><p>由于多线程是异步操作，如果同时对变量进行操作，会有状态竞争问题。</p>
<p>因此需要同步这些操作：一个一个操作。</p>
<p>通过 synchronized 关键字、原子操作、Atomic 类都可以做到同步操作。</p>
<p><strong>协调问题</strong></p>
<p>有时候一个线程可能和另一个线程相关，但又被限制为了同步操作，导致这个方法不能结束另一个方法又不能执行，这被称为死锁。</p>
<p>这时可以通过 wait() 方法使当前线程暂时休眠，等另一个线程执行完对应任务后通过 <code>notifyAll()</code> 来唤醒它，最后达成同步。</p>
<p><strong>锁除了 synchronized 外，还有一个专门的包专门提供锁。</strong></p>
<ol>
<li>ReentrantLock 可重入锁</li>
<li>ReadWriteLock 读写锁</li>
<li>StampedLock 读写锁的优化版</li>
<li>Semaphore 信号量</li>
</ol>
<p>除此之外，还有一些个专门的线程安全集合类</p>
<ol>
<li>CopyOnWriteArrayList</li>
<li>ArrayBlockingQueue</li>
<li>等等</li>
</ol>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a><strong>线程池</strong></h3><p>因为线程的创建需要资源和时间，频繁的创建和销毁会浪费大量的性能。</p>
<p>因此就可以创建线程池，存储创建过的线程，复用线程。</p>
<p>创建方式：</p>
<p>大多都是通过 Executors 的方法创建</p>
<ol>
<li>newFixedThreadPool</li>
<li>newScheduledThreadPool</li>
</ol>
<p>Schedule 表示定时操作</p>
<p>又分为</p>
<ol>
<li>schedule 定时</li>
<li>scheduleAtFixedRate 以固定频率定时</li>
<li>scheduleWithFixedDelay 以固定间隔定时</li>
</ol>
<h3 id="并发操作"><a href="#并发操作" class="headerlink" title="并发操作"></a>并发操作</h3><p>普通的 Thread 创建子线程只能执行操作，而不能获取返回值。</p>
<p>因此 Future 就出场了，可以获得返回值。</p>
<p>但是其 <code>get()</code> 操作确实阻塞的。</p>
<p>这时候 CompletableFuture 又出现了，提供异步回调的方式。</p>
<p>同时还有多种方法实现“并行”和“串行”的并发操作，非常好用。</p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="轮转数组"><a href="#轮转数组" class="headerlink" title="轮转数组"></a><strong>轮转数组</strong></h3><p>通过分析轮转后数组中各元素的位置变化。</p>
<p>首先发现尾部的数组会变到数组的头部（首位翻转数组）</p>
<p>同时还保持着原有的顺序（切割数组，将数组各部分翻转回来）</p>
<p>最终实现了<strong>原地</strong>转了过去。</p>
<h3 id="除自身以外数组的乘积"><a href="#除自身以外数组的乘积" class="headerlink" title="除自身以外数组的乘积"></a><strong>除自身以外数组的乘积</strong></h3><p><strong>题目要求不能用除法</strong></p>
<p>不然就是一个求积，然后除以当前元素得到结果了。【O(n), O(1)空间爽歪歪！】</p>
<p>常规思路就是除去当前位置，左右求积然后再积，O(n^2^)</p>
<p>略微思考可以发现左右求积的过程都是【无后效性】的，即一个状态是另一个状态的基础。</p>
<p>没错！！动态规划，提前求出每个状态的前后累乘积。</p>
<p>那么在遍历求结果时，只需要 O(1) 的时间就可以得到结果了，最终 O(n)。</p>
<h3 id="缺失的第一个正数"><a href="#缺失的第一个正数" class="headerlink" title="缺失的第一个正数"></a><strong>缺失的第一个正数</strong></h3><p><strong>给定一个数组，要求找出数组确实的第一个正整数</strong></p>
<p>常规思路：建立哈希表（优化查找效率），然后从 1 开始遍历，第一个不存在的即为答案。</p>
<p>深度思考：</p>
<p>结果要么属于 [1, N]，要么就是 N+1。</p>
<p>因为数组只有两种情况，要么[1, N]刚好塞满，要么中间差了谁，被区间外的数占了。</p>
<blockquote>
<p>不要专注于什么没有，而是要看什么已经有了。</p>
</blockquote>
<p>同时，题目要求：<strong>必须使用 O(1) 的空间</strong>。</p>
<p>那建立哈希表不是泡汤了？</p>
<p>错！！既然结果属于 [1, N] 就让数组本身成为哈希表。</p>
<p><strong>核心：</strong>通过遍历数组标记索引为 [0, N-1] 的位置，第一个没有被标记的位置 + 1 即为结果。</p>
<blockquote>
<p>怎么标记不影响原数组呢？</p>
<p>设为负数</p>
<p>本身就是负数呢？</p>
<p>设为N+1，不干扰到索引范围内的数。</p>
</blockquote>
<h3 id="矩阵置零"><a href="#矩阵置零" class="headerlink" title="矩阵置零"></a><strong>矩阵置零</strong></h3><p><strong>要求使用额外常数空间 O(1)</strong></p>
<p>只要某个位置存在 0，就将整行和整列变为 0。</p>
<blockquote>
<p>摆脱固定思维：真的一行一列遍历赋值为0。。。O(n^3^)</p>
</blockquote>
<p>O(M+N) ：分别建立行和列的数组，标记出现 0 的行或列，遍历整个矩阵，只要当前行或列存在 0，当前元素就赋值为 0，时间：O(n^2^)。</p>
<p>O(2)：从矩阵<strong>本身</strong>挑出第一行和第一列作为标记数组，并且设置 flagRow，flagCol 两个标记变量标记原第一行或列是否存在 0。</p>
<p><strong>和上一题很像，以自身为空间</strong></p>
<p>O(1)：省去 flagRow，用第一列的第一个元素代替标记。</p>
<blockquote>
<p>在用第一行或列作为标记数组，并将存在 0 的行或列对应位置赋值为 0，并不影响原位置元素。</p>
<p>因为如果这一行或列存在 0 的话，它本身就应该变为 0。</p>
</blockquote>
<h3 id="旋转图像"><a href="#旋转图像" class="headerlink" title="旋转图像"></a><strong>旋转图像</strong></h3><p>n * n 矩阵顺时针旋转。</p>
<p><strong>顺时针旋转 &#x3D; （上下）左右翻转 + （负）正时针对角线交换</strong></p>
<p><strong>对角线交换公式（正方形）</strong></p>
<p><code>X(i, j) =&gt; X(n-1-j, n-1-i)</code> n为边长。</p>
<p>位置交换，并转化为长度的“找补”。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n-<span class="number">1</span>-i; j++) &#123;</span><br><span class="line">                swap(matrix, i, j, n-<span class="number">1</span>-j, n-<span class="number">1</span>-i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>每日总结</category>
      </categories>
      <tags>
        <tag>每日总结</tag>
      </tags>
  </entry>
  <entry>
    <title>每日杂记 day5</title>
    <url>/2024/07/18/2024-7-18/</url>
    <content><![CDATA[<h2 id="八股"><a href="#八股" class="headerlink" title="八股"></a>八股</h2><h3 id="HashMap-实现原理"><a href="#HashMap-实现原理" class="headerlink" title="HashMap 实现原理"></a>HashMap 实现原理</h3><h3 id="hashmap和hashtable的区别，为什么不使用hashtable"><a href="#hashmap和hashtable的区别，为什么不使用hashtable" class="headerlink" title="hashmap和hashtable的区别，为什么不使用hashtable"></a>hashmap和hashtable的区别，为什么不使用hashtable</h3><ol>
<li>继承类不同</li>
<li>null 值的允许规则不同</li>
<li>hashtable是线程安全的</li>
<li>遍历方式</li>
<li>容量分配</li>
<li>hash计算方式</li>
</ol>
<h3 id="Class-的获取方式"><a href="#Class-的获取方式" class="headerlink" title="Class 的获取方式"></a>Class 的获取方式</h3><h3 id="Field，Method，Constructor的使用方式"><a href="#Field，Method，Constructor的使用方式" class="headerlink" title="Field，Method，Constructor的使用方式"></a>Field，Method，Constructor的使用方式</h3><ul>
<li>自身属性</li>
<li>调用API</li>
</ul>
<h3 id="Method-的反射多态调用"><a href="#Method-的反射多态调用" class="headerlink" title="Method 的反射多态调用"></a>Method 的反射多态调用</h3>]]></content>
      <categories>
        <category>每日总结</category>
      </categories>
      <tags>
        <tag>每日总结</tag>
      </tags>
  </entry>
  <entry>
    <title>每日杂记 day4</title>
    <url>/2024/07/17/2024-7-17/</url>
    <content><![CDATA[<p>。。昨天被几道算法题弄的迷失了方向</p>
<hr>
<h2 id="八股"><a href="#八股" class="headerlink" title="八股"></a>八股</h2><h3 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h3><h4 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h4><p>控制反转，将创建、管理对象的权力交给第三方容器，在开发时只需要注入对象就可以直接使用，不需要关心复杂的依赖关系。</p>
<h4 id="Component-和-Bean-注解的区别"><a href="#Component-和-Bean-注解的区别" class="headerlink" title="Component 和 Bean 注解的区别"></a>Component 和 Bean 注解的区别</h4><p>Component 作用于类，通过 ComponentScan 指明路径可以将标注的类转化为 Spring 管理的 Bean。</p>
<p>Bean 作用于方法，将方法的返回值作为一个 Spring Bean，生效的前提是所在的类被声明为了 bean，如 Configuration；</p>
<p>Bean 比 Component 的自定义性能力强，比如再需要引入第三方库的依赖时，可以声明一个 Bean 标注的方法来实现。</p>
<h4 id="如何获得-Bean"><a href="#如何获得-Bean" class="headerlink" title="如何获得 Bean"></a>如何获得 Bean</h4><ol>
<li>通过 Spring 容器上下文来手动获取 bean</li>
<li>通过注解的方式来自动注入 bean<ol>
<li>Autowired</li>
<li>Resource</li>
<li>Inject</li>
</ol>
</li>
</ol>
<h4 id="autowired-和-resource-的区别"><a href="#autowired-和-resource-的区别" class="headerlink" title="autowired 和 resource 的区别"></a>autowired 和 resource 的区别</h4><p>前者是 Spring 提供的注解，后者是 jdk 提供的。</p>
<p>前者通过类型获取 bean，如果同一个类型有多个实现类会会按照名称来获取。这时候可以借助 Qualified 注解声明需要注入类的名称。</p>
<p>后者默认通过名称获取 bean，如果无法匹配就会根据类型的方式来获取。</p>
<blockquote>
<p>如果也有多个实现类呢？</p>
<p>那 resource 就要结合名称来获取了。</p>
</blockquote>
<p>Resource注解有两个属性分别是 name，type。</p>
<p>指定哪一个，默认获取方式就是哪一个。</p>
<p>如果都指定，就结合两个属性进行获取。</p>
<p>:question: autowired还支持在构造函数上在使用？Resource 只支持在字段和方法上。</p>
<h4 id="Bean-的作用域有哪些？"><a href="#Bean-的作用域有哪些？" class="headerlink" title="Bean 的作用域有哪些？"></a>Bean 的作用域有哪些？</h4><p>主要有：</p>
<ul>
<li>singleton，单例模式</li>
<li>prototype，每次获取的都是不同的实例</li>
<li>request：每次 HTTP 请求都会产生一个 bean，只有在 web 应用中可以用。</li>
<li>session，类似request</li>
</ul>
<p><strong>如何配置</strong></p>
<p>通过 @Scope 注解</p>
<h4 id="Bean-是线程安全的吗？"><a href="#Bean-是线程安全的吗？" class="headerlink" title="Bean 是线程安全的吗？"></a>Bean 是线程安全的吗？</h4><p>在单例模式下，bean 线程不安全，如果它是有状态的，多线程修改会存在资源竞争问题。</p>
<h4 id="Bean-的生命周期"><a href="#Bean-的生命周期" class="headerlink" title="Bean 的生命周期"></a>Bean 的生命周期</h4><p>实例化 -&gt; 属性赋值 -&gt; 初始化 -&gt; 销毁</p>
<p><img src="/../assets/spring-bean-lifestyle.png" alt="img"></p>
<h4 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h4><p>面向切面编程，是一个对横切关注点的增强，抽象出公共业务，降低不同模块间的耦合度。</p>
<p><strong>实现原理</strong>就是动态代理，如果要代理的对象实现了接口就使用 jdk 的 proxy 创建代理，没有接口就用第三方库 cglib 进行动态代理。</p>
<blockquote>
<p>jdk proxy 和 cglib 的区别？</p>
<p><strong>JDK 动态代理只能代理实现了接口的类或者直接代理接口，而 CGLIB 可以代理未实现任何接口的类。</strong> 另外， CGLIB 动态代理是通过生成一个被代理类的<strong>子类</strong>来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法。</p>
<p>就二者的<strong>效率</strong>来说，大部分情况都是 JDK 动态代理更优秀，随着 JDK 版本的升级，这个优势更加明显</p>
<p>和 OOP 的区别：</p>
<p>oop 是封装为对象，实现代码的模块化和层次化。</p>
</blockquote>
<h4 id="Spring-aop-和-aspectj-aop-的区别"><a href="#Spring-aop-和-aspectj-aop-的区别" class="headerlink" title="Spring aop 和 aspectj aop 的区别"></a>Spring aop 和 aspectj aop 的区别</h4><p>前者是运行时增强，后者是编译期增强，将增强的代码写入字节码中，效率更高。</p>
<h4 id="aop-的通知类型有哪些？"><a href="#aop-的通知类型有哪些？" class="headerlink" title="aop 的通知类型有哪些？"></a>aop 的通知类型有哪些？</h4><ol>
<li><p>before 方法执行前</p>
</li>
<li><p>after 方法执行后</p>
</li>
<li><p>afterReturning 方法返回结果后</p>
</li>
<li><p>afterThrowing 方法抛出异常后</p>
</li>
<li><p>around 编程式的控制目标对象的调用，可以直接拿到目标对象和要执行的方法。</p>
</li>
</ol>
<h4 id="多个切面如何控制执行顺序"><a href="#多个切面如何控制执行顺序" class="headerlink" title="多个切面如何控制执行顺序"></a>多个切面如何控制执行顺序</h4><p>通过 @Order 注解，值越小优先级越高</p>
<h4 id="aop-应用场景"><a href="#aop-应用场景" class="headerlink" title="aop 应用场景"></a>aop 应用场景</h4><ol>
<li>日志记录</li>
<li>事务管理</li>
<li>权限控制</li>
<li>接口限流等</li>
</ol>
<h3 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h3><p>将业务逻辑、数据、界面分离来组织代码</p>
<p><strong>核心组件：</strong></p>
<p>DispatcherServlet：核心处理器，复杂接受请求、分发、给予客户端响应。</p>
<p>HandlerMapping：根据 Url 匹配查找能处理的 Handler，并且将拦截器和 Handler 一起封装。</p>
<p>HandlerAdapter：根据 handlermapping 找到的Handler，去适配执行对应的Handler</p>
<p>Handler：实际处理的处理器</p>
<p>ViewResovler：视图解析器，根据 Handler 返回的逻辑视图，解析渲染界面，并传递给 dispatcherservlet 响应给客户端。</p>
<p><img src="/../assets/de6d2b213f112297298f3e223bf08f28.png" alt="img"></p>
<h4 id="如果有多个拦截了异常类（或父类）的统一异常处理通知，会都执行吗？"><a href="#如果有多个拦截了异常类（或父类）的统一异常处理通知，会都执行吗？" class="headerlink" title="如果有多个拦截了异常类（或父类）的统一异常处理通知，会都执行吗？"></a>如果有多个拦截了异常类（或父类）的统一异常处理通知，会都执行吗？</h4><p>首先会根据拦截异常类型，添加所有符合类型（包括父类）异常处理，最后根据匹配程度选取优先级最高的 1 个。</p>
<h4 id="Spring-的三级缓存"><a href="#Spring-的三级缓存" class="headerlink" title="Spring 的三级缓存"></a>Spring 的三级缓存</h4><p>一级缓存：存放最终创建完成的 bean</p>
<p>二级缓存：存放刚刚实例化后的 bean 或 代理对象。</p>
<p>三级缓存，存放对象工厂，可以生成原始 Bean 或代理对象，只对单例 bean 生效，多例直接生成新的即可。</p>
<p><strong>获取顺序：</strong>一级 -&gt; 二级 -&gt; 三级</p>
<h3 id="Spring-事务"><a href="#Spring-事务" class="headerlink" title="Spring 事务"></a>Spring 事务</h3><p>编程式事务，通过 TransactionTemplate 或 TransactionManager 手动管理事务。</p>
<p>声明式事务，基于 @Transactional 注解通过 aop 实现事务。</p>
<h4 id="TransactionManager-使用"><a href="#TransactionManager-使用" class="headerlink" title="TransactionManager 使用"></a>TransactionManager 使用</h4><ol>
<li>注入 PlatformTransactionManager。</li>
<li>定义事务信息 TransactionDefinition</li>
<li>得到事务运行状态 TransactionStatus</li>
<li>修改状态<ol>
<li>commit</li>
<li>rollback</li>
</ol>
</li>
</ol>
<h4 id="事务的传播行为"><a href="#事务的传播行为" class="headerlink" title="事务的传播行为"></a>事务的传播行为</h4><ol>
<li>RRQUIRED 加入事务，没有则新建，是默认的行为</li>
<li>REQUIRES_NEW 新建事务</li>
<li>REQUIRED_NESTED 嵌套事务</li>
<li>MANDATORY 强制事务，没有则抛出异常</li>
</ol>
<p>新建事务外部回滚不会影响内部新建的事务，但是如果内存回滚并抛出了相应异常，外部也会回滚，因为会捕捉到异常。</p>
<p>嵌套事务如果外部回滚，其也会回滚；反之不会。</p>
<h4 id="事务的隔离"><a href="#事务的隔离" class="headerlink" title="事务的隔离"></a>事务的隔离</h4><p>主要分为</p>
<ol>
<li>READ_COMMITED 只能读取事务提交后的值。</li>
<li>REPETABLE_READ 允许重复读。</li>
</ol>
<h4 id="Transaction-默认回滚策略"><a href="#Transaction-默认回滚策略" class="headerlink" title="@Transaction 默认回滚策略"></a>@Transaction 默认回滚策略</h4><p>runtimeException ，而checked exception 不会回滚</p>
<h4 id="只读事务"><a href="#只读事务" class="headerlink" title="只读事务"></a>只读事务</h4><p>一组查询语句应该声明为只读事务。</p>
<p>MySQL 默认对每一个新建立的连接都启用了<code>autocommit</code>模式</p>
<p>MySQL 内部每一条 sql 语句都会新建一个事务，相互之间是独立的，执行时间不同就有可能同个值读取不一致问题，造成读取逻辑错乱。</p>
<p>同时声明为只读事务，还可以优化性能。</p>
<h4 id="事务的-ACID-特性"><a href="#事务的-ACID-特性" class="headerlink" title="事务的 ACID 特性"></a>事务的 ACID 特性</h4><p>A：原子性，C：一致性，I：隔离性，D：持久性</p>
<p>A, I, D -&gt; C</p>
<h2 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h2><h3 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a>最大子数组和</h3><p><strong>普通解法：</strong></p>
<p>遍历两两区间，通过 sum 记录所有子数组，并保留 max。</p>
<p><strong>动态规划解法：</strong></p>
<p>将问题转化为 n 个“无后效性”问题：即前一个问题的结果与后一个问题无关。</p>
<p>再找到“状态方程”的变换条件：由于连续，后一个问题的最大子数组和一定是基于前一个问题的和。</p>
<ul>
<li>小于 0 直接“中断”，sum 从头算起。</li>
<li>大于 0 继续计算。</li>
</ul>
<p>最后遍历完所有问题，得到最终结果 max。</p>
<h3 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a>合并区间</h3><p>将能够相接的区间合并在一起：相接即区间有重合部分。</p>
<p><strong>关键在于排序</strong>，因为能够合并的区间，一定在相邻位置。</p>
<p><strong>双指针建立左右边界</strong>，同时需要记录最大右边界。</p>
<p><strong>移动条件</strong>：只要区间 x 的左边界&lt;=就表示有重合部分，右边界继续扩张；否则重新记录左边界。</p>
<p>最后返回所有的区间结果。</p>
]]></content>
      <categories>
        <category>每日总结</category>
      </categories>
      <tags>
        <tag>每日总结</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL(三) 分组函数</title>
    <url>/2024/07/15/MySQL-%E4%B8%89-%E5%88%86%E7%BB%84%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>区别于“数据处理函数”：</p>
<p><strong>分组函数是多行函数</strong>，多行数据产生一个结果 (如果没有 group by)</p>
<blockquote>
<p>没加 group by 即一整张表就是一组。</p>
</blockquote>
<p><strong>数据处理函数是单行函数</strong>，一行数据一个结果。</p>
<span id="more"></span>

<h2 id="分组函数"><a href="#分组函数" class="headerlink" title="分组函数"></a>分组函数</h2><p>分组函数共有：max, min, avg, count, sum。</p>
<p><strong>常见问题</strong></p>
<p>Q: <strong><code>count(*)</code> 和<code>count(字段)</code> 的区别？&#96;</strong></p>
<p>A: 前者是统计所有字段不全为 NULL 的数量，即整张表的行数；后者是统计该字段不为空的个数。</p>
<p>Q: <strong>分组函数不能使用在 where 条件中</strong></p>
<p>A: 因为分组函数是根据查询结果计算的，如果加在 where 中就会不断改变，无法计算。</p>
<p><strong>注：</strong>多行函数是自动忽略 NULL 的，因为是从所有行中统计出结果。</p>
<h3 id="group-by"><a href="#group-by" class="headerlink" title="group by"></a>group by</h3><p>将查询结果按照某个字段分组，或者多个字段联合分组，在 where 后执行。</p>
<p><strong>经过分组后 sql 语句，只能 select 分组函数和分组字段</strong></p>
<p>因为分组后，其他数据“糅合”在一起了，无法正常显示。</p>
<h3 id="having"><a href="#having" class="headerlink" title="having"></a>having</h3><p>在分组后，对分组数据进行筛选。</p>
<blockquote>
<p>分组数据：分组函数产生的数据，或分组字段。</p>
<p>建议只有涉及到分组数据的筛选采用 having，其他用 where 提前过滤掉，保证查询效率。</p>
</blockquote>
<p><strong>区别举例：</strong>查询部门为 job 的平均薪资数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 低效用法</span><br><span class="line"><span class="keyword">select</span> job,<span class="built_in">avg</span>(sal) <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> job <span class="keyword">having</span> job<span class="operator">=</span><span class="string">&#x27;SALESMAN&#x27;</span>;</span><br><span class="line"># 高效用法</span><br><span class="line"><span class="keyword">select</span> job,<span class="built_in">avg</span>(sal) <span class="keyword">from</span> emp <span class="keyword">where</span> job<span class="operator">=</span><span class="string">&#x27;SALESMAN&#x27;</span> <span class="keyword">group</span> <span class="keyword">by</span> job;</span><br></pre></td></tr></table></figure>

<h3 id="组内排序"><a href="#组内排序" class="headerlink" title="组内排序"></a>组内排序</h3><h4 id="substring-index"><a href="#substring-index" class="headerlink" title="substring_index"></a>substring_index</h4><p>按分隔符分割。</p>
<p><strong>语法格式：</strong></p>
<p><code>substring_index(字符串, 分隔符, 子串数量)</code></p>
<h4 id="group-concat"><a href="#group-concat" class="headerlink" title="group_concat"></a>group_concat</h4><p>将分组后的同组数据进行拼接。</p>
<p><strong>语法格式：</strong></p>
<p><code>group_concat(字段 [order by ...])</code> 可选是否排序</p>
<p><strong>注意：</strong>和 group by 后的 select 语句相反，这里不应该出现分组函数和分组字段，因为同组的数据结果相同。</p>
<blockquote>
<p>但是 MySQL 是允许的。</p>
</blockquote>
<p><strong>联合使用举例：</strong>找出每个工作岗位的工资排名在前两名的员工姓名。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 先按工资对组内数据排序拼接，再按“，”分割出前两位</span><br><span class="line"><span class="keyword">select</span> job,</span><br><span class="line">substring_index(</span><br><span class="line">    group_concat(job <span class="keyword">order</span> <span class="keyword">by</span> sal), </span><br><span class="line">    &quot;,&quot;,<span class="number">2</span>) <span class="keyword">as</span> top2 </span><br><span class="line"><span class="keyword">from</span> emp </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> job;</span><br></pre></td></tr></table></figure>

<p><img src="/../assets/image-20240715225035606.png" alt="image-20240715225035606"></p>
<h2 id="语句执行顺序"><a href="#语句执行顺序" class="headerlink" title="语句执行顺序"></a>语句执行顺序</h2><p>一个相对完整的 sql 语句的执行顺序如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> ... 		# <span class="number">5</span></span><br><span class="line"><span class="keyword">from</span> ...		# <span class="number">1</span></span><br><span class="line"><span class="keyword">where</span> ...		# <span class="number">2</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> ...	# <span class="number">3</span></span><br><span class="line"><span class="keyword">having</span> ...		# <span class="number">4</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> ...	# <span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>可以参考这个顺序对 sql 语句进行优化。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>每日杂记 day3</title>
    <url>/2024/07/15/2024-7-15/</url>
    <content><![CDATA[<h2 id="八股"><a href="#八股" class="headerlink" title="八股"></a>八股</h2><h3 id="为什么-JDK-要同时提供-equals-和-hashcode-两个方法？"><a href="#为什么-JDK-要同时提供-equals-和-hashcode-两个方法？" class="headerlink" title="为什么 JDK 要同时提供 equals 和 hashcode 两个方法？"></a>为什么 JDK 要同时提供 equals 和 hashcode 两个方法？</h3><p>hashmap, hashset 的插入流程。</p>
<p>hashcode 可能会冲突，equals 检查是否一致。</p>
<h3 id="String、StringBuffer、StringBuilder-的区别"><a href="#String、StringBuffer、StringBuilder-的区别" class="headerlink" title="String、StringBuffer、StringBuilder 的区别"></a>String、StringBuffer、StringBuilder 的区别</h3><p>String 不可变，每次操作生成新对象。</p>
<p>StringBuffer、StringBuilder 每次都是对对象本身进行操作；区别是前者是线程安全的，后者不安全仅提升 10% - 15% 的性能。</p>
<h3 id="String-不可变的原因"><a href="#String-不可变的原因" class="headerlink" title="String 不可变的原因"></a>String 不可变的原因</h3><p>内部是由字符数组维护的。</p>
<ol>
<li>被 final 和 private 修饰不可指向其他对象，也不能被外部访问，String 类也没有提供修改这个字符串的方法。</li>
<li>String 类被 final 修饰，不可被继承避免了子类破坏结构。</li>
</ol>
<h3 id="字符串拼接用-“-”-还是-StringBuilder？"><a href="#字符串拼接用-“-”-还是-StringBuilder？" class="headerlink" title="字符串拼接用 “+” 还是 StringBuilder？"></a>字符串拼接用 “+” 还是 StringBuilder？</h3><p>直接使用 “+” 的方式，其实底层创建了  StringBuilder 进行优化。</p>
<p>但是如果循环进行拼接应显式创建一个 StringBuilder 来复用，否则会造成多次创建。</p>
<h3 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h3><p>是 JVM 为了提升性能和减少内存消耗针对字符串专门开辟的一块区域。</p>
<p>当创建一个字符串对象时，会先检查常量池内是否存在，如果没有就创建 2 个字符串对象，一个给当前引用，另一个的引用保存到字符串常量池中。</p>
<p><code>String.valueOf</code> 会先从常量池中找，没有再 <code>new String()</code></p>
<p>而 <code>new String()</code> 是直接创建 1 个新的，只有常量池中没有才会给常量池也创建一个。</p>
<p>所以这个常量池是专门为字符串常量建立的缓存。</p>
<h3 id="String-intern"><a href="#String-intern" class="headerlink" title="String#intern"></a>String#intern</h3><p>类似 <code>new String()</code> 会创建 1 &#x2F; 2 个对象，其中一个保存到常量池，并且返回常量池的引用，<strong>确保这个引用是唯一的</strong></p>
<h3 id="String-类型的变量和常量做-“-”-运算时发生了什么。"><a href="#String-类型的变量和常量做-“-”-运算时发生了什么。" class="headerlink" title="String 类型的变量和常量做 “+” 运算时发生了什么。"></a>String 类型的变量和常量做 “+” 运算时发生了什么。</h3><p><strong>“常量折叠”</strong>：对于在编译时期就可以确定的值，会提前进行计算。</p>
<p>而引用的值是无法直接确定的，因此会创建一个新的对象，后续进行计算。</p>
<p><strong>发生常量折叠的情况：</strong></p>
<ul>
<li>基本数据类型( <code>byte</code>、<code>boolean</code>、<code>short</code>、<code>char</code>、<code>int</code>、<code>float</code>、<code>long</code>、<code>double</code>)、字符串的<strong>常量</strong></li>
</ul>
<blockquote>
<p>无法测试区分常量相加和变量相加创建的变量地址是否一致，因为无法直接比较基本类型的地址。</p>
</blockquote>
<ul>
<li>final 修饰的基本数据类型和字符串的<strong>变量</strong>。</li>
<li>字符串通过 “+”拼接得到的字符串、基本数据类型之间算数运算（加减乘除）、基本数据类型的位运算（&lt;&lt;、&gt;&gt;、&gt;&gt;&gt; ）</li>
</ul>
<p>简言之，通过 final 修饰或者其他确定的直接运算，就会被折叠。</p>
<h3 id="Exception-和-Error-有什么区别"><a href="#Exception-和-Error-有什么区别" class="headerlink" title="Exception 和 Error 有什么区别"></a>Exception 和 Error 有什么区别</h3><p>Exception 表示程序本身能处理的异常，可以捕获。</p>
<p>Error 程序无法处理，JVM 一般会选择直接终止。</p>
<p>如：虚拟机错误（Virtual MachineError）</p>
<h3 id="finally-和-try-中同时存在-return-会怎么样？"><a href="#finally-和-try-中同时存在-return-会怎么样？" class="headerlink" title="finally 和 try 中同时存在 return 会怎么样？"></a>finally 和 try 中同时存在 return 会怎么样？</h3><p>最后 return 的值会变成 finally 的。</p>
<p>因为执行到 try 的 return 时会将返回值暂存到一个本地变量，如果 finally 也有 return 会覆盖掉之前的值。</p>
<h3 id="try-with-resources-Java7"><a href="#try-with-resources-Java7" class="headerlink" title="try-with-resources Java7"></a>try-with-resources Java7</h3><p>用于实现了 <code>AutoCloseable</code> 或者 <code>Closeable</code> 的对象。</p>
<p>在作用域结束后会自动关闭声明的资源。</p>
<blockquote>
<p>通过 ；可以声明多个资源</p>
</blockquote>
<h3 id="异常使用有哪些需要注意的地方？"><a href="#异常使用有哪些需要注意的地方？" class="headerlink" title="异常使用有哪些需要注意的地方？"></a>异常使用有哪些需要注意的地方？</h3><p>不要把异常定义为静态变量，因为这样会导致异常栈信息错乱。每次手动抛出异常，我们都需要手动 new 一个异常对象抛出。</p>
<h2 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h2><h3 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a><strong>两数之和</strong></h3><p>从一个数组中找到和为 target 的两个数的位置，时间 O(n)。</p>
<p><strong>普通思路：</strong>两两遍历 O(n^2^)</p>
<p><strong>优化：</strong>如果第一层遍历确定了一个数，那么第二层仅是为了找 target - x 是否存在，因此可以借助哈希表优化索引时间为 O(1)，key：元素值，value：索引位置。</p>
<p><strong>数组内存在重复值问题：</strong>一边遍历一边建立哈希表，即使当前元素的值重复了也不会匹配同一个元素；</p>
<blockquote>
<p>如果提前建立哈希表，数组内重复的值无法作为唯一 key，当 target 需要由类似 3+3&#x3D;6 组成时，就会找不到索引。</p>
</blockquote>
<h3 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a><strong>接雨水</strong></h3><p>给出一个数组 height，其中 n 个元素代表 n 个高度为 height[n]，底部为 1 的柱子，试求出所有柱子构成的“容器”能够储存的雨水量总和。</p>
<p>类似 “盛最多水的容器” 一题，能够承载雨水量由最短高度决定。</p>
<p><strong>解法：</strong>一个柱子能够装的水等于两条“边”的最短边 - 本身高度，遍历每根柱子，依次求出左右两边的最长边，求出所有柱子的储水量相加即为结果。</p>
<blockquote>
<p>求 左右 最长边时包括自身，确保不会比自身还短，导致“漏掉”。</p>
</blockquote>
<p><strong>普通思路：</strong>遍历数组，求每个柱子的左右 max 然后计算，统计所有柱子储水量之和 O(n^2^)。</p>
<p><strong>优化（动态规划）：</strong> 和哈希表类似，可以提前算出每个点的左右 max，这样就避免了每次计算的重复寻找 max，使得计算过程为 O(1)，最终时间 O(n)，空间 O(n)。</p>
<p><strong>再优化（双指针）：</strong>从左右边界开始，由于每个柱子都可能作为边界，只要 height[l] &lt; height[r] 那么就一定有 left_max &lt; right_max 的情况发生，所以此时直接用 left_max - 自身高度 得到此刻的储水量，将空间缩减为了 O(1)。</p>
<blockquote>
<p>相当于抽象了整体，选出只需要“处理”一个方向的情况进行计算，不需要管另一边了。</p>
<p>当动态规划中的数据只需要用到 1 次时，可以考虑转化为双指针。</p>
</blockquote>
<h3 id="什么是动态规划？"><a href="#什么是动态规划？" class="headerlink" title="什么是动态规划？"></a>什么是动态规划？</h3><p>在动态中规划逻辑路线，根据状态变化能够做出新的决策；</p>
<h2 id="MySQL-分组"><a href="#MySQL-分组" class="headerlink" title="MySQL 分组"></a>MySQL 分组</h2><p>一个完整的分组流程。</p>
<p>选择表 emp；</p>
<p>分组 job；</p>
<p>筛选 having avg(sal) &gt; 2000；</p>
<p>展示 job,avg(sal)</p>
]]></content>
      <categories>
        <category>每日总结</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>算法</tag>
        <tag>八股</tag>
      </tags>
  </entry>
  <entry>
    <title>每日总结 day2</title>
    <url>/2024/07/14/2024-7-14/</url>
    <content><![CDATA[<h2 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h2><p>经过三道题，近乎两小时的洗礼。</p>
<p>我似乎明白了双指针的精髓。</p>
<p>双指针，双指针，双：一定会出现两者的相互关系。</p>
<p>而借助两者关系就能让两者相互“运动”，从而可以尽量把 O(n^2^) 的时间缩短至 O(n)。</p>
<h3 id="盛最多水的容器"><a href="#盛最多水的容器" class="headerlink" title="盛最多水的容器"></a>盛最多水的容器</h3><p>给定一个 heights 数组，索引代表 x 轴上的点，每一个值代表这个点的高度（y）。</p>
<p>尝试找到两个点之间构成的容器（矩形），能形成的最大面积。</p>
<p><strong>关键点：木桶效应，容量是由最短的边决定的。</strong></p>
<p><strong>解题思路：</strong></p>
<ol>
<li>面积由 x, y 两者决定，因此首先定义双指针指向左右边界，使得 x 最大。</li>
<li>其次就到了遍历求解过程了：如何让 x 缩减的同时，y 能尽量增大。<ol>
<li>假设选定了两条边分为位于 a, b 点，距离为 t，且 a &lt; b；</li>
<li>如果移动 b，最大面积绝对不会超过 a * t，所以关键在于最短边；</li>
<li>只要每次移动短的那一边，就能尽可能让结果增大，以此减少遍历次数。</li>
</ol>
</li>
<li>同时由于容器两边肯定要不能重合或反着计算对称的结果，应确保 a &lt; b；</li>
</ol>
<p><strong>再优化</strong></p>
<p>再遍历次数无法减少的情况下，可以对计算次数进行简化。</p>
<p>记录最短边，只要移动过后的值还 &lt;&#x3D; 最短边，就一直移动无需计算。</p>
<h3 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a><strong>三数之和</strong></h3><p>给定一个 nums 数组，要求找出位置互不相同的三个数，使其满足 i + j + k &#x3D; 0。</p>
<p><strong>解题思路：</strong> </p>
<p>首先为了避免三个在三三遍历时出现一个尾，一个头重复使用的情况，应对数组进行排序，然后有序遍历。</p>
<p>找出两者关系，三个数，两者关系？？？</p>
<p><strong>i + j + k &#x3D; 0 可以转化为 j + k &#x3D; -i</strong></p>
<p>将 i, j, k 分别看做三个数，普通思路是直接三层遍历 O(n^3^)，</p>
<p>但是当第一层遍历时，i 的值在某一个刻是<strong>确定的</strong>。</p>
<p>因此第 2 和 3 层遍历是有关系的。</p>
<p>要想保证 i 不变，需要一层增加，一层减少。</p>
<p>由于数组时有序且递增的，</p>
<p>只需要在第二层递增遍历时，同时让第三层递减遍历即可，这样就减少了一层时间复杂度。</p>
<h2 id="Java-八股"><a href="#Java-八股" class="headerlink" title="Java 八股"></a>Java 八股</h2><h3 id="Java的特点"><a href="#Java的特点" class="headerlink" title="Java的特点"></a>Java的特点</h3><p>面向对象、平台无关、多线程、可靠性、安全、高效。</p>
<h3 id="Java：“编译与解释并存”"><a href="#Java：“编译与解释并存”" class="headerlink" title="Java：“编译与解释并存”"></a>Java：“编译与解释并存”</h3><p>java代码 -&gt; 字节码 -&gt; 机器码</p>
<h3 id="基本类型和包装类型的区别"><a href="#基本类型和包装类型的区别" class="headerlink" title="基本类型和包装类型的区别"></a>基本类型和包装类型的区别</h3><ol>
<li>用途</li>
<li>存储方式</li>
<li>占用空间</li>
<li>默认值</li>
<li>比较方式</li>
</ol>
<h3 id="包装类型的缓存机制"><a href="#包装类型的缓存机制" class="headerlink" title="包装类型的缓存机制"></a>包装类型的缓存机制</h3><p>new 和 自动装箱</p>
<h3 id="包装类的装箱和拆箱的本质"><a href="#包装类的装箱和拆箱的本质" class="headerlink" title="包装类的装箱和拆箱的本质"></a>包装类的装箱和拆箱的本质</h3><p>valueOf  intValue</p>
<h3 id="如何解决浮点数运算精度丢失问题"><a href="#如何解决浮点数运算精度丢失问题" class="headerlink" title="如何解决浮点数运算精度丢失问题"></a>如何解决浮点数运算精度丢失问题</h3><p>BigDecimal 字符数组</p>
<h3 id="超过-long-长度的整型该如何表示"><a href="#超过-long-长度的整型该如何表示" class="headerlink" title="超过 long 长度的整型该如何表示"></a>超过 long 长度的整型该如何表示</h3><p>BigInteger</p>
<h3 id="成员变量和局部变量的区别"><a href="#成员变量和局部变量的区别" class="headerlink" title="成员变量和局部变量的区别"></a>成员变量和局部变量的区别</h3><p>语法形式：访问修饰符，static</p>
<p>存储方式：堆，栈</p>
<p>生存时间：实例创建，局部作用域</p>
<p>默认值</p>
<blockquote>
<p>为什么成员变量有默认值</p>
</blockquote>
<h3 id="字符型常量和字符串常量的区别？"><a href="#字符型常量和字符串常量的区别？" class="headerlink" title="字符型常量和字符串常量的区别？"></a>字符型常量和字符串常量的区别？</h3><p>表示形式：</p>
<p>含义：</p>
<p>内存大小：</p>
<h3 id="重写父类方法的要求"><a href="#重写父类方法的要求" class="headerlink" title="重写父类方法的要求"></a>重写父类方法的要求</h3><p>返回值类型，抛出异常，访问修饰符（向上转型）</p>
<h3 id="可变长参数-Java5"><a href="#可变长参数-Java5" class="headerlink" title="可变长参数 Java5"></a>可变长参数 Java5</h3><p>声明位置？</p>
<p>遇上方法重载？优先级低</p>
<h3 id="面向过程性能比面向对象高？"><a href="#面向过程性能比面向对象高？" class="headerlink" title="面向过程性能比面向对象高？"></a>面向过程性能比面向对象高？</h3><p>c &#x2F; C++, Java?</p>
<h3 id="面向对象三大特征"><a href="#面向对象三大特征" class="headerlink" title="面向对象三大特征"></a>面向对象三大特征</h3><p>封装</p>
<p>集成</p>
<p>多态</p>
<h3 id="浅拷贝、深拷贝、引用拷贝"><a href="#浅拷贝、深拷贝、引用拷贝" class="headerlink" title="浅拷贝、深拷贝、引用拷贝"></a>浅拷贝、深拷贝、引用拷贝</h3><p>一层</p>
<p>完全</p>
<p>地址</p>
<h3 id="与equals方法的区别"><a href="#与equals方法的区别" class="headerlink" title="&#x3D;&#x3D;与equals方法的区别"></a>&#x3D;&#x3D;与equals方法的区别</h3><p>Object默认的equals</p>
<h3 id="为什么重写equals必须重写hashcode方法？"><a href="#为什么重写equals必须重写hashcode方法？" class="headerlink" title="为什么重写equals必须重写hashcode方法？"></a>为什么重写equals必须重写hashcode方法？</h3><p>因为相等的对象hashcode必须一致，否则hashmap会出现相同的key值的情况</p>
]]></content>
      <categories>
        <category>每日总结</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>算法</tag>
        <tag>八股</tag>
      </tags>
  </entry>
  <entry>
    <title>每日总结 day1</title>
    <url>/2024/07/13/2024-7-13/</url>
    <content><![CDATA[<p>在此立个 Flag：遵循我的每日安排！并且坚持 21 天！</p>
<blockquote>
<p>期间中断不能超过 1 天，避免意外情况。</p>
</blockquote>
<p>失败惩罚：一个星期不许进行任何娱乐活动！</p>
<hr>
<h2 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h2><p>:happy: 今天悟出来的做题经验：</p>
<ol>
<li>先根据题意，写出最简单的、最能想得到的思路。</li>
<li>然后把思路转变为代码，并且额外留意区间的临界点。</li>
</ol>
<blockquote>
<p>临界点：除一般情况外，代码逻辑并不能正确执行的某个状态。</p>
</blockquote>
<ol start="3">
<li>再根据题目标签（涉及的数据结构）和题目要求，一步一步的优化代码。</li>
</ol>
<h3 id="链表指定区间反转"><a href="#链表指定区间反转" class="headerlink" title="链表指定区间反转"></a><strong>链表指定区间反转</strong></h3><p>给出一个区间的起始位置和结束位置，要求反转这个区间的节点，然后重新和整个链表连接上。</p>
<p><strong>解题思路：</strong>找到这个区间的前置节点（起始位置的前一个）和后置节点（同理），然后遍历反转这段区间的节点，再分别用前置和后置节点连上。</p>
<p><strong>临界点：</strong>链表为空、区间长度为1。</p>
<p><strong>难点：</strong>起始点可能在头部，需要一个假的头节点作为前置节点来连接整个链表。</p>
<blockquote>
<p>也可以把这个作为一个“临界点”处理。if m &#x3D;&#x3D; 1</p>
</blockquote>
<h3 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a><strong>合并两个有序链表</strong></h3><p>输入两个递增的链表，单个链表的长度为n，合并这两个链表并使新链表中的节点仍然是递增排序的。</p>
<p><strong>解题思路：</strong>创建一个新的头节点用来构建新链表，分别<strong>同时</strong>遍历两个链表，循环取出值更小的那一个，直到其中一个链表为空，尾部直接全部接上另一个链表。</p>
<p><strong>临界点</strong>：任意一个链表为空。</p>
<p><strong>难点：</strong>代码条件关系的判断。</p>
<h3 id="字母异位词分组"><a href="#字母异位词分组" class="headerlink" title="字母异位词分组"></a><strong>字母异位词分组</strong></h3><p>给一个字符串数组，要求将属于同一类<strong>字母异位词</strong>的字符串组成一个新的数组。</p>
<blockquote>
<p>字母异位词：如果将一个字符串中的所有字母任意排列可以得到另一个字符串，即互为字母异位词。</p>
</blockquote>
<p><strong>解题思路：</strong>既然每个异位词包含的所有字母都是相同的，那么将字母重新按照字典序排序得到的结果就一定是一样的。此时只需要创建一个以字典序为 key，异位词数组为 value 的哈希表，遍历完整个数组就能得到按异位词分组的数组了。</p>
<blockquote>
<p>“bat”, “bta”, “atb” &#x3D;&gt; “abt”</p>
</blockquote>
<p><strong>难点：</strong>发现一组字母异位词（题干）的共同点（分组依据）。</p>
<h3 id="最长连续序列"><a href="#最长连续序列" class="headerlink" title="最长连续序列"></a>最长连续序列</h3><p>给定一个未排序的整数数组 <code>nums</code> ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p>
<p><strong>解题思路：</strong>遍历数组，以元素 x 为起始值，尝试匹配 x+1, x+2, … , x+y 符合连续序列的值是否存在，记录最大的连续长度。</p>
<p><strong>难点：</strong>降低时间复杂度</p>
<ul>
<li>暴力匹配：第一层遍历元素 x，第二层匹配 1-y 连续值，第三层再次遍历是否存在，总时间 O(n^3^)</li>
<li>哈希索引：先遍历一遍构建哈希索引，将第三层的判断缩减为 O(n)，总时间 O(n^2^)</li>
<li>剔除子区间：在尝试匹配连续序列前，应先检验 x-1 是否存在，如果存在那么从 x-1 开始的序列长度一定大于本元素起始的序列，所以直接跳过匹配，综合计算总时间 O(n)。</li>
</ul>
<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><p>思路：</p>
<ol>
<li>先找到提问关注点，针对性回答。</li>
</ol>
<blockquote>
<p> 类似举例的问题可以相对粗略的回答，指明是原理就应该详细回答。</p>
</blockquote>
<ol start="2">
<li>不应该直接扯到深层知识，可以留给面试官提问的空间。</li>
</ol>
]]></content>
      <categories>
        <category>每日总结</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>刷题</tag>
        <tag>哈希表</tag>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL(二) 数据处理函数</title>
    <url>/2024/07/12/MySQL-%E4%BA%8C-%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>在数据库操作中，除了需要查询数据，</p>
<p>有时候还需要对数据进行一些简单的处理，</p>
<p>用于优化数据显示效果等。</p>
<span id="more"></span>

<p><strong>select的其他用法</strong></p>
<p>select 除了可以选择列名外，还可以选择常量。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="number">3</span>; # <span class="number">3</span></span><br><span class="line"><span class="keyword">select</span> <span class="string">&#x27;hello world&#x27;</span>; # hello world</span><br></pre></td></tr></table></figure>

<h1 id="upper、lower"><a href="#upper、lower" class="headerlink" title="upper、lower"></a>upper、lower</h1><p>分别用于将字符串转为大写和小写</p>
<blockquote>
<p>ucase, lcase 分别也可以转大小写。</p>
</blockquote>
<p><strong>应用</strong></p>
<p>当不知道查询内容的大小写时，可以统一转为大写&#x2F;小写来匹配查询。</p>
<p>在 Oracle 数据库中区分大小写，Linux 的 MySQL 也区分</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> <span class="built_in">upper</span>(ename)<span class="operator">=</span><span class="string">&#x27;smith&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h1 id="substr"><a href="#substr" class="headerlink" title="substr"></a>substr</h1><p>用于截取字符串</p>
<p><strong>用法</strong></p>
<ol>
<li>substr(‘被截取的字符串’, 起始下标, 截取长度)</li>
<li>substr(‘被截取的字符串’, 起始下标)</li>
</ol>
<blockquote>
<p>如果不写截取长度，就直接截取到尾部。</p>
</blockquote>
<p><strong>截取规则：</strong></p>
<ol>
<li><p>下标从 1 开始，-1 表示右侧第一个。</p>
</li>
<li><p>截取的方向永远往右边截取。</p>
</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> substr(<span class="string">&#x27;abcd&#x27;</span>, <span class="number">-1</span>, <span class="number">2</span>); # d</span><br></pre></td></tr></table></figure>

<p>上述 sql 只能得到 ‘d’，而不是 ‘cd’</p>
<p><strong>应用</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> substr(ename, <span class="number">2</span>, <span class="number">1</span>) <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>选择 ename 第二个字符是 A 的行。</p>
<h1 id="length、char-length"><a href="#length、char-length" class="headerlink" title="length、char_length"></a>length、char_length</h1><p>length 用于统计字符串的字节数</p>
<p>char_length 用于统计字符数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> length(<span class="string">&#x27;你好&#x27;</span>); # <span class="number">6</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">char_length</span>(<span class="string">&#x27;你好&#x27;</span>); # <span class="number">2</span></span><br></pre></td></tr></table></figure>

<h1 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h1><p>用于拼接字符串，可以传入任意个参数。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> concat(<span class="string">&#x27;hello &#x27;</span>, <span class="string">&#x27;world&#x27;</span>); # hello world</span><br></pre></td></tr></table></figure>

<blockquote>
<p>mysql8之前可以采用 || 进行拼接。</p>
<p>‘hello ‘ || ‘world’ &#x3D;&gt; ‘hello world’</p>
</blockquote>
<h1 id="trim"><a href="#trim" class="headerlink" title="trim"></a>trim</h1><p>去除字符串前后空白字符。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">trim</span>(<span class="string">&#x27;  a  b  c  &#x27;</span>);</span><br><span class="line"># a  b  c</span><br></pre></td></tr></table></figure>

<p><strong>扩展</strong></p>
<p>leading</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">trim</span>(<span class="keyword">leading</span> <span class="string">&#x27;0&#x27;</span> <span class="keyword">from</span> <span class="string">&#x27;000111&#x27;</span>);</span><br><span class="line"># <span class="number">111</span></span><br></pre></td></tr></table></figure>

<p>去除前面的 0 字符。</p>
<p>trailing</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">trim</span>(<span class="keyword">trailing</span> <span class="string">&#x27;0&#x27;</span> <span class="keyword">from</span> <span class="string">&#x27;111000&#x27;</span>);</span><br><span class="line"># <span class="number">111</span></span><br></pre></td></tr></table></figure>

<p>去除后面的 0 字符</p>
<p>both</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">trim</span>(<span class="keyword">both</span> <span class="string">&#x27;x&#x27;</span> <span class="keyword">from</span> <span class="string">&#x27;xx111xx&#x27;</span>);</span><br><span class="line"># <span class="number">111</span></span><br></pre></td></tr></table></figure>

<p>去除前后的 x 字符</p>
<h1 id="rand"><a href="#rand" class="headerlink" title="rand()"></a>rand()</h1><p>生成 0 到 1 之间的随机浮点数。</p>
<p>还有一种写法：rand(x)</p>
<p>通过传入一个值，保留本次随机数的值。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> rand(<span class="number">1</span>); # <span class="number">0.918204912</span></span><br><span class="line"><span class="keyword">select</span> rand(<span class="number">1</span>); # <span class="number">0.918204912</span></span><br></pre></td></tr></table></figure>

<p>这个 x 就相当于一个 key，每次获取同样的 x，得到的值都是一样的。</p>
<blockquote>
<p>这个 x 应该是“种子”吧，如果种子相同得到的结果自然是一样的。</p>
</blockquote>
<h1 id="round-x"><a href="#round-x" class="headerlink" title="round(x)"></a>round(x)</h1><p>四舍五入</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> round(<span class="number">3.5</span>); # <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p><strong>指定保留的小数位</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> round(<span class="number">3.63</span>, <span class="number">1</span>); #<span class="number">3.6</span></span><br></pre></td></tr></table></figure>

<h1 id="truncate-x-y"><a href="#truncate-x-y" class="headerlink" title="truncate(x, y)"></a>truncate(x, y)</h1><p>只保留 y 个小数，剩下小数位舍弃</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">truncate</span>(<span class="number">3.6666</span>, <span class="number">1</span>); # <span class="number">3.6</span></span><br></pre></td></tr></table></figure>

<h1 id="ceil-x-、floor-x"><a href="#ceil-x-、floor-x" class="headerlink" title="ceil(x)、floor(x)"></a>ceil(x)、floor(x)</h1><p>ceil：向上取整</p>
<p>floor：向下取整</p>
<blockquote>
<p>忽略四舍五入</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">ceil</span>(<span class="number">4.7</span>); # <span class="number">5</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">floor</span>(<span class="number">4.7</span>); # <span class="number">4</span></span><br></pre></td></tr></table></figure>

<h1 id="空处理"><a href="#空处理" class="headerlink" title="空处理"></a>空处理</h1><p>在 MySQL 和 Oracle 中，任何和 NULL 运算的结果都是 NULL；</p>
<p><strong><code>ifnull(x, y)</code></strong></p>
<p>如果 x 为 NULL，就用 y 代替</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> ename, sal, ((sal <span class="operator">+</span> ifnull(comm, <span class="number">0</span>)) <span class="operator">*</span> <span class="number">12</span>) <span class="keyword">as</span> year_sal <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure>

<p>当 comm 为空时（员工没有津贴时），统一用 0 代替，避免运算结果为 NULL。</p>
<h1 id="获取当前-datetime"><a href="#获取当前-datetime" class="headerlink" title="获取当前 datetime"></a>获取当前 datetime</h1><p><code>now()</code></p>
<p>获取当前时间（select 执行的时间）</p>
<p><img src="/assets/image-20240712221917658.png" alt="image-20240712221917658"></p>
<p><code>sysdate()</code></p>
<p>获取该函数执行的时间</p>
<p><img src="/assets/image-20240712222000512.png" alt="image-20240712222000512"></p>
<blockquote>
<p>底层应该是 now 直接被转化为当前时间，而 sysdate 按照程序执行顺序获取时间。</p>
</blockquote>
<h1 id="获取当前-date-time"><a href="#获取当前-date-time" class="headerlink" title="获取当前 date&#x2F;time"></a>获取当前 date&#x2F;time</h1><p><code>current_date()</code> 获取当前日期</p>
<p><code>current_time()</code> 获取当前时间</p>
<blockquote>
<p>可以省略括号()</p>
</blockquote>
<h1 id="获取单独的年月日时分秒"><a href="#获取单独的年月日时分秒" class="headerlink" title="获取单独的年月日时分秒"></a>获取单独的年月日时分秒</h1><p><code>year(时间)</code></p>
<p><code>month(时间)</code></p>
<p><code>day(时间)</code></p>
<p><code>hour(时间)</code></p>
<p><code>minute(时间)</code></p>
<p><code>second(时间)</code></p>
<p>这里的时间可以是 now()，或者符合日期格式的字符串。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">year</span>(<span class="string">&#x27;2024-07-12 22:26:31&#x27;</span>);</span><br><span class="line"># <span class="number">2024</span></span><br></pre></td></tr></table></figure>

<h1 id="date-add"><a href="#date-add" class="headerlink" title="date_add"></a>date_add</h1><p>用于日期时间的运算</p>
<p>语法格式：</p>
<p><code>date_add(日期，interval expr 单位)</code></p>
<p>例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> date_add(<span class="string">&#x27;2020-10-14&#x27;</span>, <span class="type">interval</span> <span class="number">3</span> <span class="keyword">day</span>);</span><br><span class="line"># <span class="number">2020</span><span class="number">-10</span><span class="number">-17</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>只提供“日期”，可以用“时分秒”等次级单位来增减间隔。</p>
<p>但是如果只提供“时分秒”，就无法用上一级的单位“年月日”来增减间隔了。</p>
<p>运算向下兼容。</p>
</blockquote>
<p><strong>参数介绍</strong></p>
<p>日期：一个日期类型的数据或字符串</p>
<p>interval：固定写法，关键字</p>
<p>expr：指定一个具体的间隔量</p>
<blockquote>
<p>可以为负数，效果和 date_sub 一致，表示往后退。</p>
</blockquote>
<p>单位：</p>
<ul>
<li>年月日</li>
<li>时分秒</li>
<li>microsecond 微妙</li>
<li>week 周</li>
<li>quarter 一个季度（3个月）</li>
</ul>
<p><strong>复合单位</strong></p>
<p>两个单位通过下划线组合在一起。</p>
<p>例如：</p>
<ul>
<li>year_month</li>
<li>day_hour</li>
<li>day_minute</li>
<li>day_second</li>
</ul>
<blockquote>
<p>没有 month_day，不知道为什么。。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> date_add(<span class="string">&#x27;2020-10-14&#x27;</span>, <span class="type">interval</span> <span class="string">&#x27;1,1&#x27;</span> year_month);</span><br><span class="line"># <span class="number">2021</span><span class="number">-11</span><span class="number">-14</span></span><br></pre></td></tr></table></figure>

<p>注意：expr 需用引号包裹，表示一个表达式。</p>
<h2 id="date-format"><a href="#date-format" class="headerlink" title="date_format"></a>date_format</h2><p>用于日期格式化</p>
<p><strong>语法格式：</strong></p>
<p><code>date_format(日期, 格式字符串)</code></p>
<p>举例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> date_format(now(), <span class="string">&#x27;%y-%m-%d %H:%i:%s&#x27;</span>);</span><br><span class="line"># <span class="number">24</span><span class="number">-07</span><span class="number">-14</span> <span class="number">23</span>:<span class="number">28</span>:<span class="number">11</span></span><br></pre></td></tr></table></figure>

<p><strong>参数介绍</strong></p>
<p>日期：可以是日期类型数据或字符串</p>
<p>格式字符串：由“%”+代表年月日时间的字符，和其他分隔字符组成。</p>
<p><strong>日期字符：</strong></p>
<ul>
<li>Y &#x2F; y：Y：四位完整的年份，y：完整年份的后两位数。</li>
<li>m：月份</li>
<li>d：日</li>
<li>H：小时</li>
<li>i：分钟</li>
<li>s：秒</li>
</ul>
<h2 id="str-to-date"><a href="#str-to-date" class="headerlink" title="str_to_date"></a>str_to_date</h2><p>将字符串转为日期</p>
<p><strong>语法格式：</strong></p>
<p><code>str_to_date(日期, 格式字符串)</code></p>
<p>格式字符串与 <code>date_format</code> 一致。</p>
<p><strong>例如：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_student(name, birth) <span class="keyword">values</span>(<span class="string">&#x27;lisi&#x27;</span>, str_to_date(<span class="string">&#x27;10/01/1999&#x27;</span>, <span class="string">&#x27;%m/%d/%Y&#x27;</span>));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>或者直接输入遵循默认日期格式的字符串（%y-%m-%d %H:%i:%s）。</p>
</blockquote>
<h2 id="dayofweek-dayofmonth-dayofyear"><a href="#dayofweek-dayofmonth-dayofyear" class="headerlink" title="dayofweek, dayofmonth, dayofyear"></a>dayofweek, dayofmonth, dayofyear</h2><p>分别给出<strong>目标日期</strong>对应一个星期，一个月，一年中的<strong>哪一天</strong></p>
<p><strong>语法格式：</strong></p>
<p><code>dayofweek(日期)</code></p>
<p>同，可以是日期类型数据或者字符串。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> dayofweek(now());</span><br><span class="line"><span class="keyword">select</span> dayofmonth(now());</span><br><span class="line"><span class="keyword">select</span> dayofyear(now());</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：<strong>周日</strong>是一周的第一天</p>
</blockquote>
<h2 id="last-day"><a href="#last-day" class="headerlink" title="last_day"></a>last_day</h2><p>给出当前月份的最后一天的日期。</p>
<p><strong>语法格式：</strong></p>
<p><code>last_day(日期)</code></p>
<p>同，可以是日期类型数据或者字符串。</p>
<h2 id="datediff-timediff"><a href="#datediff-timediff" class="headerlink" title="datediff, timediff"></a>datediff, timediff</h2><p><strong>datediff：</strong>显示两个日期相差的天数。</p>
<p><strong>timediff：</strong>求出两个日期相差的小时数，以时:分:秒的形式显示。</p>
<p><strong>语法格式：</strong></p>
<p><code>datediff(日期1, 日期2)</code></p>
<p><code>timediff(日期1, 日期2)</code></p>
<p><strong>例如：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> datediff(<span class="string">&#x27;2000-10-10 10:10:10&#x27;</span>, <span class="string">&#x27;2000-10-9 10:10:10&#x27;</span>);</span><br><span class="line"># <span class="number">1</span></span><br><span class="line"><span class="keyword">select</span> timediff(<span class="string">&#x27;2000-10-10 10:10:10&#x27;</span>, <span class="string">&#x27;2000-10-9 10:10:10&#x27;</span>);</span><br><span class="line"># <span class="number">24</span>:<span class="number">00</span>:<span class="number">00</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>结果是以日期1比日期2晚 xx 时间计算的，前者时间晚于后者，结果为正数，反之为负数。</p>
</blockquote>
<h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><p>类似 Java 中的三目运算符。</p>
<p><strong>语法格式：</strong></p>
<p><code>if(条件, x, y)</code></p>
<p>条件符合返回 x，反之返回 y。</p>
<p><strong>例如：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> if(<span class="number">1</span><span class="operator">&lt;</span><span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>); # <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>支持嵌套运算</strong></p>
<p>当 job 为 SALESMAN 时薪水乘以 1.1 倍，为 MANAGER 时薪水乘以 2 倍，请给出结果。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> sal, job, if(job<span class="operator">=</span><span class="string">&#x27;SALESMAN&#x27;</span>, sal<span class="operator">*</span><span class="number">1.1</span>, if(job<span class="operator">=</span><span class="string">&#x27;MANAGER&#x27;</span>, sal<span class="operator">*</span><span class="number">2</span>, sal)) <span class="keyword">as</span> new_sal <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure>

<p><img src="/assets/image-20240714234512305.png" alt="image-20240714234512305"></p>
<h2 id="case…when…then…else…end"><a href="#case…when…then…else…end" class="headerlink" title="case…when…then…else…end"></a><strong>case…when…then…else…end</strong></h2><p>类似 Java 中的 switch</p>
<p><strong>语法格式：</strong></p>
<p><code>case 变量 when 匹配值 then 结果 else 结果 end</code></p>
<p><strong>例如：</strong>（修改 if 嵌套）</p>
<p>:x:错误写法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select sal, job, (case job</span><br><span class="line">when job=&#x27;SALESMAN&#x27; then sal*1.1</span><br><span class="line">when job=&#x27;MANAGER&#x27; then sal*2</span><br><span class="line">else sal end) as new_sal</span><br><span class="line">from emp;</span><br></pre></td></tr></table></figure>

<p>:question: 为什么写成 job&#x3D;’xxx’ 反而是 manager 的薪水乘以 1.1，salesman 的薪水乘以 2 了。</p>
<p>正确写法</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> sal, job, (<span class="keyword">case</span> job</span><br><span class="line"><span class="keyword">when</span> <span class="string">&#x27;SALESMAN&#x27;</span> <span class="keyword">then</span> sal<span class="operator">*</span><span class="number">1.1</span></span><br><span class="line"><span class="keyword">when</span> <span class="string">&#x27;MANAGER&#x27;</span> <span class="keyword">then</span> sal<span class="operator">*</span><span class="number">2</span></span><br><span class="line"><span class="keyword">else</span> sal <span class="keyword">end</span>) <span class="keyword">as</span> new_sal</span><br><span class="line"><span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure>

<p><img src="/assets/image-20240714235253338.png" alt="image-20240714235253338"></p>
<p>结果和 if 嵌套写法一致。</p>
<blockquote>
<p>建议先写好模板，然后一个一个条件填入</p>
</blockquote>
<h2 id="cast"><a href="#cast" class="headerlink" title="cast"></a>cast</h2><p>用于类型转换</p>
<p><strong>语法格式：</strong></p>
<p><code>cast(值 as 数据类型)</code></p>
<p><strong>数据类型：</strong></p>
<ul>
<li>date：日期</li>
<li>time：时间</li>
<li>datetime：日期时间</li>
<li>signed：有符号的 int 类型</li>
<li>char：char(字符长度)，字符。</li>
<li>decimal：decimal(有效数字位，保留小数位)，浮点数。</li>
</ul>
<blockquote>
<p>有效数字位包括小数位。</p>
<p>转化为 decimal 时如果指定的实际值超过了有效数字位，</p>
<p>会返回要求有效数字位的最大值。</p>
<p>如：将 ‘123.456’ 转为 decimal(3, 1) &#x3D;&gt; 99.9</p>
</blockquote>
<p><strong>例如：</strong>将字符串转为浮点数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">cast</span>(<span class="string">&#x27;000123.456&#x27;</span> <span class="keyword">as</span> <span class="type">decimal</span>(<span class="number">4</span>,<span class="number">1</span>));</span><br><span class="line"># <span class="number">123.5</span> 四舍五入</span><br></pre></td></tr></table></figure>

<h2 id="md5"><a href="#md5" class="headerlink" title="md5"></a>md5</h2><p>单向加密算法，结果是一个固定长度 32 位的字符串。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>JMeter 测试教程</title>
    <url>/2024/07/09/JMeter%E6%B5%8B%E8%AF%95%E5%A4%9A%E4%BA%BA%E5%B9%B6%E5%8F%91%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>一个好的项目不仅需要完整的业务功能，</p>
<p>更应该保证处理响应的效率！</p>
<p>在业务中经常需要检验并发的可靠性，特别是多人同时操作对业务的影响。</p>
<p>这时候就可以借助 JMeter 进行测试。</p>
<p>本文提供两种方式：串行测试、全局属性</p>
<span id="more"></span>

<h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><p>首先介绍下 JMeter 的基本使用。</p>
<p>一个完整的测试分为创建线程组，创建取样器（请求），定义响应结果断言。</p>
<p><strong>创建线程组</strong>目的是设置并发量。</p>
<h2 id="创建线程组"><a href="#创建线程组" class="headerlink" title="创建线程组"></a>创建线程组</h2><p><img src="https://gcore.jsdelivr.net/gh/BlueApong/images@main/img/202407112345944.png" alt="image-20240709130805462"></p>
<p><strong>线程组大致分为三类：</strong></p>
<ol>
<li>启动线程组，最开始执行的线程</li>
<li>销毁线程组，最后才执行的线程</li>
<li>普通线程组，除启动和销毁外被放在中间执行的线程</li>
</ol>
<p>（以上待考证，因为是我猜的）</p>
<p>一般来说随便选一个线程组都可以，如果同时只需要用到一个线程组的话</p>
<p><strong>参数介绍</strong></p>
<p><img src="https://gcore.jsdelivr.net/gh/BlueApong/images@main/img/202407112346988.png" alt="image-20240711234655935"></p>
<p>Name：线程组的名称</p>
<p>Action to be token after…：当某个线程失败后的执行策略</p>
<p>Number of Threads：总线程数</p>
<p>Ramp-up period：执行完全部线程的时间（秒）</p>
<p>Loop Count：该线程组的循环次数</p>
<p>Same user on…：每个线程是否采用同一个数据（当你读取文件时有用）</p>
<p>常用的就是设置线程数和总时间，比如设置 threads: 1000 period: 10，就是 10 秒内跑完 1000 个线程，平均每秒 100 个并发。</p>
<p><strong>注意：</strong>实际情况下线程数是不断递增的，因为启动需要时间。 </p>
<h2 id="创建取样器"><a href="#创建取样器" class="headerlink" title="创建取样器"></a>创建取样器</h2><p>以创建 HTTP 请求为例</p>
<p>右键线程组弹出菜单，点击 Add -&gt; Sampler -&gt; HTTP Request</p>
<p><img src="https://gcore.jsdelivr.net/gh/BlueApong/images@main/img/202407112355332.png" alt="image-20240709134542130"></p>
<p><strong>参数介绍</strong></p>
<p><img src="https://gcore.jsdelivr.net/gh/BlueApong/images@main/img/202407112357005.png" alt="image-20240711235738958"></p>
<p>分别通过 protocal, server name(domain), port, path 设置请求的 URL 路径。</p>
<p>再通过 HTTP Request 选择请求的方式，下面的 Parameters, Body Data … 可携带请求参数&#x2F;请求体。</p>
<h2 id="定义响应结果断言"><a href="#定义响应结果断言" class="headerlink" title="定义响应结果断言"></a>定义响应结果断言</h2><p>以 JSON 断言为例，</p>
<p>在此之前需声明响应头信息的 Content-Type 为 JSON</p>
<h3 id="添加响应头配置"><a href="#添加响应头配置" class="headerlink" title="添加响应头配置"></a>添加响应头配置</h3><p>右键取样器，点击 Add -&gt; Config Element -&gt; HTTP Header Manager</p>
<p><img src="https://gcore.jsdelivr.net/gh/BlueApong/images@main/img/202407121103271.png" alt="image-20240712110317215"></p>
<p>然后就是根据 Name-Value 的规则添加信息头了。</p>
<p>再右键取样器创建断言，点击 Add -&gt; Assertions -&gt; JSON Assertion</p>
<p><img src="https://gcore.jsdelivr.net/gh/BlueApong/images@main/img/202407120002114.png" alt="image-20240712000225048"></p>
<p><strong>参数介绍</strong></p>
<p><img src="https://gcore.jsdelivr.net/gh/BlueApong/images@main/img/202407120004509.png" alt="image-20240712000427473"></p>
<p>Assert JSON Path exists：表示响应结果 JSON 对象中包含 xx 属性。</p>
<p>Additionally assert value：同时断言这个属性的值。</p>
<p>Match as regular expression：以正则表达式的语法匹配。</p>
<p>Expected Value：期望的属性值。</p>
<h2 id="添加结果分析报告"><a href="#添加结果分析报告" class="headerlink" title="添加结果分析报告"></a>添加结果分析报告</h2><p><img src="https://gcore.jsdelivr.net/gh/BlueApong/images@main/img/202407121122750.png" alt="image-20240712112237695"></p>
<p>根据上述定义的断言，可以确定结果是否正确，并能够通过 Listener 监听器显示测试的结果。</p>
<h3 id="聚合报告"><a href="#聚合报告" class="headerlink" title="聚合报告"></a>聚合报告</h3><p>将所有的结果进行分析。</p>
<p>包含样本数，平均响应时间，中位数、90%以下、95%以下、99%以下、最小、最大响应时间，错误率，吞吐量等数据。</p>
<p><img src="https://gcore.jsdelivr.net/gh/BlueApong/images@main/img/202407121125863.png" alt="image-20240712112552811"></p>
<h3 id="结果树"><a href="#结果树" class="headerlink" title="结果树"></a>结果树</h3><p>展示每一条请求的具体内容</p>
<p>包括请求头，请求体，响应内容等。</p>
<p><img src="https://gcore.jsdelivr.net/gh/BlueApong/images@main/img/202407121127209.png" alt="image-20240712112700165"></p>
<h2 id="开启测试"><a href="#开启测试" class="headerlink" title="开启测试"></a>开启测试</h2><p>右键线程组，点击 Start 即可开始测试。</p>
<p><img src="https://gcore.jsdelivr.net/gh/BlueApong/images@main/img/202407121129403.png" alt="image-20240712112938357"></p>
<blockquote>
<p>如果点击界面上方的开始按钮，会开始全部的线程组。</p>
</blockquote>
<h1 id="业务测试"><a href="#业务测试" class="headerlink" title="业务测试"></a>业务测试</h1><p>下文以实际多种测试为例，讲解如何进行常用的业务的测试。</p>
<h2 id="登录测试"><a href="#登录测试" class="headerlink" title="登录测试"></a>登录测试</h2><h3 id="创建线程组-1"><a href="#创建线程组-1" class="headerlink" title="创建线程组"></a>创建线程组</h3><p><img src="https://gcore.jsdelivr.net/gh/BlueApong/images@main/img/202407121109288.png" alt="image-20240712110917225"></p>
<p>图中的 Same User… 需要取消勾选，确保每个线程都取不同行的数据</p>
<h3 id="添加-CSV-数据配置"><a href="#添加-CSV-数据配置" class="headerlink" title="添加 CSV 数据配置"></a>添加 CSV 数据配置</h3><p>通过配置数据文件，可以在线程组内通过变量的方式读取文件内的数据。</p>
<p>比如用于 token，session，用户登录账号密码信息 的输入。</p>
<p><img src="https://gcore.jsdelivr.net/gh/BlueApong/images@main/img/202407121112827.png" alt="image-20240712111226038"></p>
<p><strong>参数介绍</strong></p>
<p>Filename：文件路径，也可以是其他文件，只要正确指定分隔符就行。</p>
<p>Variable Names：在 CSV 文件中，通过“,”分隔的列名。</p>
<blockquote>
<p>也可以没有列名，这个变量名只是用来指定根据“分隔符”划分的每一列的名称。</p>
</blockquote>
<p>Ignore first line…：是否忽略文件的第一行</p>
<p>Delimiter：数据之间的分隔符</p>
<p>Recycle on EOF：是否循环读取文件数据</p>
<p>Sharing mode：数据共享模式</p>
<p><strong>注意：</strong>只有取消勾选 Same User… 才会应用这些变量的时候选取不同行的数据</p>
<p><strong>应用变量</strong></p>
<p>通过 ${variables} 的方式，可以在线程组的任意一处应用</p>
<h3 id="创建取样器-1"><a href="#创建取样器-1" class="headerlink" title="创建取样器"></a>创建取样器</h3><p><img src="https://gcore.jsdelivr.net/gh/BlueApong/images@main/img/202407121118584.png" alt="image-20240712111802527"></p>
<p>以上是错误示范：并不满足 JSON 格式。</p>
<p><img src="https://gcore.jsdelivr.net/gh/BlueApong/images@main/img/202407121137971.png"></p>
<p>属性和值必须用双引号包裹</p>
<blockquote>
<p>变量即使为双引号包括，也会正常解析，解析结果其实就相当于一个字面量，</p>
<p>如果和其他字符在一起如：123_${userAccount}</p>
<p>结果会拼接在一起：123_xxxxxxx</p>
</blockquote>
<p>填写好测试的 api 地址，和请求体内容。</p>
<h3 id="定义响应头信息，结果断言。"><a href="#定义响应头信息，结果断言。" class="headerlink" title="定义响应头信息，结果断言。"></a>定义响应头信息，结果断言。</h3><p><img src="https://gcore.jsdelivr.net/gh/BlueApong/images@main/img/202407121120755.png" alt="image-20240712112031704"></p>
<p>保证响应结果能以 JSON 形式解析。</p>
<p><img src="https://gcore.jsdelivr.net/gh/BlueApong/images@main/img/202407121127637.png" alt="image-20240712112755591"></p>
<p>定义结果内容断言：必须要有 code 属性，且值为 0。</p>
<p>添加监听报告省略…</p>
<p>右键线程组点击 Start，即可开始测试。</p>
<p><img src="https://gcore.jsdelivr.net/gh/BlueApong/images@main/img/202407121135198.png" alt="image-20240712113544130"></p>
<h2 id="多人并发测试"><a href="#多人并发测试" class="headerlink" title="多人并发测试"></a>多人并发测试</h2><p>由于多人并发测试，需要用到用户信息，测试并不好办。</p>
<p>所以需要先登录拿到用户信息，再进行接下来的测试。</p>
<h3 id="串行测试（推荐）"><a href="#串行测试（推荐）" class="headerlink" title="串行测试（推荐）"></a>串行测试（推荐）</h3><p>在一个线程组内，创建两个取样器，并勾选 keep-alive 保证 cookie 不会丢失。</p>
<p>第二个取样器就可以基于第一个的用户信息发出请求了</p>
<p><img src="https://gcore.jsdelivr.net/gh/BlueApong/images@main/img/202407121606444.png" alt="image-20240712160616341"></p>
<p>此处就利用登录的 session 信息，进行个人信息的再一步请求。</p>
<h3 id="全局属性"><a href="#全局属性" class="headerlink" title="全局属性"></a>全局属性</h3><p>也可以分开两个线程组，先通过“登录”的取样器发出请求，并添加一系列处理程序来将 session 存储到全局属性中，</p>
<p>再需要用户信息的测试中，再通过获取全局属性的方式来获取到 session，进行请求。</p>
<p>以 Session 为例，</p>
<p>由于 session 的设置包含在响应头里，就需要通过先提取响应头。</p>
<p><strong>添加 正则后置处理器，提取 session 变量</strong></p>
<p><img src="https://gcore.jsdelivr.net/gh/BlueApong/images@main/img/202407121611146.png" alt="image-20240712161134096"></p>
<p>“session” 表示提取出来的变量的名称。</p>
<p><strong>注意：</strong>捕获组从 1 开始，Match No. 表示捕获匹配的哪一句。</p>
<p><strong>添加 BeanShell 处理程序，设置全局属性</strong></p>
<p><img src="https://gcore.jsdelivr.net/gh/BlueApong/images@main/img/202407121613845.png" alt="image-20240712161346797"></p>
<p>Parameters 表示从 CSV 数据配置传来的变量名，</p>
<blockquote>
<p> 大概因为 session 同处于后置处理器环节，所以直接写就可以了。</p>
</blockquote>
<p>通过 <code>$&#123;__setProperty()&#125;</code> 设置全局属性。</p>
<p>将 session 和 userAccount 绑定，存储所有用户的 session 值。</p>
<p><strong>添加 HTTP Cookie 管理器</strong></p>
<p><img src="https://gcore.jsdelivr.net/gh/BlueApong/images@main/img/202407121617412.png" alt="image-20240712161709362"></p>
<p>通过 <code>$(__property(variable_name))</code> 获取全局属性值。</p>
<p>接下来就可以进行测试了，请求会自动携带 cookie 中的 sessionID</p>
]]></content>
      <categories>
        <category>测试</category>
        <category>JMeter</category>
      </categories>
      <tags>
        <tag>JMeter</tag>
        <tag>测试</tag>
        <tag>多人并发</tag>
      </tags>
  </entry>
  <entry>
    <title>240506</title>
    <url>/2024/05/06/240506/</url>
    <content><![CDATA[<h2 id="not选择器"><a href="#not选择器" class="headerlink" title=":not选择器"></a>:not选择器</h2><p>用于选择非xx的元素，如 <code>.btn:not(:nth-child(1))</code> ，在btn类中选择非第一个子元素的其他元素。</p>
<h2 id="Object-fromEntries"><a href="#Object-fromEntries" class="headerlink" title="Object.fromEntries"></a>Object.fromEntries</h2><p>通过传入以 <code>[key, value]</code> 结构为元素的数组，构造出一个整合该数组所有key-value的对象字面量</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> entries = [[<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>], [<span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>]]</span><br><span class="line"><span class="keyword">let</span> obj = <span class="title class_">Object</span>.<span class="title function_">fromEntries</span>(entries)</span><br><span class="line"><span class="comment">// obj: &#123;a:1, b:2&#125;</span></span><br></pre></td></tr></table></figure>



<h2 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys"></a>Object.keys</h2><p>传入一个对象，以数组的形式返回其所有的key</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>:<span class="number">1</span>, <span class="attr">b</span>:<span class="number">2</span>&#125;</span><br><span class="line"><span class="keyword">let</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj)</span><br><span class="line"><span class="comment">// keys: [a, b]</span></span><br></pre></td></tr></table></figure>



<h2 id="vue中click事件函数不传值"><a href="#vue中click事件函数不传值" class="headerlink" title="vue中click事件函数不传值"></a>vue中click事件函数不传值</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;button @click=&quot;handleClick&quot;&gt;&lt;/button&gt;</span><br><span class="line">	&lt;button @click=&quot;handleClick(123)&quot;&gt;&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    methods: &#123;</span><br><span class="line">        handleClick(param) &#123;</span><br><span class="line">            console.log(param)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>相比于react直接传参会立即执行，vue允许声明处理函数时携带参数，因此 <code>handleClick(123)</code> 会输出123</p>
<p>但是，对于这类原生事件<strong>click</strong>，即使声明时没有携带参数，也会默认传入一个事件参数event。</p>
<p>所以 <code>handleClick</code> 这个事件点击后会输出event，而不是undefined。</p>
<h2 id="ApacheEcharts的init方法（在vue中）"><a href="#ApacheEcharts的init方法（在vue中）" class="headerlink" title="ApacheEcharts的init方法（在vue中）"></a>ApacheEcharts的init方法（在vue中）</h2><p>设想：由于图形渲染需要事件，可不可以在created时期，各个属性都创建完成的时候，执行 init 方法呢？</p>
<p>答案：不可以！</p>
<p>原因：因为 init 方法是通过获取dom树上的节点进行再处理的，而created时期并没有渲染完真实dom。</p>
<h2 id="el-form-item单个绑定rules属性"><a href="#el-form-item单个绑定rules属性" class="headerlink" title="el-form-item单个绑定rules属性"></a>el-form-item单个绑定rules属性</h2><p>直接绑定 rules 属性会显示红色<code>*</code>表示这个数据项需要通过验证，但是并不会真实生效。</p>
<p>需要额外指定 prop 属性，因为 rules 本身是通过 el-form 中声明的 model 数据然后找到对应 prop 属性来对这个值进行校验的。</p>
<p>如果不指定 prop，无法捕捉到这个数据项的值，当然无法进行数据验证。</p>
<h2 id="如何将module数据绑定到vue模板"><a href="#如何将module数据绑定到vue模板" class="headerlink" title="如何将module数据绑定到vue模板"></a>如何将module数据绑定到vue模板</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">import * as productStatus from &#x27;@/constants/product&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  computed: &#123;</span><br><span class="line">    productStatus() &#123;</span><br><span class="line">      return productStatus</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>最好绑定只读数据，如果让其可修改，会造成数据干扰。</p>
<h2 id="如何将函数绑定到vue模板中"><a href="#如何将函数绑定到vue模板中" class="headerlink" title="如何将函数绑定到vue模板中"></a>如何将函数绑定到vue模板中</h2><p>在methods体内再声明就可以了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; getFormatTime &#125; from &#x27;@/utils/timeFormatter&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    getFormatTime,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h2 id="如何使用lodash"><a href="#如何使用lodash" class="headerlink" title="如何使用lodash"></a>如何使用lodash</h2><ol>
<li>安装依赖</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install lodash</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>引入lodash</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">&quot;lodash&quot;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">_.<span class="title function_">sort</span>([<span class="number">1</span>,<span class="number">2</span>], <span class="number">3</span>) <span class="comment">// [1,2,3]</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot集成沙箱支付——不墨迹版</title>
    <url>/2024/04/19/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%B2%99%E7%AE%B1%E6%94%AF%E4%BB%98/</url>
    <content><![CDATA[<h1 id="SpringBoot集成沙箱支付——不墨迹版"><a href="#SpringBoot集成沙箱支付——不墨迹版" class="headerlink" title="SpringBoot集成沙箱支付——不墨迹版"></a>SpringBoot集成沙箱支付——不墨迹版</h1><h3 id="一、获取沙箱配置信息"><a href="#一、获取沙箱配置信息" class="headerlink" title="一、获取沙箱配置信息"></a>一、获取沙箱配置信息</h3><p>先进入支付宝的个人沙箱应用页面 <a href="https://openhome.alipay.com/develop/sandbox/app">https://openhome.alipay.com/develop/sandbox/app</a></p>
<p><img src="/assets/1685079849346-0bb2ef6b-3ea3-48ed-bc39-81aa22bd7f1b.png" alt="image.png"></p>
<p><img src="/assets/image-20240419143841824.png" alt="image-20240419143841824"></p>
<p>图中 <strong>黑色框框</strong> 圈出来的我们需要的四个配置信息。</p>
<blockquote>
<p>以下步骤省略创建 Spring Boot 项目过程。</p>
<p>教程采用版本：</p>
<ul>
<li>spring boot 2.6.13</li>
<li>java 8</li>
</ul>
</blockquote>
<h3 id="二、在-pom-xml-中引入支付宝SDK依赖"><a href="#二、在-pom-xml-中引入支付宝SDK依赖" class="headerlink" title="二、在 pom.xml 中引入支付宝SDK依赖"></a>二、在 pom.xml 中引入支付宝SDK依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- alipay --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alipay.sdk<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>alipay-sdk-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.34.0.ALL<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>经监测，开源的Java开发组件Fastjson存在远程代码执行漏洞，攻击者可利用上述漏洞远程执行任意代码。Java SDK（alipay-sdk-java）在4.34.0版本之前使用了存在漏洞的Fastjson版本（详情可查看 <a href="https://opendocs.alipay.com/rules/03f7dr">关于Fastjson漏洞预警的公告</a>）。</p>
<p>建议将上述SDK升级至 4.34.0 及以上版本</p>
<p>——摘自<a href="https://opendocs.alipay.com/common/02kkv2?pathHash=358ff034">官方文档</a></p>
</blockquote>
<h3 id="三、往-application-yml-中写入第一步获取到的配置信息"><a href="#三、往-application-yml-中写入第一步获取到的配置信息" class="headerlink" title="三、往 application.yml 中写入第一步获取到的配置信息"></a>三、往 application.yml 中写入第一步获取到的配置信息</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 支付宝沙箱</span></span><br><span class="line"><span class="attr">myalipay:</span></span><br><span class="line">    <span class="attr">gateway:</span> 			<span class="comment"># 支付宝网关地址</span></span><br><span class="line">    <span class="attr">appId:</span> 				<span class="comment"># 填入APPID</span></span><br><span class="line">    <span class="attr">appPrivateKey:</span>  	<span class="comment"># 填入Java应用私钥</span></span><br><span class="line">    <span class="attr">alipayPublicKey:</span>   	<span class="comment"># 填入应用公钥</span></span><br></pre></td></tr></table></figure>



<h3 id="四、编写-AlipayConfig-沙箱支付配置类"><a href="#四、编写-AlipayConfig-沙箱支付配置类" class="headerlink" title="四、编写 AlipayConfig 沙箱支付配置类"></a>四、编写 AlipayConfig 沙箱支付配置类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.alipaysandboxdemo.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alipay.api.DefaultAlipayClient;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 沙箱支付配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(&quot;myalipay&quot;)</span>	<span class="comment">// 第三步中yml配置的前缀</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AlipayConfig</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 沙箱支付网关</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String gateway;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 应用Id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String appId;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 应用私钥</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String appPrivateKey;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 支付宝公钥</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String alipayPublicKey;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 参数返回格式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">FORMAT</span> <span class="operator">=</span> <span class="string">&quot;JSON&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编码方式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CHARSET</span> <span class="operator">=</span> <span class="string">&quot;UTF-8&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 签名方式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SIGN_TYPE</span> <span class="operator">=</span> <span class="string">&quot;RSA2&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DefaultAlipayClient <span class="title function_">defaultAlipayClient</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultAlipayClient</span>(</span><br><span class="line">                gateway,</span><br><span class="line">                appId,</span><br><span class="line">                appPrivateKey,</span><br><span class="line">                FORMAT,</span><br><span class="line">                CHARSET,</span><br><span class="line">                alipayPublicKey,</span><br><span class="line">                SIGN_TYPE</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上述代码可见，向 AlipayConfig 类注入了第三步中写入的配置信息，并创建了一个 DefaultAlipayClient 的 Bean，后续沙箱支付的操作基本都使用 DefaultAlipayClient 完成。</p>
<h3 id="五、编写沙箱支付相关接口"><a href="#五、编写沙箱支付相关接口" class="headerlink" title="五、编写沙箱支付相关接口"></a>五、编写沙箱支付相关接口</h3><p>在编写接口请求之前，需要知道一件事：</p>
<p><strong>在服务器通过沙箱支付成功后，支付宝会发出一个携带本次支付相关信息参数的请求，通知该服务器</strong></p>
<p>服务器：这里指本地的 Springboot 后端程序</p>
<p>既然是请求，就需要给它提供一个接口访问，让它能够把本次支付信息传过来。</p>
<p><strong>问题是：</strong>支付宝发出的请求只能访问外网的地址，而在本地的 tomcat 服务器属于内网。</p>
<p>因此需要通过使用 <strong>内网穿透</strong> 工具获取一个临时的公网域名，让支付宝能够正常访问到。</p>
<h4 id="内网穿透"><a href="#内网穿透" class="headerlink" title="内网穿透"></a>内网穿透</h4><p><strong>这里使用 <a href="https://natapp.cn/">netapp</a> 搭建</strong></p>
<p><img src="/assets/image-20240419154343084.png" alt="image-20240419154343084"></p>
<p><strong>netapp 官方教程：</strong><a href="https://natapp.cn/article/natapp_newbie">https://natapp.cn/article/natapp_newbie</a></p>
<p><strong>&#x3D;&#x3D;注意：隧道对应的本地端口应改为自己的 Spring Boot 项目启动端口&#x3D;&#x3D;</strong></p>
<p><img src="/assets/image-20240419154814353.png" alt="image-20240419154814353"></p>
<p>如果忘记改了，也可以自己在 “我的隧道” 那里配置刚才创建的隧道</p>
<p>运行成功后，得到如下界面：</p>
<p><img src="/assets/image-20240419160102998.png" alt="image-20240419160102998"></p>
<p>&#x3D;&#x3D;注意：圈出来的是临时域名，每次重新运行都会更改，应该保证代码里写的是最新的域名&#x3D;&#x3D;</p>
<h4 id="编写-AlipayController-类"><a href="#编写-AlipayController-类" class="headerlink" title="编写 AlipayController 类"></a>编写 AlipayController 类</h4><p>为了省事，业务逻辑全部写在 Controller 中了，读者可自行分层封装，降低代码耦合。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.alipaysandboxdemo.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSONObject;</span><br><span class="line"><span class="keyword">import</span> com.alipay.api.AlipayApiException;</span><br><span class="line"><span class="keyword">import</span> com.alipay.api.DefaultAlipayClient;</span><br><span class="line"><span class="keyword">import</span> com.alipay.api.internal.util.AlipaySignature;</span><br><span class="line"><span class="keyword">import</span> com.alipay.api.request.AlipayTradePagePayRequest;</span><br><span class="line"><span class="keyword">import</span> com.alipay.api.request.AlipayTradeRefundRequest;</span><br><span class="line"><span class="keyword">import</span> com.alipay.api.response.AlipayTradeRefundResponse;</span><br><span class="line"><span class="keyword">import</span> com.example.alipaysandboxdemo.config.AlipayConfig;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/alipay&quot;)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AlipayController</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 沙箱支付配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> AlipayConfig alipayConfig;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 沙箱支付代理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> DefaultAlipayClient defaultAlipayClient;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 支付成功通知地址</span></span><br><span class="line"><span class="comment">     * todo: 确保更改为最新域名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NOTIFY_PATH</span> <span class="operator">=</span> <span class="string">&quot;http://eiabc3.natappfree.cc&quot;</span> + <span class="string">&quot;/alipay/notify&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 支付</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tradeNo   交易单号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> amount    商品名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/pay&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">alipay</span><span class="params">(String tradeNo, Double amount)</span> &#123;</span><br><span class="line">        <span class="comment">// 封装支付请求体</span></span><br><span class="line">        <span class="type">AlipayTradePagePayRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AlipayTradePagePayRequest</span>();</span><br><span class="line">        <span class="comment">// json请求体</span></span><br><span class="line">        <span class="type">JSONObject</span> <span class="variable">bizContent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>();</span><br><span class="line">        <span class="comment">// 交易单号</span></span><br><span class="line">        bizContent.put(<span class="string">&quot;out_trade_no&quot;</span>, tradeNo);</span><br><span class="line">        <span class="comment">// 商品名称</span></span><br><span class="line">        bizContent.put(<span class="string">&quot;subject&quot;</span>, <span class="string">&quot;遥遥领先 华为meta60&quot;</span>);</span><br><span class="line">        <span class="comment">// 交易金额</span></span><br><span class="line">        bizContent.put(<span class="string">&quot;total_amount&quot;</span>, amount);</span><br><span class="line">        <span class="comment">// 沙箱支付环境唯一配置</span></span><br><span class="line">        bizContent.put(<span class="string">&quot;product_code&quot;</span>, <span class="string">&quot;FAST_INSTANT_TRADE_PAY&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置支付宝通知地址</span></span><br><span class="line">        request.setNotifyUrl(NOTIFY_PATH);</span><br><span class="line">        request.setBizContent(bizContent.toString());</span><br><span class="line">        <span class="comment">// 支付</span></span><br><span class="line">        String formPage;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            formPage = defaultAlipayClient.pageExecute(request).getBody();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AlipayApiException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;订单支付异常：&quot;</span> + tradeNo, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 渲染页面</span></span><br><span class="line">        <span class="keyword">return</span> formPage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 支付成功通知接口</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/notify&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> AlipayApiException &#123;</span><br><span class="line">        <span class="comment">// 除了以下三个参数外，还有其他参数，可自行debug查看</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">tradeStatus</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;trade_status&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">tradeNo</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;out_trade_no&quot;</span>);</span><br><span class="line">        <span class="type">Double</span> <span class="variable">amount</span> <span class="operator">=</span> Double.valueOf(request.getParameter(<span class="string">&quot;total_amount&quot;</span>));</span><br><span class="line">        <span class="keyword">if</span> (!<span class="string">&quot;TRADE_SUCCESS&quot;</span>.equals(tradeStatus)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;订单支付失败：&quot;</span> + tradeNo);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 验签</span></span><br><span class="line">        Map&lt;String, String&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String name : request.getParameterMap().keySet()) &#123;</span><br><span class="line">            params.put(name, request.getParameter(name));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> AlipaySignature.getSignCheckContentV1(params);</span><br><span class="line">        <span class="type">String</span> <span class="variable">alipayPublicKey</span> <span class="operator">=</span> alipayConfig.getAlipayPublicKey();</span><br><span class="line">        <span class="type">String</span> <span class="variable">sign</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;sign&quot;</span>);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">check</span> <span class="operator">=</span> AlipaySignature.rsa256CheckContent(content, sign, alipayPublicKey, AlipayConfig.CHARSET);</span><br><span class="line">        <span class="keyword">if</span> (!check) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;订单验签异常：&quot;</span> + tradeNo);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 验签成功后，保存订单...</span></span><br><span class="line">        System.out.println(<span class="string">&quot;订单支付成功：&quot;</span> + tradeNo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 退款</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tradeNo   交易单号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> amount    商品名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/refund&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refund</span><span class="params">(String tradeNo, Double amount)</span> <span class="keyword">throws</span> AlipayApiException &#123;</span><br><span class="line">        <span class="comment">// 封装退款请求体</span></span><br><span class="line">        <span class="type">AlipayTradeRefundRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AlipayTradeRefundRequest</span>();</span><br><span class="line">        <span class="type">JSONObject</span> <span class="variable">bizContent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>();</span><br><span class="line">        bizContent.put(<span class="string">&quot;out_trade_no&quot;</span>, tradeNo);</span><br><span class="line">        bizContent.put(<span class="string">&quot;refund_amount&quot;</span>, amount);</span><br><span class="line">        request.setBizContent(bizContent.toString());</span><br><span class="line">        <span class="comment">// 退款</span></span><br><span class="line">        <span class="type">AlipayTradeRefundResponse</span> <span class="variable">response</span> <span class="operator">=</span> defaultAlipayClient.execute(request);;</span><br><span class="line">        <span class="keyword">if</span> (!response.isSuccess()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;订单退款失败：&quot;</span> + tradeNo);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 保存退款信息...</span></span><br><span class="line">        System.out.println(<span class="string">&quot;订单退款成功：&quot;</span> + tradeNo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>前后端分离</strong></p>
<p> &#x2F;alipay&#x2F;pay 支付接口返回的 formPage 实际上是一个 <strong>HTML片段</strong>，支付宝将我们发出的支付请求参数封装成了一个 <strong>form表单</strong> 并通过 <strong>script脚本</strong> 立即执行，用于跳转支付宝支付页面（需要联网）。</p>
<p>这里由于标注了 <code>@RestController</code> 注解，所以直接访问该接口直接渲染成一个页面。</p>
<p>如果你的项目是前后端分离，可以采用如下操作：</p>
<ol>
<li><p>将返回的 formPage 字符串数据插入到页面中，并切割掉 script脚本 手动执行。</p>
<blockquote>
<p><code>&lt;script&gt;form[0].submit()&lt;/script&gt;</code></p>
<p>因为 script脚本 默认执行页面中的第一个表单。</p>
</blockquote>
</li>
<li><p>搭建 iframe 容器，插入 formPage。</p>
</li>
</ol>
<h3 id="六、测试"><a href="#六、测试" class="headerlink" title="六、测试"></a>六、测试</h3><h4 id="测试支付接口"><a href="#测试支付接口" class="headerlink" title="测试支付接口"></a>测试支付接口</h4><p>这里的账号和密码是沙箱环境中的 <a href="https://openhome.alipay.com/develop/sandbox/account">沙箱账号</a></p>
<blockquote>
<p> <a href="http://localhost:8101/alipay/pay?tradeNo=1772919741251236385&amount=888">http://localhost:8101/alipay/pay?tradeNo=1772919741251236385&amp;amount=888</a></p>
</blockquote>
<p><img src="/assets/image-20240419163200727.png" alt="image-20240419163200727"></p>
<p><img src="/assets/image-20240419164512715.png" alt="image-20240419164512715"></p>
<p>支付完成后，支付宝发出通知到指定地址：</p>
<p><img src="/assets/image-20240419164607599.png" alt="image-20240419164607599"></p>
<h4 id="测试退款接口"><a href="#测试退款接口" class="headerlink" title="测试退款接口"></a>测试退款接口</h4><p>将刚刚支付的订单退款：</p>
<blockquote>
<p><a href="http://localhost:8101/alipay/refund?tradeNo=1772919741251236385&amount=888">http://localhost:8101/alipay/refund?tradeNo=1772919741251236385&amp;amount=888</a></p>
</blockquote>
<p><img src="/assets/image-20240419164750328.png" alt="image-20240419164750328"></p>
]]></content>
      <categories>
        <category>沙箱支付</category>
        <category>教程</category>
      </categories>
      <tags>
        <tag>沙箱支付</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Java多线程、SortedSet</title>
    <url>/2024/04/12/240412/</url>
    <content><![CDATA[<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p><strong>线程协调</strong></p>
<p>有时候因为业务逻辑的关系，代码之间是相互制约的，如果随意加锁就会导致死锁or逻辑死锁。</p>
<p>因此就需要借助 wait 和 notify 来完成一些配合操作。</p>
<p><strong>死锁</strong></p>
<p>多个服务需要同时获取多把锁，如果不同服务获取的锁出现交叉问题，就会造成死锁。</p>
<p>如：</p>
<ol>
<li>阻塞读 —— 写，自身交叉，没写就读不到，造成逻辑死锁</li>
<li>业务交叉，A 获取 A 锁，B 获取 B 锁，此时如果 A 需要获取 B 锁，B 又需要获取 A 锁，就会顺序交叉，同样造成物理死锁。</li>
</ol>
<p><strong>限流</strong></p>
<p>通过 Semaphore 信号量限制 acquire 的线程数。</p>
<p><strong>线程池</strong></p>
<p>因为创建新的线程，需要额外的开销。</p>
<p>如果一个线程执行完后让其释放，而后执行另一个任务又另起线程，这一创建和释放就会白耗很多性能。</p>
<p>因此就需要借助线程池，对执行完的线程进行回收，需要用到时再从线程池内取，减少了创建新线程的开销。</p>
<p><strong>CompletableFuture</strong></p>
<p>对 Future 异步执行返回结果的操作进行优化，可以在 complete 和 exception 时传入回调操作自动执行。</p>
<p>同时还支持多线程下的串行执行（单个 then），并行执行（any -&gt; 多个then），以及综合起来执行（any -&gt; 多个then）。</p>
<h1 id="点赞功能"><a href="#点赞功能" class="headerlink" title="点赞功能"></a>点赞功能</h1><p><strong>用户对同一篇笔记点赞和取消点赞</strong></p>
<p>实现：</p>
<ol>
<li><p>先判断该用户是否已点赞</p>
<p>从 Redis 的 SortedSet中调用score查询，如果没有分数，则表示该用户未点赞</p>
</li>
<li><p>未点赞</p>
<ol>
<li>MySQL 自增 liked 字段</li>
<li>加入 SortedSet 中，并将 score 设置为当前时间戳</li>
</ol>
</li>
<li><p>已点赞</p>
<ol>
<li>MySQL 自减 liked 字段</li>
<li>从 SortedSet 中移除</li>
</ol>
</li>
</ol>
<p>存在问题：</p>
<ol>
<li>并发，同时多个线程绕过点赞判断，出现一个用户对同一篇笔记多次点赞</li>
</ol>
<p><strong>显示点赞效果</strong></p>
<p>实现：</p>
<ol>
<li>给实体类添加 isLike 属性</li>
<li>从 redis 中查询 score</li>
</ol>
<p><strong>点赞显示的对象按时间先后排列</strong></p>
<p>实现：</p>
<ol>
<li>从 Redis 中按 ZRANGE 查询（升序：时间先后）</li>
<li>查询 MySQL 用户信息</li>
<li>限制 MySQL 返回结果排列 ORDER BY FIELD(“id”, id1, id2)</li>
<li>返回脱敏用户信息</li>
</ol>
]]></content>
      <categories>
        <category>Redis</category>
        <category>Java</category>
        <category>多线程</category>
        <category>锁</category>
      </categories>
      <tags>
        <tag>锁</tag>
        <tag>Java</tag>
        <tag>线程池</tag>
        <tag>CompletableFuture</tag>
        <tag>信号量</tag>
      </tags>
  </entry>
  <entry>
    <title>Transactional注解、Java工作路径、Paths类</title>
    <url>/2024/04/11/240411/</url>
    <content><![CDATA[<h1 id="Transactional-事务代理失效问题"><a href="#Transactional-事务代理失效问题" class="headerlink" title="@Transactional 事务代理失效问题"></a>@Transactional 事务代理失效问题</h1><p>在Spring中是通过aop增强对@Transactional注解标注的方法进行事务代理的。</p>
<p>但是如果通过 this 调用该方法，那么这个注解就会失效，也就是事务代理失效。</p>
<p><strong>原因：</strong> </p>
<p>aop的实现原理是在管理的bean中匹配切入点，然后对bean执行的方法进行增强。</p>
<p>而通过 this 调用，这个 this 是不被 Spring 管理的，如何找到它并且匹配切入点呢？？</p>
<p>简而言之，只有当该方法是被 Spring 的代理对象执行时，aop增强才会生效。</p>
<p><strong>事务加入问题</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Class Test &#123;</span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">proxyFunc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dbOperation1();</span><br><span class="line">        <span class="built_in">this</span>.dbOperation2();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 数据库操作1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dbOperation1</span><span class="params">()</span> &#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 数据库操作2</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dbOperation2</span><span class="params">()</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中存在一个被代理对象调用并标注 <code>@Transactional</code> 注解的 <code>proxyFunc</code> 方法，其内部通过 this 指针调用了两个数据库操作。</p>
<p><strong>这里的两个数据库操作会加入 proxyFunc 的事务吗？</strong></p>
<p>答案：会。</p>
<p>原因：因为 proxyFunc 已经被 @Transactional 增强了，开启了事务，那么其内部所有的数据库操作都会加入这个事务。</p>
<p><strong>事务冒泡问题</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Class Test &#123;</span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">proxyFunc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dbOperation1();</span><br><span class="line">        <span class="built_in">this</span>.dbOperation2();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 数据库操作1</span></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.NOT_SUPPORTED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dbOperation1</span><span class="params">()</span> &#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 数据库操作2</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dbOperation2</span><span class="params">()</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还是一样的代码，不过这次给数据库操作1标注了 <code>@Transactional(propagation = Propagation.NOT_SUPPORTED)</code> 不支持事务的注解，也表示不会加入其他事务。</p>
<p><strong>那么这个注解会生效吗？</strong></p>
<p>答案：不会</p>
<p>原因：因为数据库操作1是通过 this 调用的，而不是 proxy 代理对象，不会被aop“增强”，也就是注解失效！</p>
<p>不是最外层是 proxy 代理的，内部就都是它代理，可以回想一下 aop 增强的实现代码，本质是在目标方法的外层再包装一层逻辑，所以这个 proxy 只会包装最外层的注解增强代码，无法处理内部。</p>
<p><strong>那事务冒泡配置注解什么时候使用呢？</strong></p>
<p>可以在其他 service 的代码中使用，通过注入其代理对象，然后使用目标方法，这时候由于是 proxy 代理的，注解就会正常生效。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Class OtherService &#123;</span><br><span class="line">    <span class="comment">// 数据库操作1</span></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.NOT_SUPPORTED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dbOperation1</span><span class="params">()</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Class Test &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> OtherService otherService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">proxyFunc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 不支持事务注解正常生效</span></span><br><span class="line">        otherService.dbOperation1();</span><br><span class="line">        <span class="built_in">this</span>.dbOperation2();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 数据库操作2</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dbOperation2</span><span class="params">()</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如果需要分离方法体单独封装，又不能通过 this 调用，该如何保证目标方法事务生效呢</strong></p>
<p>答案：手动获取代理对象，然后通过代理对象调用目标方法；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Class TestService &#123;</span><br><span class="line">    <span class="comment">// 调用入口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">calledFunc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 需要引入 aspectjweaver aop依赖，并且开启 exposeProxy </span></span><br><span class="line">        (TestService) proxy = (TestService) AopContext.currentProxy();</span><br><span class="line">        proxy.sealedDBOperation();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 封装数据库操作</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sealedDBOperation</span><span class="params">()</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="获取工作目录根路径"><a href="#获取工作目录根路径" class="headerlink" title="获取工作目录根路径"></a>获取工作目录根路径</h1><p>通过 System 方法获取环境属性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">rootWorkPath</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;user.dir&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>拼接其他路径</strong></p>
<p>使用 <code>java.nio.file</code> 下的 <code>Paths</code> 工具类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(rootWorkPath, <span class="string">&quot;path1&quot;</span>, <span class="string">&quot;path2 ...&quot;</span>)</span><br></pre></td></tr></table></figure>



<h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><p>不可变对象也是线程安全的。</p>
<p>如 List、String 等。</p>
<p>但是引用提升至 List 的 ArrayList 实例同样是线程不安全的。</p>
<p>异步下，对 ArrayList 的插入操作，会导致 length 和 列表元素 出现错乱。</p>
<p><strong>为什么大部分类都是线程不安全的？</strong></p>
<p>因为线程安全会影响性能，应交由开发者自由控制。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>事务</tag>
        <tag>this调用失效</tag>
        <tag>工作路径</tag>
        <tag>Paths</tag>
        <tag>线程安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis的Stream消息队列应用</title>
    <url>/2024/04/07/240407/</url>
    <content><![CDATA[<h1 id="熟悉Stream"><a href="#熟悉Stream" class="headerlink" title="熟悉Stream"></a>熟悉Stream</h1><h2 id="独立消费者"><a href="#独立消费者" class="headerlink" title="独立消费者"></a>独立消费者</h2><p><strong>发布消息</strong></p>
<p><code>XADD KEY [NOMKSTREAM] *|ID field value [field value ...] </code></p>
<p>添加一条消息到 key 的队列中去，如果不存在则创建队列</p>
<p>*：自动生成id</p>
<p>ID：自定义id，需遵循时间戳-序号的格式</p>
<p>field，value：消息键值对，允许一条消息有多个键值对，类似hash</p>
<p>NOMKSTREAM：如果队列不存在，不会创建</p>
<p><strong>订阅消息</strong></p>
<p><code>XREAD COUNT count BLOCK milliseconds STREAMS key [key ...] ID [ID ...]</code></p>
<p>可以从多个stream中读取从ID往后的count条消息，如果暂时没有则等待xx毫秒</p>
<p>COUNT：读取数量</p>
<p>BLOCK：等待时间</p>
<p>ID：消息起始ID，可以传特殊值 0：第一个，$：最新消息。</p>
<blockquote>
<p>$：是最新消息，返回开启了阻塞等待后的第一条消息，存在漏读的问题，往后的二三条都读不到，如果COUNT为1。</p>
</blockquote>
<p><strong>特点</strong></p>
<ol>
<li>消息可以追溯，不是读完就消失了</li>
<li>一条消息可以被多个消费者读取</li>
<li>可以阻塞读取</li>
<li>有消息漏读的风险</li>
</ol>
<h2 id="消费者组"><a href="#消费者组" class="headerlink" title="消费者组"></a><strong>消费者组</strong></h2><p>将消息和消费者分组，每一组的消息由组内的消费者消费</p>
<p>特点：</p>
<ol>
<li>消息分流，同组的信息由多个消费者同时处理</li>
<li>消息标识，消费者组会维护一个标识，记录着最后一个被处理的消息，确保每次读取未处理的</li>
<li>消息确认，如果被读取的消息没有确认完成，会存在每个消费者的pending-list，供每个消费者继续消费。</li>
</ol>
<h3 id="创建消费者组"><a href="#创建消费者组" class="headerlink" title="创建消费者组"></a>创建消费者组</h3><p><code>XGROUP CREATE key groupName MKSTREAM</code></p>
<p>给stream创建一个消费者组，如果Stream不存在则自动创建</p>
<p>key：队列的key</p>
<p>groupName：消费者组名</p>
<p>MKSTREAM：自动创建队列</p>
<h3 id="消费者组读取消息"><a href="#消费者组读取消息" class="headerlink" title="消费者组读取消息"></a>消费者组读取消息</h3><p><code>XREADGROUP GROUP group consumer COUNT count BLOCK mills STREAMS key ID</code></p>
<p>先写命令 <code>XREADGROUP GROUP</code>，再写 <code>group consumer</code> 组名和消费者名，再写读取数量和等待时间，最后写队列key和起始消息ID</p>
<p>ID有两类特殊值：</p>
<ol>
<li>“&gt;”，从下一个未消费的消息开始</li>
<li>其他：从各自消费者的pending-list中取，例如0，表示list中的第一个消息。</li>
</ol>
<h3 id="确认消息"><a href="#确认消息" class="headerlink" title="确认消息"></a>确认消息</h3><p>xack </p>
<h1 id="异步秒杀应用Stream消息队列"><a href="#异步秒杀应用Stream消息队列" class="headerlink" title="异步秒杀应用Stream消息队列"></a>异步秒杀应用Stream消息队列</h1><p>准备工作：</p>
<ol>
<li>创建消费者组，自动创建队列</li>
</ol>
<p>书写lua代码：</p>
<ol>
<li>判断是否有秒杀资格</li>
<li>如果有则加入消息队列</li>
</ol>
<p>书写Java代码：</p>
<ol>
<li>持续监听下单消息</li>
<li>取出下单消息 xreadgroup</li>
<li>如果不存在，则继续监听</li>
<li>如果处理失败，就转入pending-list处理</li>
<li>取出待处理消息 xreadgroup</li>
<li>如果处理失败，继续取出处理，直到处理完毕</li>
<li>最后确认消息 xack streamKey groupName messageId</li>
</ol>
]]></content>
      <categories>
        <category>Redis</category>
        <category>Stream</category>
      </categories>
      <tags>
        <tag>Redis Stream</tag>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础</title>
    <url>/2024/04/03/Java-Common/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>Java是基于jvm虚拟机运行的跨平台语言</li>
<li>内置垃圾收集，不用考虑内存管理</li>
</ul>
<h3 id="JRE-和-JDK-介绍"><a href="#JRE-和-JDK-介绍" class="headerlink" title="JRE 和 JDK 介绍"></a>JRE 和 JDK 介绍</h3><p><strong>JRE：</strong> 用于运行 被编译为字节码class 的 Java 代码</p>
<p><strong>JDK：</strong>提供编译器，调试器等用于编写 Java 代码工具</p>
<blockquote>
<p>JRE: Java Runtime Environment</p>
<p>JDK: Java Development Kit</p>
</blockquote>
<p><strong>命令行常用命令</strong></p>
<ul>
<li>Java: 启动jvm虚拟机，运行编译为class字节码的代码。</li>
<li>Javac: 编译Java代码</li>
<li>Javadoc: 注释文档</li>
<li>jdb: 调试器</li>
</ul>
<p><strong>JDK与JRE的关系</strong></p>
<p>JDK &#x3D; JRE + 开发工具（Javac.exe等）</p>
<p>JRE &#x3D; JVM + Java API</p>
<blockquote>
<p>开发程序，需要用到JDk，因为要用Javac编译.Java文件</p>
<p>运行程序，只需要用到JRE，包含了Java API</p>
</blockquote>
<h3 id="名词介绍"><a href="#名词介绍" class="headerlink" title="名词介绍"></a>名词介绍</h3><ol>
<li>JSR规范: Java Specification Request</li>
<li>JCP组织: Java Community Process</li>
</ol>
<blockquote>
<p> JSR规范用于保证 Java 语言的规范性。</p>
<p> 凡是想给 Java 平台添加一个功能，比如说访问数据库的功能，需要先创建一个 JSR规范，定义好接口。</p>
<p> 各个数据库平台必须按照规范实现该接口，开发者就用同样的API访问各个数据库平台。</p>
</blockquote>
<ol start="5">
<li>RI: Reference Implementation</li>
<li>TCK: Technology Compability Kit</li>
<li>IDE: Integrated Development Environment</li>
</ol>
<h2 id="语法规则"><a href="#语法规则" class="headerlink" title="语法规则"></a>语法规则</h2><h3 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h3><ul>
<li>变量、类名 必须以英文字母开头，后接字母，数字和下划线的组合</li>
<li>**类名 **习惯首字母大写</li>
<li>如果单个源文件中有多个类，那么只能有一个类是public类，表示该文件的主入口</li>
</ul>
<blockquote>
<p>在java编程思想（第四版）一书中有这样3段话（6.4 类的访问权限）：</p>
<p>每个编译单元（文件）都只能有一个public类，使得每个编译单元都有单一的公共接口，用public类来表现。该接口可以按要求包含众多的 支持包访问权限 的类。</p>
<p>如果在某个编译单元内有一个以上的public类，就不知道使用哪个类导致无法编译。</p>
<p>同时允许编译单元内完全不带public类，这时候可能会并入其他编译单元编译，并且启动该文件时需手动指定数据来源（文件内存在的多个class）</p>
</blockquote>
<ul>
<li>源文件的名字必须与 public 类的类名相同</li>
<li>如果源文件中没有 public 类，则文件名可以是任意的</li>
</ul>
<h3 id="Hello-world分析"><a href="#Hello-world分析" class="headerlink" title="Hello world分析"></a>Hello world分析</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>main方法必须声明为静态方法，作为程序执行入口</li>
<li>在书写完Java文件后，使用Javac命令编译源文件</li>
</ul>
<blockquote>
<p>  javac -encoding&#x3D;utf-8 Hello.java</p>
<p>  如果文件编码非utf-8需使用encoding选项指定编码格式</p>
</blockquote>
<ul>
<li>运行代码</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java Hello <span class="comment"># 不需要带.class扩展名</span></span><br></pre></td></tr></table></figure>



<h3 id="主类"><a href="#主类" class="headerlink" title="主类"></a>主类</h3><p>Java程序的执行入口是main方法，&#x3D;&#x3D;包含有main方法的类称为主类&#x3D;&#x3D;</p>
<ul>
<li>一个Java源文件中可以有零个或多个主类。</li>
</ul>
<blockquote>
<p>  假如一个Java文件中有3个类，则在编译后会生成3个class文件</p>
<p>  只有包含main方法的主类才能使用Java命令运行</p>
</blockquote>
<ul>
<li>如果程序中包含主类，则称为Java应用程序。没有就叫做Java库程序，通常被用来让其他Java程序调用.</li>
</ul>
<h3 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h3><blockquote>
<p>从源代码到可执行代码，称为编译，也称为正向工程。</p>
<p>从可执行代码到源代码，称为反编译，也称为逆向工程。</p>
</blockquote>
<p>可用 javap命令实现反编译。</p>
<blockquote>
<p> 但并没有实现完全的反编译，只反编译到<strong>方法声明</strong>这一层，<u>无法反编译方法内的代码。</u></p>
</blockquote>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><ol>
<li>&#x2F;&#x2F;…          单行注释</li>
<li>&#x2F;* … *&#x2F;   多行注释</li>
<li>&#x2F;** … *&#x2F; 文档注释</li>
</ol>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ol>
<li>整数类型：byte，short，int，long</li>
<li>浮点数类型：float，double</li>
<li>字符类型：char</li>
<li>布尔类型： boolean</li>
</ol>
<blockquote>
<p>只有 true 和 false 两个值。</p>
<p>Java语言对布尔类型的存储并没有做规定。</p>
<p>理论上存储布尔类型只需要1 bit，但是通常 JVM 内部会把boolean表示为4字节整数&#x3D;&#x3D;。</p>
</blockquote>
<ol start="5">
<li><u>引用类型</u>，类似如C语言的指针。</li>
</ol>
<blockquote>
<p>在Java中，对象的实例化变量常为引用类型</p>
</blockquote>
<ol start="6">
<li><p>常量，使用final关键字声明。</p>
</li>
<li><p>var关键字</p>
<p>当类型名太长可以用var来进行声明，编译器会根据赋值语句来自动推断出该变量的类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>特殊规则</strong></p>
<ul>
<li>Java只定义了带符号的整型，即最高位为符号位。如，<u>int 最大值为 2^31-1</u></li>
<li>支持使用 _ 来连接数字，结果和原数一致。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">2_000</span>;</span><br><span class="line">System.out.println(x);</span><br><span class="line"><span class="comment">// 输出: 2000</span></span><br></pre></td></tr></table></figure>

<ul>
<li>0前缀表示八进制</li>
<li>0x前缀表示十六进制</li>
<li>0b前缀表示二进制</li>
<li>long类型需在数字后加上字母大小写 “L”</li>
<li><strong>定义float类型变量时末尾一定要加上字母大小写”F”，因为默认浮点数为双精度（double）类型</strong></li>
</ul>
<h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ol>
<li><p><code>/</code> 除法运算符</p>
</li>
<li><p><code>%</code> 求余运算符</p>
</li>
<li><p><code>&gt;&gt;</code> 右移运算符，无法移动符号位，即负数右移后还是负数</p>
</li>
<li><p><code>&gt;&gt;&gt;</code> 可以移动符号位的右移运算符</p>
</li>
<li><p><code>&lt;&lt;</code> 左移运算符同理，不存在向左移动符号位的运算符。</p>
<blockquote>
<p>对<code>byte</code>和<code>short</code>类型进行移位时，会首先转换为<code>int</code>再进行位移。</p>
</blockquote>
</li>
<li><p><code>++</code>，<code>--</code> 自增自减运算符只能用于 整型 和 浮点型 变量。</p>
</li>
<li><p><code>instanceof</code> 运算符，判断前者是否为后者的实例化对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">a <span class="keyword">instanceof</span> Integer; <span class="comment">//得到true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>位运算：<code>&amp;</code>，<code>|</code>，<code>~</code>，<code>^</code> 分别是与，或，非，异或运算。</p>
</li>
<li><p>逻辑运算符：<code>&amp;&amp;</code>，<code>||</code>，<code>！</code> 的操作元必须是boolean型数据。</p>
</li>
</ol>
<h3 id="整数运算"><a href="#整数运算" class="headerlink" title="整数运算"></a>整数运算</h3><ol>
<li>两个整数相除只能得到结果的整数部分（即舍弃余数得到整数）</li>
<li>整数的除法对于除数为0时运行时将报错，但编译不会报错。</li>
</ol>
<p><strong>溢出：</strong></p>
<p>整数由于存在范围限制，如果计算结果超出了范围，就会产生溢出，而溢出<em>不会出错</em>，却会得到一个奇怪的结果。（占据符号位，成为负数）</p>
<h3 id="浮点数运算"><a href="#浮点数运算" class="headerlink" title="浮点数运算"></a>浮点数运算</h3><p><strong>浮点数比较正确做法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">r</span> <span class="operator">=</span> Math.abs(x - y); <span class="comment">// 取绝对值</span></span><br><span class="line"><span class="comment">// 精度范围</span></span><br><span class="line"><span class="keyword">if</span> (r &lt; <span class="number">0.00001</span>) &#123;</span><br><span class="line">    <span class="comment">// 认为相等</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 不相等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<p>在一个复杂的四则运算中，两个整数的运算不会出现自动提升的情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">1.2</span> + <span class="number">24</span> / <span class="number">5</span>; <span class="comment">// d = 1.2 + 4</span></span><br></pre></td></tr></table></figure>

<p>原因：类型提升指的是最后赋值的时候，而算式中 24 &#x2F; 5 依然遵循整数运算规则。</p>
<p><strong>溢出：</strong></p>
<p>整数运算在除数为<code>0</code>时会报错，而浮点数运算在除数为<code>0</code>时，不会报错，但会返回几个特殊值：</p>
<ul>
<li><code>NaN</code>表示Not a Number</li>
<li><code>Infinity</code>表示无穷大</li>
<li><code>-Infinity</code>表示负无穷大</li>
</ul>
<h3 id="布尔运算"><a href="#布尔运算" class="headerlink" title="布尔运算"></a>布尔运算</h3><p><strong>短路运算：</strong>如果一个布尔运算的表达式能提前确定结果，则后续的计算不再执行，直接返回结果。</p>
<h3 id="运算精度"><a href="#运算精度" class="headerlink" title="运算精度"></a><strong>运算精度</strong></h3><ul>
<li>如果表达式中最高精度低于Int型整数，则按int精度计算</li>
</ul>
<blockquote>
<p>如 ‘a’ + ‘b’ &#x3D; int型数字</p>
<p>byte x&#x3D;7; 则执行表达式 ‘B’+x; 的结果是int型。</p>
</blockquote>
<ul>
<li>char型数据和整型数据运算结果的精度是int精度</li>
<li>Java允许把不超出取值范围的算术表达式赋值给对应类型，<strong>但是当算术表达式中含有变量的时候，只会检查变量的类型</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">z</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">2</span> + z; <span class="comment">// 将int转化为byte类型，报错</span></span><br></pre></td></tr></table></figure>

<p>类型遵循自动&#x3D;&#x3D;小转大&#x3D;&#x3D;，不支持&#x3D;&#x3D;大转小&#x3D;&#x3D;（可以强制转型）</p>
<p><strong>强制转型：</strong>超出范围的强制转型会得到错误的结果</p>
<p>如 int -&gt; short：<code>int</code>的两个高位字节直接被扔掉，仅保留了低位的两个字节</p>
<ul>
<li>较小类型和较大类型运算，结果会自动转化为较大类型。</li>
</ul>
<h2 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h2><p>Java 在内存中总是使用 Unicode 表示字符。</p>
<p>所以 char 类型占用两个字节。</p>
<p>可以用转义字符 <code>\u</code> + Unicode编码（十六进制）表示一个字符</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意是十六进制:</span></span><br><span class="line"><span class="type">char</span> <span class="variable">c3</span> <span class="operator">=</span> <span class="string">&#x27;\u0041&#x27;</span>; <span class="comment">// &#x27;A&#x27;，因为十六进制0041</span></span><br></pre></td></tr></table></figure>





<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><ul>
<li><code>\&quot;</code> 表示字符<code>&quot;</code></li>
<li><code>\&#39;</code> 表示字符<code>&#39;</code></li>
<li><code>\\</code> 表示字符<code>\</code></li>
<li><code>\n</code> 表示换行符</li>
<li><code>\r</code> 表示回车符</li>
<li><code>\t</code> 表示Tab</li>
<li><code>\u####</code> 表示一个Unicode编码的字符</li>
</ul>
<h3 id="不可变特性"><a href="#不可变特性" class="headerlink" title="不可变特性"></a>不可变特性</h3><p>字符串的内容是常量，不可改变，<strong>无法通过索引元素改变其值</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串变了吗？</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">s1 = <span class="string">&quot;world&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>字符串变量为引用类型</p>
<p>对其再次赋值，仅仅改变其指向的内存，原内容依旧存在。</p>
<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a><strong>功能</strong></h3><ol>
<li><p>可以使用 “+” 连接字符串</p>
<p>也可以用 “+” 连接字符串和其他数据类型，结果为字符串类型，被拼接的其他数据类型自身不会改变。</p>
</li>
<li><p>‘’’ … ‘’’ 三引号用于表示多行字符串，<strong>Java 13 以后</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">...........SELECT * FROM</span></span><br><span class="line"><span class="string">...........  users</span></span><br><span class="line"><span class="string">...........WHERE id &gt; 100</span></span><br><span class="line"><span class="string">...........ORDER BY name DESC</span></span><br><span class="line"><span class="string">...........&quot;&quot;&quot;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong>字符串s占据&#x3D;&#x3D;5行&#x3D;&#x3D;，因为在desc后面还有一个’\n’，如果不想要5行，可以直接把三引号写在结尾</p>
<p><strong>排版：</strong>最后会根据每行字符的相对位置来显示，共同的空格会被忽略，不规则排版则是以最短的空格为基准。</p>
</li>
<li><p>null 与 “” 的区别</p>
<p>null：一个引用空值。</p>
<p>“”：一个空的字符串，并不是空值。</p>
</li>
</ol>
<h3 id="在引用的使用"><a href="#在引用的使用" class="headerlink" title="== 在引用的使用"></a><code>==</code> 在引用的使用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;HELLO&quot;</span>.toLowerCase();</span><br><span class="line">System.out.println(a == b); <span class="comment">// false</span></span><br><span class="line"><span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> a;</span><br><span class="line">System.out.println(a == c); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>原因是：<code>==</code> 用于判断两者是否为同一个引用，而不是判断内容是否一致。</p>
<p>判断字符串内容相等可以使用String类型的equals方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a.equals(b)</span><br></pre></td></tr></table></figure>



<p><strong>低内存的特殊</strong></p>
<p>对于数值占用内存较少的情况，JVM 为了节省内存空间，在创建不同变量的时候指向的内存地址都是一样的。</p>
<p>如在128以内（不包括128）的数字</p>
<p>当有多个引用指向它们时，地址是一样的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">System.out.println(a == b); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>



<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>Java 中为了保存 C 语言开发的习惯，保留了<code>int arr[]</code> 和 <code>int[] arr</code> 声明数组类型的形式。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ol>
<li><p>new关键字</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>可以把 <code>int[]</code> 看做一整个数组类，new 出一个 int[] 的对象。</p>
</li>
<li><p>数组常量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>数组常量只能用于初始化，不能声明再赋值。</p>
</li>
</ol>
<h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ol>
<li><p>int[] 括号内不需要指定数字，在初始化的时候会自动推断。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &#123;&#125;内指定了数组元素，这里的3可以省略</span></span><br><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>

<p>如果没有指定，也没有指定数字（数组长度），那这个数组长度只有就是0。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明一个长度为 10 的数组，默认值为 0</span></span><br><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化后，数组的长度将不可改变，超出长度的索引会报异常。</p>
</li>
<li><p>创建的数组元素，如果没有赋予初值，会被赋予默认值</p>
<ul>
<li><p>数值型基本数据类型的默认值是 0</p>
</li>
<li><p>char 类型的默认值为 ‘\u0000’ </p>
</li>
<li><p>boolean 类型默认值为 false。</p>
</li>
</ul>
</li>
<li><p>通过访问 length 属性可以获得数组的长度。</p>
</li>
</ol>
<p><strong>注意：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    String[] names = &#123;<span class="string">&quot;ABC&quot;</span>, <span class="string">&quot;XYZ&quot;</span>, <span class="string">&quot;zoo&quot;</span>&#125;;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> names[<span class="number">1</span>];</span><br><span class="line">    names[<span class="number">1</span>] = <span class="string">&quot;cat&quot;</span>;</span><br><span class="line">    System.out.println(s);	<span class="comment">// s是被赋值为XYZ了，而不是names[1]的引用</span></span><br><span class="line">    System.out.println(Arrays.toString(names)); <span class="comment">// [ABC, cat, Zoo]</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>names[1] 是一个元素，不是引用。</p>
<h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><p><strong>初始化</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[][] ns = &#123;</span><br><span class="line">    &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;,</span><br><span class="line">    &#123; <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span> &#125;,</span><br><span class="line">    &#123; <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// new</span></span><br><span class="line"><span class="type">int</span>[][] ns = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;</span><br><span class="line">    &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;,</span><br><span class="line">    &#123; <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span> &#125;,</span><br><span class="line">    &#123; <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>打印多维数组</strong></p>
<p>打印多维数组可以使用<code>Arrays.deepToString()</code>；</p>
<h3 id="排序数组"><a href="#排序数组" class="headerlink" title="排序数组"></a>排序数组</h3><p>使用 Arrays 类的成员函数sort，可对数组进行排序</p>
<p><strong>默认小到大排列</strong>: Arrays.sort(arr);</p>
<p><strong>逆序</strong>: Arrays.sort(arr，Collections.reverseOrder())</p>
<p>sort 不能直接用于排列多维数组，&#x3D;&#x3D;使用什么可以排序多维数组呢&#x3D;&#x3D;</p>
<p>多维数组不需要排序，本质是处理每个一维数组。</p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ol>
<li>使用 Scanner 类初始化数组</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> n: arr)&#123;</span><br><span class="line">    n = scanner.nextInt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>随机打乱</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[index];</span><br><span class="line">    arr[index] = arr[arr.length - <span class="number">1</span>];</span><br><span class="line">    arr[arr.length - <span class="number">1</span>] = temp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line"> 		<span class="comment">// 随机位置与数组的最后一个元素交换</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (<span class="type">int</span>)(Math.random() * arr.length);</span><br><span class="line">        swap(arr, index);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Arrays.toString(arr));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：使用传递&#x3D;&#x3D;数组引用&#x3D;&#x3D;的方式才能在 不同作用域 交换数组内的值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Swap</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr，<span class="type">int</span> i，<span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String args[ ])</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>，<span class="number">2</span>&#125;;</span><br><span class="line">        Swap.swap(arr，<span class="number">0</span>，<span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr)); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>复制数组</p>
<ol>
<li><p>使用Java.util.Arrays的静态方法copyOf复制数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">newArr = Arrays.copyOf(oldArr，neededLength);</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用System类中的静态方法arraycopy</p>
</li>
<li><p>使用clone方法复制数组</p>
</li>
</ol>
</li>
<li><p>for each循环</p>
<p>对于可迭代对象，使用for循环的”for each”形式会显得更加简洁</p>
<p>形式: for( varName :  arrayName) {…}</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span>，<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> n: arr)&#123;</span><br><span class="line">            System.out.println(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>这里的n，代表数组中的每个元素，而不是索引值</p>
</li>
<li><p>使用该方法遍历数组，无法控制访问顺序</p>
</li>
<li><p>for each循环还可用于List，Map等数据结构</p>
</li>
</ul>
</li>
<li><p>转 Stream 流</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.stream(arr)</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h2><blockquote>
<p>在使用 java 命令执行 java 文件的时候</p>
</blockquote>
<p>可以传入 …String 类型的参数，由 public 类的入口函数 main 的 args 参数获取</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java Main &quot;123&quot; &quot;456&quot;</span><br><span class="line">// args: [&quot;123&quot;, &quot;456&quot;]</span><br></pre></td></tr></table></figure>





<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><blockquote>
<p> 通常使用Scanner类的实例对象来接受用户输入</p>
</blockquote>
<p>Scanner 类包含在 <code>java.util</code> 包内，需要先引入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">myScan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);	<span class="comment">// 传入输入流</span></span><br><span class="line">        <span class="comment">// 使用nextInt()获取整型数据</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> myScan.nextInt();</span><br><span class="line">        <span class="comment">// 使用nextLine()获取一行字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> myScan.nextLine();</span><br><span class="line">        <span class="comment">// next...等等</span></span><br><span class="line">        <span class="comment">// 使用完毕后，关闭输入流</span></span><br><span class="line">        myScan.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong> </p>
<p>nextInt 表示获取用户的下一个输入并转化为 int 类型，不是从输入中获取下一个 int 类型</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用户输入</span></span><br><span class="line">a 123</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">nextInt 会接收 a</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">并抛出 java.util.InputMismatchException 异常</span></span><br></pre></td></tr></table></figure>



<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>使用System.out输出流向输出端输出数据</p>
<ul>
<li>System.out.println() 输出一行</li>
<li>System.out.print()    直接输出</li>
<li>System.out.printf()   格式化输出</li>
</ul>
<p><strong>格式字符：</strong></p>
<p>%d 输出整型数据</p>
<p>%c 输出字符型数据</p>
<p>%f 输出浮点型数据</p>
<p>使用如%m.nd形式，可以控制输出的排版。</p>
<p>m：数字所占位数</p>
<p>n：小数位数</p>
<p><strong>注意</strong>：因为 % 表示占位符，所以连续两个 %% 才表示一个 % 字符本身。</p>
<h3 id="if判断"><a href="#if判断" class="headerlink" title="if判断"></a>if判断</h3><p>if 中表达式必须是 &#x3D;&#x3D;boolean类型&#x3D;&#x3D;，不能使用 0，1，null 代替</p>
<h3 id="switch新用法"><a href="#switch新用法" class="headerlink" title="switch新用法"></a>switch新用法</h3><p>switch 中 case 的条件必须是常量，枚举也可以。</p>
<p><strong>Java 12</strong> 开始，使用 <code>-&gt;</code> 符号可以<strong>无需break</strong>，直接指定执行单一路径，而不会继续向下执行其他语句</p>
<p>switch 将返回被执行 case 条件的结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">fruit</span> <span class="operator">=</span> <span class="string">&quot;apple&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">opt</span> <span class="operator">=</span> <span class="keyword">switch</span> (fruit) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;apple&quot;</span> -&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;pear&quot;</span> -&gt; <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">default</span> -&gt; <span class="number">0</span>;</span><br><span class="line">        &#125;;	<span class="comment">// 赋值语句后以 ; 结束</span></span><br><span class="line">        System.out.println(opt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果需要使用复杂的语句，可以使用花括号{}包裹，再通过yield关键字返回值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&quot;mango&quot;</span> -&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">code</span> <span class="operator">=</span> fruit.hashCode();</span><br><span class="line">    <span class="keyword">yield</span> code;		<span class="comment">// code作为该分支的返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>从 Java 13 开始允许使用yield返回值</p>
</blockquote>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><h4 id="while"><a href="#while" class="headerlink" title="while"></a><strong>while</strong></h4><p>while循环中的判断条件必须是一个 boolean 值，如 3 &gt; 2 的结果，而不能直接放一个数字</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">      <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123; <span class="comment">// 在C语言中可以直接写为 n</span></span><br><span class="line">         res += n--;</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(res);</span><br><span class="line">   &#125; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>对于循环条件判断，以及自增变量的处理，要特别注意边界条件。思考一下下面的代码为何没有获得正确结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">            n ++;</span><br><span class="line">            sum = sum + n;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum); <span class="comment">// 5151</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>n的边界是 0 -&gt; 100，当 n &#x3D; 100 时，会再次进入循环，n 变成了 101。</p>
<p>导致结果多加了一个 101，原本为 5050</p>
<p>将这个操作改为 for 循环则不会有这个问题，因为 自增变量 始终作为后置条件在循环体内执行完之后。</p>
<h4 id="do-while"><a href="#do-while" class="headerlink" title="do while"></a>do while</h4><p>改写 while 循环的 1 到 100 求和</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            sum = sum + n;</span><br><span class="line">            n ++;</span><br><span class="line">        &#125; <span class="keyword">while</span> (n &lt;= <span class="number">100</span>);</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4><p>改写 1 到 100 求和</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">100</span>; i++) &#123;</span><br><span class="line">            sum = sum + i;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>计数器定义位置</strong></p>
<p>如果变量 <code>i</code> 定义在 <code>for</code> 循环外：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int[] ns = &#123; 1, 4, 9, 16, 25 &#125;;</span><br><span class="line">int i;</span><br><span class="line">for (i=0; i&lt;ns.length; i++) &#123;</span><br><span class="line">    System.out.println(ns[i]);</span><br><span class="line">&#125;</span><br><span class="line">// 仍然可以使用i</span><br><span class="line">int n = i;</span><br></pre></td></tr></table></figure>

<p>破坏了<strong>变量应该把访问范围缩到最小</strong>的原则。</p>
<h4 id="for-each"><a href="#for-each" class="headerlink" title="for each"></a>for each</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] ns = &#123; <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span> &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> n : ns) &#123;</span><br><span class="line">            System.out.println(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和<code>for</code>循环相比，<code>for each</code>循环的变量n不再是计数器，而是直接对应到数组的每个元素。</p>
<p>除了数组外，<code>for each</code>循环能够遍历所有“可迭代”的数据类型，包括后面会介绍的<code>List</code>、<code>Map</code>等。</p>
<h4 id="break-和-continue"><a href="#break-和-continue" class="headerlink" title="break 和 continue"></a>break 和 continue</h4><p>break：跳出最近一层循环，多层循环只能跳出一层</p>
<p>continue：跳出本次循环，执行下一个符合条件的循环</p>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h5 id="0-特点"><a href="#0-特点" class="headerlink" title="0. 特点"></a>0. 特点</h5><ul>
<li>封装性</li>
<li>继承</li>
<li>多态</li>
</ul>
<h5 id="1-字段"><a href="#1-字段" class="headerlink" title="1. 字段"></a>1. 字段</h5><blockquote>
<p>字段即成员变量</p>
</blockquote>
<p>​	没有初始化的引用字段，默认为null值; 其他类型的也是默认值，如Int类型是0，boolean是false;</p>
<h6 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h6><ul>
<li>静态方法可以通过对应类的空对象访问</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="literal">null</span>;	<span class="comment">// 定义Test类空对象</span></span><br><span class="line">        test.f1();			<span class="comment">// 使用空对象访问静态方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>:</p>
<ul>
<li>在&#x3D;&#x3D;成员函数内部&#x3D;&#x3D;声明的局部变量不会自动初始化，需要初始化后才可引用</li>
<li>无论成员变量，和成员函数声明定义的顺序如何，&#x3D;&#x3D;成员变量是先与成员函数生成的&#x3D;&#x3D;，所以可以出现以下这种情况</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> m; <span class="comment">// m被定义为成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>不能在成员函数中定义<strong>与参数重名</strong>的变量</li>
<li>可以在成员函数中定义与成员变量同名的变量，定义的局部变量会覆盖成员变量。</li>
</ul>
<h5 id="2-构造函数"><a href="#2-构造函数" class="headerlink" title="2. 构造函数"></a>2. 构造函数</h5><blockquote>
<p>构造函数支持重载(Overload)</p>
</blockquote>
<p>​	Java中可以通过<strong>this引用</strong>可以在一个构造函数中调用其他构造函数，<u>但是C++不行</u>，因为可以有默认参数， 所以就没有构造函数的相互调用了，但是C++可以调用父类的构造函数</p>
<h5 id="3-this关键字"><a href="#3-this关键字" class="headerlink" title="3. this关键字"></a>3. this关键字</h5><ul>
<li>this是Java的一个关键字，表示某个对象<ul>
<li>在构造方法中，代表该构造方法所创建的对象。</li>
<li>实例方法中，代表正在调用该方法的当前对象。</li>
</ul>
</li>
<li>this不能用于类成员变量和类方法。</li>
<li>可用this调用被隐藏的成员变量</li>
</ul>
<blockquote>
<p>如：当局部变量和成员变量重名时，可以使用this.成员变量访问到它</p>
</blockquote>
<h5 id="4-包"><a href="#4-包" class="headerlink" title="4. 包"></a>4. 包</h5><p>包是一种用来管理类的机制，可以有效地区分名字相同的类</p>
<p><strong>使用方法</strong>：</p>
<ul>
<li>用package 包名;语句声明该源文件所在的包</li>
</ul>
<p><strong>注意事项</strong>：</p>
<ul>
<li>该语句必须作为源文件的第一行语句。</li>
<li>建议用域名反写的方式建包（目前还没有看懂）。</li>
<li>包的名字，必须为源文件所在路径，不能随意起名。</li>
</ul>
<blockquote>
<p>如tom&#x2F;jiafei&#x2F;路径下有Test.Java文件，则该文件的包名可以为tom.jiafei</p>
</blockquote>
<p><strong>运行方式</strong>：</p>
<p>​	如果主类的包名是tom.jiafei，就<strong>必须到</strong>tom\jiafei的上一层（即tom的父目录）目录中去运行主类。</p>
<blockquote>
<p>假设tom\jiafei的上一层目录是1000，那么必须用如下格式来运行： C:\1000&gt; Java tom.jiafei.主类名</p>
</blockquote>
<p><strong>import语句</strong></p>
<p>既然有包的建立，那必然有引用包。</p>
<blockquote>
<p>系统会自动导入Java.lang包中所有的类。</p>
</blockquote>
<p>通过import语句，可以使该源文件能够调用其他包中的类。</p>
<p>&#x3D;&#x3D;父包和子包没有关系，包含的类也没有关系&#x3D;&#x3D;</p>
<h5 id="5-修饰符"><a href="#5-修饰符" class="headerlink" title="5. 修饰符"></a>5. 修饰符</h5><p>Java使用四种修饰符，来限制类中的成员变量和成员函数被访问的权限</p>
<ul>
<li>public类。 该类成员可以被所有类访问</li>
<li>protected类。 该类成员只能被同一文件，同一包内的类或子类访问。</li>
<li>没有修饰符的称为default类。 只能被同一文件，和同一包内的类访问。</li>
</ul>
<blockquote>
<p>子类不能访问指：其他包通过引用该包，然后继承该包中的某一个类，该子类无法访问父类的成员。</p>
</blockquote>
<p>&#x3D;&#x3D;事实证明即使是default类，只要其子类在同一个文件或包，依旧能够访问父类成员。&#x3D;&#x3D;</p>
<ul>
<li>private类。 该类成员只能被自己访问。</li>
</ul>
<h5 id="6-包装类"><a href="#6-包装类" class="headerlink" title="6. 包装类"></a>6. 包装类</h5><p>为了方便基本数据类型的使用，Java提供了基本数据类型的相关类，实现了对其的封装。</p>
<p>如：Integer,Character,Byte等类。</p>
<p>构造方法如：Integer a &#x3D; new Integer(2);</p>
<p>返回类中包含的值：a.value();</p>
<h5 id="7-上转型对象"><a href="#7-上转型对象" class="headerlink" title="7. 上转型对象"></a>7. 上转型对象</h5><p>将子类的对象传递给父类引用，称为上转型对象。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Father</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line"><span class="comment">// 第二种情况</span></span><br><span class="line">Father f;</span><br><span class="line"><span class="type">Son</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">f = s;</span><br></pre></td></tr></table></figure>

<p><strong>使用</strong>：</p>
<ul>
<li>不可以使用子类新增的成员（变量、函数）</li>
<li>可以使用子类继承和重写的方法</li>
<li>可以使用子类隐藏的成员变量</li>
</ul>
<blockquote>
<p>如：父类有int a变量，而子类定义了同名变量double a，而上转型对象调用的是父类的a变量。</p>
</blockquote>
<p>&#x3D;&#x3D;不支持向下转型，会报出ClassCastException&#x3D;&#x3D;</p>
<p><strong>多态</strong></p>
<p>多态就是指父类的某个方法被子类重写后产生自己的功能行为，各个子类都不同。</p>
<h5 id="8-抽象类"><a href="#8-抽象类" class="headerlink" title="8. 抽象类"></a>8. 抽象类</h5><p>用于定义共有的属性（变量、方法），合理地使用抽象类，可以写出易维护、易扩展的程序。</p>
<p>&#x3D;&#x3D;抽象类可以没有abstract方法&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;不可以使用static修饰抽象类&#x3D;&#x3D;，因为抽象类没有实例吧。</p>
<p><strong>使用</strong>：</p>
<ul>
<li>具备一般类的基本能力，可以有字段、构造方法；<strong>但不能实例化abstract类对象</strong></li>
<li>不能用final修饰抽象类，因为定义抽象类就是要用来继承的。</li>
<li>抽象类的非抽象子类必须实现抽象父类的所有抽象方法。</li>
</ul>
<p><strong>缺点</strong>：&#x3D;&#x3D;Java中只能继承一个类，所以抽象类并不完善&#x3D;&#x3D;</p>
<h5 id="9-接口"><a href="#9-接口" class="headerlink" title="9. 接口"></a>9. 接口</h5><p>为了弥补只能继承一个类的缺陷，Java定义了接口概念。</p>
<p>接口和抽象类差不多，但是比抽象类更加标准化。接口还有一个优势：&#x3D;&#x3D;允许非同一父类的子类拥有相同名称的方法。&#x3D;&#x3D;</p>
<p><strong>使用</strong>：</p>
<p>通过interface 接口名{}，与定义一个类差不多的形式定义接口；</p>
<ul>
<li>接口中不存在变量。&#x3D;&#x3D;声明常量时必须初始化，不具有默认值&#x3D;&#x3D;</li>
</ul>
<p>类似int MAX &#x3D; 100;</p>
<p>等价于：(public static final) int MAX &#x3D; 100; 	括号内为缺省类型，即可以省略不写。</p>
<ul>
<li>接口中所有的方法默认都是抽象方法</li>
</ul>
<p>如void f(); &#x3D;&gt; 等价于 public abstract void f() {};</p>
<ul>
<li>可以用default关键字定义实例方法（JDK8后），必须是public方法，可省略不写。</li>
</ul>
<blockquote>
<p>default方法与普通类的实例方法一致，该接口的实现类可以选择是否重写，重写需去掉default关键字。</p>
</blockquote>
<ul>
<li>允许使用static关键字定义静态方法（JDK8后）</li>
<li>允许使用private关键字定义私有方法，接口的实现类无法访问private方法，目的是配合default方法使用实现一些算法的封装。（JDK9）</li>
</ul>
<p><strong>注意</strong>：</p>
<ul>
<li>接口没有构造函数</li>
<li>所有字段除了private， 其他的访问权限都是public</li>
</ul>
<p><strong>实现接口</strong></p>
<p>通过implements关键字可以实现一个或多个接口，接口之间用逗号隔开。</p>
<ul>
<li>非抽象类实现接口，必须重写所有抽象方法。</li>
<li>接口的实现了不拥有接口的<strong>静态</strong>和私有方法。</li>
<li>实现接口方法的访问权限必须是public， <strong>允许重载接口方法，并修改访问权限</strong></li>
</ul>
<blockquote>
<p>如接口有void cry(); 子类可以定义protected void cry(int m)方法。</p>
</blockquote>
<p><strong>接口回调</strong></p>
<p>将接口的实现类对象的引用赋值给接口变量，再通过接口变量调用实现类实现的方法，称为接口回调。</p>
<p>实际过程是：在接口变量调用方法时，根据地址通知对应的对象去调用对应的方法。</p>
<p><strong>接口与抽象类的比较</strong></p>
<ul>
<li>接口和abstract类的比较如下：<ul>
<li>abstract类和接口都可以有abstract方法。</li>
<li>接口中只可以有常量，不能有变量；而abstract类中即可以有常量也可以有变量。</li>
<li>abstract类中也可以有非abstract方法，接口不可以(JDK 7及以前的版本）。</li>
</ul>
</li>
</ul>
<h5 id="10-Lambada表达式（JDK8后）"><a href="#10-Lambada表达式（JDK8后）" class="headerlink" title="10. Lambada表达式（JDK8后）"></a>10. Lambada表达式（JDK8后）</h5><p>Lambada表达式，又称为匿名表达式；常用在单接口（只具有一个abstract方法的接口）的接口回调中。</p>
<p>形式：（参数列表） -&gt; {方法体}</p>
<p>Lambada表达式的值就是该方法的入口地址，可以将其赋给接口变量来实现单接口，用于接口回调。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        A obj;</span><br><span class="line">        obj = () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">        &#125;;			<span class="comment">// 分号不要忘记了</span></span><br><span class="line">        obj.f();	<span class="comment">// 输出 ok</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="11-内部类"><a href="#11-内部类" class="headerlink" title="11. 内部类"></a>11. 内部类</h5><p>在一个类中，再定义一个类，那么该类就叫做内部类。</p>
<blockquote>
<p>为了代码的易维护，和相关性，可以将需要用到的类写在另一个类中作为内部类。</p>
<p>对于拥有内部类的类，在编译后将生成多个class文件。</p>
</blockquote>
<p><strong>使用</strong>：</p>
<ul>
<li>外嵌类可以声明内部类对象</li>
<li>内部类不能定义静态成员。&#x3D;&#x3D;为什么内部类可以用static声明&#x3D;&#x3D;。</li>
</ul>
<h5 id="12-匿名类"><a href="#12-匿名类" class="headerlink" title="12. 匿名类"></a>12. 匿名类</h5><blockquote>
<p>有时候为了方便可以通过类体直接创建一个子类</p>
</blockquote>
<ul>
<li>可以是继承父类的子类</li>
<li>也可以是实现接口的子类</li>
<li>使用Lambada表达式做到的接口回调也是匿名类。</li>
</ul>
<p>形式：</p>
<p>new 父类构造方法 &#x2F; 接口名() {类体}</p>
<p>&#x3D;&#x3D;匿名类属于内部类&#x3D;&#x3D;</p>
<h5 id="13-异常类"><a href="#13-异常类" class="headerlink" title="13. 异常类"></a>13. 异常类</h5><p>用于提供程序运行出现错误的信息，及错误的捕捉</p>
<p>异常对象可以调用如下方法得到&#x2F;输出异常相关的信息</p>
<ul>
<li>public String getMessage();</li>
<li>public void printStackTrace();</li>
<li>public String toString();</li>
</ul>
<p><strong>捕捉异常</strong></p>
<p>Java使用try~catch~finally（可选）来捕捉处理异常，允许存在多条catch语句</p>
<p>&#x3D;&#x3D;多条catch语句可以分别处理异常，不是匹配一个就结束&#x3D;&#x3D;</p>
<p>注意：子类异常必须放在父类异常前面，因为父类异常包含子类。</p>
<p><strong>抛出异常</strong></p>
<p>在方法体内使用throw抛出异常对象: throw new Exception();</p>
<p>使用throws声明异常，声明该方法可能会出现的异常</p>
<h2 id="核心类"><a href="#核心类" class="headerlink" title="核心类"></a>核心类</h2><h5 id="1-String类"><a href="#1-String类" class="headerlink" title="1. String类"></a>1. String类</h5><p>String类不可继承。</p>
<p>String常量：用双引号括起来的字符序列。Java把String常量放在常量池内。</p>
<p>&#x3D;&#x3D;重点&#x3D;&#x3D;</p>
<ul>
<li>将一个String常量赋给变量时，如果内容相同的String常量在常量池里已经存在，则不会创建新的字符串常量，而是将已存在的字符串常量引用赋给该变量。</li>
</ul>
<blockquote>
<p>即：String a &#x3D; “hello”; String b &#x3D; “hello”;</p>
<p>a &#x3D;&#x3D; b &#x2F;&#x2F;输出true</p>
</blockquote>
<ul>
<li><p>而使用new关键字创建字符串对象，是在堆内申请一份新内存，因此内容相同但不是同一个引用。</p>
</li>
<li><p>String类对象在生成后，无法改变其中的值。</p>
</li>
</ul>
<blockquote>
<p>String a &#x3D; “hello”;</p>
<p>a[1] &#x3D; ‘a’;	&#x2F;&#x2F; 错误，并且只能通过charAt(index)方法访问。</p>
</blockquote>
<ul>
<li>通过+号可以使字符串进行并置运算。</li>
</ul>
<p>常量并置运算后依旧是常量，而一旦变量参与并置运算，就会重新在堆中创建新的String对象。</p>
<p><strong>与第一点共同思考</strong></p>
<blockquote>
<p>String str1 &#x3D; “helloJava”;</p>
<p>String str2 &#x3D; “hello” + “Java”;</p>
<p>str1 &#x3D;&#x3D; str2 	&#x2F;&#x2F; 得到true，运算后依旧是常量</p>
<p>String a &#x3D; “hello”，b &#x3D; “Java”；</p>
<p>String c &#x3D; a + b;</p>
<p>c &#x3D;&#x3D; str1; 		&#x2F;&#x2F; 得到false，因为a，b为String类变量，所以在并置运算后得到新的字符串对象。</p>
</blockquote>
<p><strong>与字符数组</strong></p>
<p>可以使用字符数组创建String类对象，也可限制范围；</p>
<ul>
<li>String(char a[],int startIndex,int count)；</li>
</ul>
<p>也可以String转字符数组</p>
<ul>
<li>public void getChars(int start,int end,char c[],int offset ) </li>
<li>public char[] toCharArray()</li>
</ul>
<p><strong>与字节数组</strong></p>
<p>String转字节数组</p>
<ul>
<li>public byte[] getBytes()。使用平台默认的字符编码。 </li>
<li>public byte[] getBytes(String charsetName)。指定字符编码</li>
</ul>
<p>&#x3D;&#x3D;GB2312编码中，一个汉字占两个字节。&#x3D;&#x3D;</p>
<h5 id="2-正则表达式"><a href="#2-正则表达式" class="headerlink" title="2. 正则表达式"></a>2. 正则表达式</h5><h5 id="3-Class类与反射"><a href="#3-Class类与反射" class="headerlink" title="3. Class类与反射"></a>3. Class类与反射</h5><blockquote>
<p>​	任何类默认有一个public的静态的(static)Class对象，该对象的名字是class（用关键字做了名字，属于Java系统特权），该对象封装当前类的有关信息（即类型的信息），如该类有哪些构造方法，哪些成员变量，哪些方法等。也可以让类的对象调用getClass()方法（从Java.lang.Object类继承的方法）返回这个Class对象：class。</p>
</blockquote>
<p>Class对象(class)调用方法可以获取当前类的有关信息，比如，类的名字、类中的方法名称、成员变量的名称等等，这一机制也称为Java反射。</p>
<p><strong>用Class类和反射机制创建新对象</strong>（有点问题）</p>
<ol>
<li>使用用Class类的类方法forName(String className)返回对应类的Class对象。</li>
<li>再让这个Class对象调用getDeclaredConstructor()方法得到 对应类 的 无参数的<strong>构造方法</strong>对象。</li>
<li>然后构造方法对象再调用newInstance()返回该类的对象</li>
</ol>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>通过代码块捕获 异常class类，来知道发生了什么错误，并进行下一步处理。</p>
<h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>类的继承关系如下：</p>
<p><img src="/assets/image-20240403211146797.png" alt="image-20240403211146797"></p>
<p><code>Error</code>表示严重的错误，程序对此一般无能为力</p>
<ul>
<li><code>OutOfMemoryError</code>：内存耗尽</li>
<li><code>NoClassDefFoundError</code>：无法加载某个Class</li>
<li><code>StackOverflowError</code>：栈溢出</li>
</ul>
<p>而<code>Exception</code>则是运行时的错误，它可以被捕获并处理。</p>
<p>某些异常是应用程序逻辑处理的一部分，应该捕获并处理。例如：</p>
<ul>
<li><code>NumberFormatException</code>：数值类型的格式错误</li>
<li><code>FileNotFoundException</code>：未找到文件</li>
<li><code>SocketException</code>：读取网络失败</li>
</ul>
<p><strong>Java规定（编辑器也会提示）：</strong></p>
<ol>
<li><p>必须捕获的异常（Checked Exception），包括<code>Exception</code>及其子类，但不包括<code>RuntimeException</code>及其子类。</p>
<p>Checked Exception：需要检查的异常</p>
<p>不包括在内的异常，可以由开发者自由选择是否捕获。</p>
<p>如 <code>NullPointerException</code> ，你可以自己选择是否捕获并处理该异常。</p>
<p>而 <code>IOException</code>，在 Java 环境中是必须要声明捕获的。 </p>
</li>
<li><p>不需要捕获的异常，包括<code>Error</code>及其子类，<code>RuntimeException</code>及其子类。</p>
</li>
</ol>
<p><strong>异常处理建议：</strong>异常不应该在产生的代码层级 <strong>空捕获不处理</strong>，即使真的什么也做不了，也应该把异常记录下来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">byte</span>[] toGBK(String s) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">        <span class="comment">// 先记下来再说:</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有异常都可以调用<code>printStackTrace()</code>方法打印异常栈（先进后出）。</p>
<p>因为是栈，所以异常栈最下面才是触发异常的源头。</p>
<h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><p><strong>catch 语句</strong></p>
<p>可以使用多个 <code>catch</code> 语句。</p>
<p>从上到下匹配对应异常类，但是只有一个能被执行。</p>
<p>因此顺序应保持：子类必须写在前面。</p>
<p>因为如果父类（范围大的异常）写在子类前面，就捕获不到子类了，等于没写。</p>
<p><strong>finally 语句</strong></p>
<p>无论异常是否发生，被捕获到，finally中的语句都会被执行。</p>
<p>特点：</p>
<ol>
<li>非必须</li>
<li>总是在 try ~ catch 之后，最后被执行</li>
</ol>
<p>finally 用于保证一些代码必须被执行，防止因为异常跳出了代码原本的运行逻辑。</p>
<p><strong>合并处理异常</strong></p>
<p>每个异常类应该是在不同 bit 位上，因此可以用 <code>|</code> 或运算符联合多个异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process1();</span><br><span class="line">        process2();</span><br><span class="line">        process3();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException | NumberFormatException e) &#123; <span class="comment">// IOException或NumberFormatException</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Bad input&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Unknown error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>完整示例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process1();</span><br><span class="line">        process2();</span><br><span class="line">        process3();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bad encoding&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;IO error&quot;</span>);</span><br><span class="line">    <span class="comment">// 常用于保证同步读写操作流的关闭</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;END&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h3><p><strong>异常传播</strong></p>
<p>当某个方法抛出异常后，如果当前方法没有捕获异常，异常就会被抛到上层调用方法，直到被捕获为止。</p>
<p><strong>抛出异常</strong></p>
<ol>
<li>创建某个 <code>Exception</code> 的实例</li>
<li>用 <code>throw</code> 语句抛出</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">process2</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">NullPointerException</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大部分情况下会合并写成一行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">process2</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="异常“转换”"><a href="#异常“转换”" class="headerlink" title="异常“转换”"></a><strong>异常“转换”</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">process1</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process2();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">process2</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>process1在捕获到process2的异常后，抛出了另一个异常 <code>IllegalArgumentException</code>。</p>
<p>那么原异常信息就会丢失，“转换”成了另一个异常暴露给外部</p>
<p>如果想要在抛出新的异常下，同时保留原始的异常信息，就需要把原始异常的实例作为新的异常构建参数传入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">process1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process2();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">        <span class="comment">// 传入原异常实例</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">process2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样在输出的异常栈信息中，就会包括原始的异常信息。</p>
<p><strong>捕获到异常并再次抛出时，一定要留住原始异常，否则很难定位第一案发现场！</strong></p>
<h3 id="异常屏蔽"><a href="#异常屏蔽" class="headerlink" title="异常屏蔽"></a>异常屏蔽</h3><p><strong>finally 与 catch 的执行顺序</strong></p>
<p>finally 语句的内容是一定会执行的，相比于 catch 语句的执行顺序呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Integer.parseInt(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;catched&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;finally&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">catched</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.RuntimeException: java.lang.NumberFormatException: For input string: <span class="string">&quot;abc&quot;</span></span><br><span class="line">    at Main.main(Main.java:<span class="number">8</span>)</span><br><span class="line">Caused by: java.lang.NumberFormatException: For input string: <span class="string">&quot;abc&quot;</span></span><br><span class="line">    at ...</span><br></pre></td></tr></table></figure>

<p>第一行打印了<code>catched</code>，第二行打印了<code>finally</code>。</p>
<p>说明先进入 catch 语句，再执行 finally 语句，并且 catch 中抛出的异常不会影响到 finally 执行</p>
<p><strong>异常屏蔽</strong></p>
<p>如果在执行 <code>finally</code> 语句时抛出异常，那么，<code>catch</code> 语句的异常还能否继续抛出？</p>
<p>答案：catch 中抛出的异常最终会被 finally 中抛出的异常“覆盖”。</p>
<p>本质猜测：</p>
<p>在 JVM 中有一个全局异常处理Handler，在执行目标类中的代码时，虽然 catch 先抛出了异常，但是要等 finally 执行完，handler 中的 catch 才对异常进行捕获，这时候 finally 中抛出的异常也会进入异常栈，覆盖原始异常，类似上述的异常“转换”，从而丢失原来的异常。</p>
<blockquote>
<p>catch 中只能抛出一个异常，没有被抛出的异常称为“被屏蔽”的异常（Suppressed Exception）。</p>
</blockquote>
<p><strong>如何获取所有的异常信息</strong></p>
<p>方法：先保存原始异常实例，然后调用 <code>Throwable.addSuppressed()</code>，把原始异常添加进来，最后在 <code>finally </code> 抛出。</p>
<p>为什么要在 finally 中抛出？</p>
<p>因为 catch 抛出一条异常就结束了，只能存好这一条异常，留在 finally 中添加了</p>
<h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>在项目开发中，为了方便处理不同业务的异常，会自定义异常，以便能精准的捕获。</p>
<p>自定义异常通常继承 <code>RuntimeException</code>。</p>
<p>这一类异常是 JVM 非强制捕获的异常，具有更好的扩展性，并且能自由的空值。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaseException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BaseException</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BaseException</span><span class="params">(String message, Throwable cause)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message, cause);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BaseException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BaseException</span><span class="params">(Throwable cause)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基本都是原样照抄<code>RuntimeException</code>。这样，抛出异常的时候，就可以选择合适的构造方法。通过IDE可以根据父类快速生成子类的构造方法。</p>
<p>真正的目的是区分不同的异常类。</p>
<h3 id="NPE异常"><a href="#NPE异常" class="headerlink" title="NPE异常"></a>NPE异常</h3><p>NPE 即 <code>NullPointerException</code> 空指针异常。</p>
<p>避免NPE的好习惯</p>
<ol>
<li><p>成员变量在定义时就初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>返回空字符串<code>&quot;&quot;</code>、空数组而不是<code>null</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] readLinesFromFile(String file) &#123;</span><br><span class="line">    <span class="keyword">if</span> (getFileSize(file) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 返回空数组而不是null:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Java 8</strong> 后，提供了 <code>Optional&lt;T&gt;</code> 工具类用于判断</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Optional&lt;String&gt; <span class="title function_">readFromFile</span><span class="params">(String file)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!fileExist(file)) &#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.empty();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过调用 Optional.isPresent() 可以判断结果</p>
</li>
</ol>
<p><strong>定位 NPE</strong></p>
<p>在执行类似如下代码时，Java 默认是不会指出哪个对象是null，只会暴露出目标文件所在行数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a.b.c.x()</span><br></pre></td></tr></table></figure>

<p>Java 14 以后，只要开启如下 JVM 参数就可以检测出具体的 null 对象。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -XX:+ShowCodeDetailsInExceptionMessages Main.java</span><br></pre></td></tr></table></figure>

<p>本质猜测：开启后，每一步对象的嵌套调用都会被记录，当出现错误的时候就显示当前层级，可能会降低性能。</p>
<h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><p>使用 <code>assert</code> 关键字来实现断言。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assert</span> x &gt;= <span class="number">0</span> : <span class="string">&quot;x must &gt;= 0&quot;</span>;</span><br></pre></td></tr></table></figure>

<p><code>:</code> 冒号后添加可选的断言消息。</p>
<p>如果断言判断失败，会抛出 <code>AssertionError</code> 异常结束程序，并带上断言消息。</p>
<p>断言常用于测试，只要错误就代表测试失败。</p>
<p>JVM 默认关闭断言指令，即遇到<code>assert</code>语句就自动忽略了，不执行。</p>
<p>需要开启 <code>-enableassertions</code> （可简写为<code>-ea</code>）参数启用断言。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -ea Main.java</span><br><span class="line">Exception <span class="keyword">in</span> thread <span class="string">&quot;main&quot;</span> java.lang.AssertionError</span><br><span class="line">	at Main.main(Main.java:5)</span><br></pre></td></tr></table></figure>

<p>还可以对特定的类启用断言<code> -ea:com.itranswarp.sample.Main</code></p>
<p>或者特定的包 <code>-ea:com.itranswarp.sample...</code>，用结尾的 … 表示这是一个包。</p>
<h3 id="日志输出"><a href="#日志输出" class="headerlink" title="日志输出"></a>日志输出</h3><p>对比 <code>System.out.println()</code> 有如下好处：</p>
<ol>
<li>可以设置输出样式，避免自己每次都写<code>&quot;ERROR: &quot; + var</code>；</li>
<li>可以设置输出级别，禁止某些级别输出。例如，只输出错误日志；</li>
<li>可以被重定向到文件，这样可以在程序运行结束后查看日志；</li>
<li>可以按包名控制日志级别，只输出某些包打的日志；</li>
<li>可以…… 等等</li>
</ol>
<p>Java 内置了 <code>java.util.logging</code>，可以直接使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.logging.Level;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.Logger;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> Logger.getGlobal();</span><br><span class="line">        logger.info(<span class="string">&quot;start process...&quot;</span>);</span><br><span class="line">        logger.warning(<span class="string">&quot;memory is running out...&quot;</span>);</span><br><span class="line">        logger.fine(<span class="string">&quot;ignored.&quot;</span>);</span><br><span class="line">        logger.severe(<span class="string">&quot;process will be terminated...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Mar 02, 2019 6:32:13 PM Hello main</span><br><span class="line">INFO: start process...</span><br><span class="line">Mar 02, 2019 6:32:13 PM Hello main</span><br><span class="line">WARNING: memory is running out...</span><br><span class="line">Mar 02, 2019 6:32:13 PM Hello main</span><br><span class="line">SEVERE: process will be terminated...</span><br></pre></td></tr></table></figure>

<p>可以看出 fine 的日志没有打印出来。</p>
<p>默认日志级别是 INFO，该级别以下的日志不会被打印出来。</p>
<p>JDK 的 Logging 定义了7个日志级别，从严重到普通：</p>
<ul>
<li>SEVERE</li>
<li>WARNING</li>
<li>INFO</li>
<li>CONFIG</li>
<li>FINE</li>
<li>FINER</li>
<li>FINEST</li>
</ul>
<p><strong>局限</strong></p>
<p>Logging 系统在 JVM 启动时读取配置文件并完成初始化，一旦开始运行<code>main()</code>方法，就无法修改配置；</p>
<p>配置不方便，需要在JVM启动时传递参数<code>-Djava.util.logging.config.file=&lt;config-file-name&gt;</code>。</p>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><p>除了 int 等基本类型外，Java 的其他类型全部都是 class，包括 interface。</p>
<blockquote>
<p>JVM也为 int 等基本类型创建了 Class 实例。</p>
</blockquote>
<p>而<code>class</code>是由JVM在执行过程中动态加载的。JVM在第一次读取到一种<code>class</code>类型时，将其加载进内存。</p>
<blockquote>
<p>没有加载到的class是无法通过Class.forName()找到的。</p>
</blockquote>
<p>每加载一种<code>class</code>，JVM就为其创建一个<code>Class</code>类型的实例，并关联起来。注意：这里的<code>Class</code>类型是一个名叫<code>Class</code>的<code>class</code>。它长这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Class</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Class</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以<code>String</code>类为例，当JVM加载<code>String</code>类时，它首先读取<code>String.class</code>文件到内存，然后，为<code>String</code>类创建一个<code>Class</code>实例并关联起来：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Class</span>(String);</span><br></pre></td></tr></table></figure>

<p><strong>每个类的Class实例是唯一的。</strong></p>
<p><strong>每个类的<code>Class</code>实例包含了该<code>class</code>的所有完整信息：</strong></p>
<p><img src="/../assets/image-20240417190242743.png" alt="image-20240417190242743"></p>
<p>所以可以通过某个类的 Class 实例获取这个类的所有信息，这种操作被称为反射。</p>
<p><strong>动态加载特性</strong></p>
<p>动态加载<code>class</code>的特性对于Java程序非常重要。</p>
<p>利用JVM动态加载<code>class</code>的特性，我们才能在运行期根据条件加载不同的实现类。</p>
<p>例如，Commons Logging总是优先使用Log4j，只有当Log4j不存在时，才使用JDK的logging。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Commons Logging优先使用Log4j:</span></span><br><span class="line"><span class="type">LogFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (isClassPresent(<span class="string">&quot;org.apache.logging.log4j.Logger&quot;</span>)) &#123;</span><br><span class="line">    factory = createLog4j();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    factory = createJdkLog();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isClassPresent</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class.forName(name);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a><strong>基本使用</strong></h3><h4 id="如何获取一个类的Class实例"><a href="#如何获取一个类的Class实例" class="headerlink" title="如何获取一个类的Class实例"></a><strong>如何获取一个类的Class实例</strong></h4><ol>
<li><p>通过类的静态变量class获取</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clz</span> <span class="operator">=</span> String.class;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过类的某个实例的 getClass() 方法获取</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">Class</span> <span class="variable">clz</span> <span class="operator">=</span> s.getClass();</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过 Class 的静态方法获取</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数为类的完整包路径</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="对比-instanceof"><a href="#对比-instanceof" class="headerlink" title="对比 instanceof"></a><strong>对比 instanceof</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> n <span class="keyword">instanceof</span> Integer; <span class="comment">// true，因为n是Integer类型</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b2</span> <span class="operator">=</span> n <span class="keyword">instanceof</span> Number; <span class="comment">// true，因为n是Number类型的子类</span></span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b3</span> <span class="operator">=</span> n.getClass() == Integer.class; <span class="comment">// true，因为n.getClass()返回Integer.class</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b4</span> <span class="operator">=</span> n.getClass() == Number.class; <span class="comment">// false，因为Integer.class!=Number.class</span></span><br></pre></td></tr></table></figure>

<p>instanceof 不但可以匹配相同类型，还可以匹配该类型的父类</p>
<p>而 Class 实例只能匹配其本身的类型，因为每个 class 都有唯一的 Class 实例。</p>
<h4 id="获取类的基本信息"><a href="#获取类的基本信息" class="headerlink" title="获取类的基本信息"></a><strong>获取类的基本信息</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        printClassInfo(<span class="string">&quot;&quot;</span>.getClass());</span><br><span class="line">        printClassInfo(Runnable.class);</span><br><span class="line">        printClassInfo(java.time.Month.class);</span><br><span class="line">        printClassInfo(String[].class);</span><br><span class="line">        printClassInfo(<span class="type">int</span>.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printClassInfo</span><span class="params">(Class cls)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Class name: &quot;</span> + cls.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;Simple name: &quot;</span> + cls.getSimpleName());</span><br><span class="line">        <span class="keyword">if</span> (cls.getPackage() != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Package name: &quot;</span> + cls.getPackage().getName());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;is interface: &quot;</span> + cls.isInterface());</span><br><span class="line">        System.out.println(<span class="string">&quot;is enum: &quot;</span> + cls.isEnum());</span><br><span class="line">        System.out.println(<span class="string">&quot;is array: &quot;</span> + cls.isArray());</span><br><span class="line">        System.out.println(<span class="string">&quot;is primitive: &quot;</span> + cls.isPrimitive());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数组（例如<code>String[]</code>）也是一种类，而且不同于<code>String.class</code>，它的类名是<code>[Ljava.lang.String;</code>。</p>
<h4 id="创建新实例"><a href="#创建新实例" class="headerlink" title="创建新实例"></a><strong>创建新实例</strong></h4><p>如果获取到了一个<code>Class</code>实例，我们就可以通过该<code>Class</code>实例来创建对应类型的实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取String的Class实例:</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> String.class;</span><br><span class="line"><span class="comment">// 创建一个String实例:</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> (String) cls.newInstance();</span><br></pre></td></tr></table></figure>



<h3 id="Field"><a href="#Field" class="headerlink" title="Field"></a>Field</h3><p>通过类的 Class 实例可以获取到该类的<strong>所有实例</strong>的字段信息。</p>
<h4 id="获取方法介绍："><a href="#获取方法介绍：" class="headerlink" title="获取方法介绍："></a><strong>获取方法介绍：</strong></h4><ul>
<li>Field getField(name)：根据字段名获取某个 public 的field（包括父类）</li>
<li>Field[] getFields()：获取所有 public 的field（包括父类）</li>
<li>Field getDeclaredField(name)：根据字段名获取当前类的某个field（不包括父类）</li>
<li>Field[] getDeclaredFields()：获取当前类的所有field（不包括父类）</li>
</ul>
<p>getDeclaredField 相比于 getField 更针对<strong>自身声明的所有字段（包括private）</strong></p>
<h4 id="Field对象属性介绍"><a href="#Field对象属性介绍" class="headerlink" title="Field对象属性介绍"></a><strong>Field对象属性介绍</strong></h4><ul>
<li><code>getName()</code>：返回字段名称，例如，<code>&quot;name&quot;</code>；</li>
<li><code>getType()</code>：返回字段类型，也是一个<code>Class</code>实例，例如，<code>String.class</code>；</li>
<li><code>getModifiers()</code>：返回字段的修饰符，它是一个<code>int</code>，不同的bit表示不同的含义。</li>
</ul>
<p>以<code>String</code>类的<code>value</code>字段为例，它的定义是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span>[] value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们用反射获取该字段的信息，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> String.class.getDeclaredField(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">f.getName(); <span class="comment">// &quot;value&quot;</span></span><br><span class="line">f.getType(); <span class="comment">// class [B 表示byte[]类型</span></span><br><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> f.getModifiers();</span><br><span class="line">Modifier.isFinal(m); <span class="comment">// true</span></span><br><span class="line">Modifier.isPublic(m); <span class="comment">// false</span></span><br><span class="line">Modifier.isProtected(m); <span class="comment">// false</span></span><br><span class="line">Modifier.isPrivate(m); <span class="comment">// true</span></span><br><span class="line">Modifier.isStatic(m); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h4 id="获取字段值"><a href="#获取字段值" class="headerlink" title="获取字段值"></a><strong>获取字段值</strong></h4><p><code>f.get(Object)</code> 获取该字段在指定实例的值。</p>
<p>因为每个类只有一个 Class，其中的每个字段只有一个 Field，而类的实例存在多个。</p>
<p>因此要想获取该字段的值，必须指定是哪个实例，所以才要传入实例。</p>
<p>但是不能直接访问非 public 字段，需要声明访问许可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">f.setAccessible(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p>不声明直接访问 private 字段会抛出 <code>IllegalAccessException</code> 非法访问异常。</p>
<p><code>setAccessible(true)</code>可能会失败。</p>
<p>如果JVM运行期存在<code>SecurityManager</code>，那么它会根据规则进行检查，有可能阻止<code>setAccessible(true)</code>。</p>
<p>例如，某个<code>SecurityManager</code>可能不允许对<code>java</code>和<code>javax</code>开头的<code>package</code>的类调用<code>setAccessible(true)</code>，这样可以保证JVM核心库的安全。</p>
<h4 id="设置字段值"><a href="#设置字段值" class="headerlink" title="设置字段值"></a><strong>设置字段值</strong></h4><p><code>f.set(Object1, Object2)</code> 设置指定实例 Object1 的 Field 字段值为 Object2。</p>
<p>同理，修改非 public 字段，需要声明访问许可。</p>
<h3 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h3><p>通过 Class 实例也可以获取该类的所有 method 方法信息。</p>
<h4 id="获取方法（类似Field）"><a href="#获取方法（类似Field）" class="headerlink" title="获取方法（类似Field）"></a><strong>获取方法（类似Field）</strong></h4><ul>
<li><code>Method getMethod(name, Class...)</code>：获取某个<code>public</code>的<code>Method</code>（包括父类）</li>
<li><code>Method[] getMethods()</code>：获取所有<code>public</code>的<code>Method</code>（包括父类）</li>
<li><code>Method getDeclaredMethod(name, Class...)</code>：获取当前类的某个<code>Method</code>（不包括父类）</li>
<li><code>Method[] getDeclaredMethods()</code>：获取当前类的所有<code>Method</code>（不包括父类）</li>
</ul>
<p>区别：因为方法允许重载，所以在获取 Method 实例时除了需要指定方法名外，还需要显式的按顺序指定参数类型。</p>
<h4 id="Method-实例属性介绍"><a href="#Method-实例属性介绍" class="headerlink" title="Method 实例属性介绍"></a><strong>Method 实例属性介绍</strong></h4><ul>
<li><code>getName()</code>：返回方法名称，例如：<code>&quot;getScore&quot;</code>；</li>
<li><code>getReturnType()</code>：返回方法返回值类型，也是一个Class实例，例如：<code>String.class</code>；</li>
<li><code>getParameterTypes()</code>：返回方法的参数类型，是一个Class数组，例如：<code>&#123;String.class, int.class&#125;</code>；</li>
<li><code>getModifiers()</code>：返回方法的修饰符，它是一个<code>int</code>，不同的bit表示不同的含义。</li>
</ul>
<h4 id="调用实例方法"><a href="#调用实例方法" class="headerlink" title="调用实例方法"></a><strong>调用实例方法</strong></h4><p><code>m.invoke(Object, ...params)</code> 调用指定实例的实例方法，类似 Field 的 get 用法。</p>
<p>当我们获取到一个<code>Method</code>对象时，就可以对它进行调用。我们以下面的代码为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello world&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">r</span> <span class="operator">=</span> s.substring(<span class="number">6</span>); <span class="comment">// &quot;world&quot;</span></span><br></pre></td></tr></table></figure>

<p>改写为反射来调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// String对象:</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello world&quot;</span>;</span><br><span class="line">        <span class="comment">// 获取String substring(int)方法，参数为int:</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> String.class.getMethod(<span class="string">&quot;substring&quot;</span>, <span class="type">int</span>.class);</span><br><span class="line">        <span class="comment">// 在s对象上调用该方法并获取结果:</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">r</span> <span class="operator">=</span> (String) m.invoke(s, <span class="number">6</span>);</span><br><span class="line">        <span class="comment">// 打印调用结果:</span></span><br><span class="line">        System.out.println(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="调用静态方法"><a href="#调用静态方法" class="headerlink" title="调用静态方法"></a><strong>调用静态方法</strong></h4><p><code>m.invoke(null, ...params)</code></p>
<p>由于静态方法是直接绑定到类实例上的，所以第一个参数永远是 null。</p>
<h4 id="调用非-public-方法"><a href="#调用非-public-方法" class="headerlink" title="调用非 public 方法"></a><strong>调用非 public 方法</strong></h4><p>也和 Field 类似，需要声明访问许可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">m.setAccessible(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a><strong>多态</strong></h4><p>一个<code>Person</code>类定义了<code>hello()</code>方法，并且它的子类<code>Student</code>也覆写了<code>hello()</code>方法</p>
<p>如果从Person类的 Class 获取Method实例，作用于 Student 实例时，调用的是谁的方法。</p>
<p>答案：会调用 Student 的，可能是因为每个 Method 是唯一的，作用于哪个实例，就是哪个实例的方法。</p>
<p>因此，使用反射调用方法时，仍然遵循多态原则：即总是调用实际类型的覆写方法（如果存在）。上述的反射代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> Person.class.getMethod(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">m.invoke(<span class="keyword">new</span> <span class="title class_">Student</span>());</span><br></pre></td></tr></table></figure>

<p>实际上相当于：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">p.hello();</span><br></pre></td></tr></table></figure>



<h3 id="Constructor"><a href="#Constructor" class="headerlink" title="Constructor"></a>Constructor</h3><p>通常使用<code>new</code>操作符创建新的实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br></pre></td></tr></table></figure>

<p>如果通过反射来创建新的实例，可以调用Class提供的newInstance()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> Person.class.newInstance();</span><br></pre></td></tr></table></figure>

<p>直接调用 <code>newInstance()</code> 方法只能调用该类的<strong>public无参数</strong>构造方法。</p>
<p>如果构造方法带有参数，或者不是public，就无法直接通过Class.newInstance()来调用。</p>
<p>因此，Java提供了这个类似Field、Method的Constructor类，包含了一个 Class 的所有构造方法信息。</p>
<h4 id="属性相关"><a href="#属性相关" class="headerlink" title="属性相关"></a>属性相关</h4><ul>
<li><code>getName()</code>：返回方法名称，例如：<code>&quot;getScore&quot;</code>；</li>
<li><code>getParameterTypes()</code>：返回方法的参数类型，是一个Class数组，例如：<code>&#123;String.class, int.class&#125;</code>；</li>
</ul>
<h4 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a><strong>获取方法</strong></h4><ul>
<li><code>getConstructor(Class...)</code>：获取某个<code>public</code>的<code>Constructor</code>；</li>
<li><code>getConstructors()</code>：获取所有<code>public</code>的<code>Constructor</code>；</li>
<li><code>getDeclaredConstructor(Class...)</code>：获取某个<code>Constructor</code>；</li>
<li><code>getDeclaredConstructors()</code>：获取所有<code>Constructor</code>。</li>
</ul>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a><strong>使用</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取构造方法Integer(int):</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">cons1</span> <span class="operator">=</span> Integer.class.getConstructor(<span class="type">int</span>.class);</span><br><span class="line">        <span class="comment">// 调用构造方法:</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">n1</span> <span class="operator">=</span> (Integer) cons1.newInstance(<span class="number">123</span>);</span><br><span class="line">        System.out.println(n1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样，调用非<code>public</code>的<code>Constructor</code>时，必须首先通过<code>setAccessible(true)</code>设置允许访问。</p>
<h3 id="获取继承关系"><a href="#获取继承关系" class="headerlink" title="获取继承关系"></a>获取继承关系</h3><h4 id="获取父类的Class"><a href="#获取父类的Class" class="headerlink" title="获取父类的Class"></a><strong>获取父类的Class</strong></h4><p>有了<code>Class</code>实例，我们还可以获取它的父类的<code>Class</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">i</span> <span class="operator">=</span> Integer.class;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">n</span> <span class="operator">=</span> i.getSuperclass();</span><br><span class="line">        System.out.println(n);</span><br><span class="line">        <span class="type">Class</span> <span class="variable">o</span> <span class="operator">=</span> n.getSuperclass();</span><br><span class="line">        System.out.println(o);</span><br><span class="line">        System.out.println(o.getSuperclass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行上述代码可以看到，<code>Integer</code>的父类类型是<code>Number</code>，<code>Number</code>的父类是<code>Object</code>，<code>Object</code>的父类是<code>null</code>，因为所有的类都是继承于 <code>Objcet</code>。</p>
<p>除<code>Object</code>外，其他任何非<code>interface</code>的<code>Class</code>都必定存在一个父类类型。</p>
<h4 id="获取interface"><a href="#获取interface" class="headerlink" title="获取interface"></a><strong>获取interface</strong></h4><p>通过<code>clz.getInterfaces()</code> 方法可以查询到该类实现的接口类型。</p>
<p>例如，查询<code>Integer</code>实现的接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">s</span> <span class="operator">=</span> Integer.class;</span><br><span class="line">        Class[] is = s.getInterfaces();</span><br><span class="line">        <span class="keyword">for</span> (Class i : is) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行上述代码可知，<code>Integer</code>实现的接口有：</p>
<ul>
<li>java.lang.Comparable</li>
<li>java.lang.constant.Constable</li>
<li>java.lang.constant.ConstantDesc</li>
</ul>
<p>注意：</p>
<ol>
<li><code>getInterfaces()</code>只返回当前类直接实现的接口类型，<strong>并不包括其父类实现的接口类型</strong></li>
<li>如果一个类没有实现任何<code>interface</code>，那么<code>getInterfaces()</code>返回空数组。</li>
</ol>
<h4 id="继承关系判断"><a href="#继承关系判断" class="headerlink" title="继承关系判断"></a><strong>继承关系判断</strong></h4><p>要判断一个类是否可以赋值给另一个类（向上转型）可以调用<code>isAssignableFrom()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Number n = ?</span></span><br><span class="line">Number.class.isAssignableFrom(Integer.class); <span class="comment">// true，因为Integer可以赋值给Number</span></span><br><span class="line"><span class="comment">// Integer i = ?</span></span><br><span class="line">Integer.class.isAssignableFrom(Number.class); <span class="comment">// false，因为Number不能赋值给Integer</span></span><br></pre></td></tr></table></figure>



<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>Java 中，是不能直接实例化 interface 的。</p>
<p>所有<code>interface</code>类型的变量总是通过某个实例向上转型并赋值给接口类型变量的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">CharSequence</span> <span class="variable">cs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br></pre></td></tr></table></figure>

<p>但是 Java 标准库提供了一种动态代理（Dynamic Proxy）的机制：可以在运行期动态创建某个<code>interface</code>的实例。</p>
<p>就是不去实现，而是在代码运行中动态创建并使用。</p>
<p>通过JDK提供的一个<code>Proxy.newProxyInstance()</code>创建一个<code>Hello</code>接口对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                System.out.println(method);</span><br><span class="line">                <span class="comment">// 匹配对应方法，执行自定义内容</span></span><br><span class="line">                <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;morning&quot;</span>)) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Good morning, &quot;</span> + args[<span class="number">0</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Hello</span> <span class="variable">hello</span> <span class="operator">=</span> (Hello) Proxy.newProxyInstance(</span><br><span class="line">            Hello.class.getClassLoader(), <span class="comment">// 传入ClassLoader</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; Hello.class &#125;, <span class="comment">// 传入要实现的接口</span></span><br><span class="line">            handler); <span class="comment">// 传入处理调用方法的InvocationHandler</span></span><br><span class="line">        hello.morning(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">morning</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>动态创建 interface 实现类步骤</strong></p>
<ol>
<li>定义一个<code>InvocationHandler</code>实例，它负责实现接口的方法调用；</li>
<li>通过 Proxy.newProxyInstance() 创建 interface 实例，传入3个参数：<ol>
<li>使用的<code>ClassLoader</code>，通常就是接口类的<code>ClassLoader</code>；</li>
<li>需要实现的接口数组，至少需要传入一个接口进去（这里传入接口本身的 Class 实例）；</li>
<li>用来处理接口方法调用的<code>InvocationHandler</code>实例。</li>
</ol>
</li>
<li>将返回的<code>Object</code>强制转型为接口。</li>
</ol>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h3 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h3><p>注解是放在Java源码的类、方法、字段、参数前的一种特殊“注释”。</p>
<p><strong>区别于注释：</strong></p>
<p>注释会被编译器直接忽略，注解则可以被编译器打包进入class文件，可以把注解看做是一种用作标注的“元数据”。</p>
<p><strong>分类</strong></p>
<p>Java的注解可以分为三类：</p>
<p><strong>第一类</strong>是由<strong>编译器</strong>使用的注解，作用于编译阶段，例如：</p>
<ul>
<li><p><code>@Override</code>：让编译器检查该方法是否正确地实现了覆写；</p>
</li>
<li><p><code>@SuppressWarnings</code>：告诉编译器忽略此处代码产生的警告。</p>
</li>
</ul>
<p>这类注解不会被编译进入<code>.class</code>文件，它们在编译后就被编译器扔掉了。</p>
<p><strong>第二类</strong>是由<strong>底层工具</strong>处理<code>.class</code>文件使用的注解。</p>
<p>比如在加载class的时候对class做动态修改，实现一些特殊的功能（如Lombok加一些属性等）。</p>
<p>这类注解会被编译进入<code>.class</code>文件，但加载结束后并不会存在于内存中。</p>
<p><strong>第三类</strong>是在<strong>程序运行期</strong>能够读取的注解，它们在加载后一直存在于JVM中，程序在运行中可以随时捕捉和处理。</p>
<p>例如，一个配置了<code>@PostConstruct</code>的方法会在调用构造方法后自动被调用（这是Java代码读取该注解实现的功能，JVM并不会识别该注解）。</p>
<h3 id="定义注解"><a href="#定义注解" class="headerlink" title="定义注解"></a><strong>定义注解</strong></h3><h4 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a><strong>配置参数</strong></h4><p>定义一个注解时可以定义配置参数。配置参数必须是<strong>不可变类型</strong>，包括：</p>
<ul>
<li>所有基本类型；</li>
<li>String；</li>
<li>枚举类型；</li>
<li>基本类型、String、Class以及枚举的数组。</li>
</ul>
<p>还允许为配置参数指定默认值，缺少某个配置参数时将使用默认值。</p>
<p>大部分注解会有一个名为<code>value</code>的配置参数，对此参数赋值，可以只写常量省略value参数名称。</p>
<p>即配置注解时，如果配置的参数名称是<code>value</code>，且只有一个参数，那么可以省略参数名称。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="meta">@Check(min=0, max=100, value=55)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Check(value=99)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> p;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Check(99)</span> <span class="comment">// @Check(value=99)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Check</span>	   <span class="comment">// 全部配置参数使用默认值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="定义格式"><a href="#定义格式" class="headerlink" title="定义格式"></a><strong>定义格式</strong></h4><p>Java语言使用<code>@interface</code>语法来定义注解（<code>Annotation</code>），它的格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">type</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    String <span class="title function_">level</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;info&quot;</span>;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a><strong>元注解</strong></h4><p>有一些注解可以修饰其他注解，这些注解就称为元注解（meta annotation）。</p>
<p>Java标准库已经定义了一些元注解，我们只需要使用元注解，通常不需要自己去编写元注解。</p>
<h5 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h5><p>最常用的元注解是<code>@Target</code>。使用<code>@Target</code>可以定义<code>Annotation</code>能够被应用于源码的哪些位置：</p>
<ul>
<li>类或接口：<code>ElementType.TYPE</code>；</li>
<li>字段：<code>ElementType.FIELD</code>；</li>
<li>方法：<code>ElementType.METHOD</code>；</li>
<li>构造方法：<code>ElementType.CONSTRUCTOR</code>；</li>
<li>方法参数：<code>ElementType.PARAMETER</code>。</li>
</ul>
<p>例如，定义注解<code>@Report</code>可用在方法上，我们必须添加一个<code>@Target(ElementType.METHOD)</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">type</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    String <span class="title function_">level</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;info&quot;</span>;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义注解<code>@Report</code>可用在方法或字段上，可以把<code>@Target</code>注解参数变为数组<code>&#123; ElementType.METHOD, ElementType.FIELD &#125;</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;</span></span><br><span class="line"><span class="meta">    ElementType.METHOD,</span></span><br><span class="line"><span class="meta">    ElementType.FIELD</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上<code>@Target</code>定义的<code>value</code>是<code>ElementType[]</code>数组，<strong>只有一个元素时，可以省略数组的写法</strong>。</p>
<h5 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h5><p>另一个重要的元注解<code>@Retention</code>定义了<code>Annotation</code>的生命周期：</p>
<ul>
<li><p>仅编译期：<code>RetentionPolicy.SOURCE</code>；</p>
<p>提供给编译器使用，编译结束后会丢掉。</p>
</li>
<li><p>仅class文件：<code>RetentionPolicy.CLASS</code>；</p>
<p>用于修改底层class结构，不会被JVM加载。</p>
</li>
<li><p>运行期：<code>RetentionPolicy.RUNTIME</code>。</p>
<p>可以在程序运行中捕获和处理，最常用。</p>
</li>
</ul>
<p>如果<code>@Retention</code>不存在，则该<code>Annotation</code>默认为<code>CLASS</code>。</p>
<p>因为通常我们自定义的<code>Annotation</code>都是<code>RUNTIME</code>，所以要加上<code>@Retention(RetentionPolicy.RUNTIME)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">type</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    String <span class="title function_">level</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;info&quot;</span>;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Repeatable"><a href="#Repeatable" class="headerlink" title="@Repeatable"></a>@Repeatable</h5><p>使用<code>@Repeatable(Class)</code>这个元注解可以定义<code>Annotation</code>是否可重复标注在同一个地方。</p>
<p>并将重复的注解读到目标 Class 的参数中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将多个 Report 记录到 Reports 注解中。</span></span><br><span class="line"><span class="meta">@Repeatable(Reports.class)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">type</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    String <span class="title function_">level</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;info&quot;</span>;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Reports &#123;</span><br><span class="line">    Report[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过<code>@Repeatable</code>修饰后，在某个类型声明处，就可以添加多个<code>@Report</code>注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Report(type=1, level=&quot;debug&quot;)</span></span><br><span class="line"><span class="meta">@Report(type=2, level=&quot;warning&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h5><p>使用<code>@Inherited</code>定义子类是否可继承父类定义的<code>Annotation</code>。</p>
<p><code>@Inherited</code>仅针对<code>@Target(ElementType.TYPE)</code>类型的<code>annotation</code>有效，并且对<code>interface</code>的继承无效：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">type</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    String <span class="title function_">level</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;info&quot;</span>;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在使用的时候，如果一个类用到了<code>@Report</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Report(type=1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>则它的子类默认也定义了该注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="自定义-Annotation-步骤"><a href="#自定义-Annotation-步骤" class="headerlink" title="自定义 Annotation 步骤"></a>自定义 Annotation 步骤</h4><ol>
<li>用<code>@interface</code>定义注解：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>定义配置参数、默认值：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">type</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    String <span class="title function_">level</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;info&quot;</span>;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把最常用的参数定义为<code>value()</code>，推荐所有参数都尽量设置默认值。</p>
<ol start="3">
<li>用元注解配置注解：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">type</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    String <span class="title function_">level</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;info&quot;</span>;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，必须设置<code>@Target</code>和<code>@Retention</code>，<code>@Retention</code>一般设置为<code>RUNTIME</code>，因为我们自定义的注解通常要求在运行期读取。一般情况下，不必写<code>@Inherited</code>和<code>@Repeatable</code>。</p>
<h3 id="读取处理注解"><a href="#读取处理注解" class="headerlink" title="读取处理注解"></a>读取处理注解</h3><p><code>SOURCE</code>类型的注解主要由编译器使用，因此我们一般只使用，不编写。</p>
<p><code>CLASS</code>类型的注解主要由底层工具库使用，涉及到class的加载，一般我们很少用到。</p>
<p>只有<code>RUNTIME</code>类型的注解不但要使用，还经常需要编写。</p>
<p>因此，以下方式针对 RUNTIME 类型处理。</p>
<h4 id="读取注解："><a href="#读取注解：" class="headerlink" title="读取注解："></a><strong>读取注解</strong>：</h4><p>判断某个注解是否存在于<code>Class</code>、<code>Field</code>、<code>Method</code>或<code>Constructor</code>：</p>
<ul>
<li><code>Class.isAnnotationPresent(Class)</code></li>
<li><code>Field.isAnnotationPresent(Class)</code></li>
<li><code>Method.isAnnotationPresent(Class)</code></li>
<li><code>Constructor.isAnnotationPresent(Class)</code></li>
</ul>
<p>使用反射API读取Annotation：</p>
<ul>
<li><code>Class.getAnnotation(Class)</code></li>
<li><code>Field.getAnnotation(Class)</code></li>
<li><code>Method.getAnnotation(Class)</code></li>
<li><code>Constructor.getAnnotation(Class)</code></li>
</ul>
<p>使用反射API读取<code>Annotation</code>有两种方法。</p>
<ol>
<li>先判断<code>Annotation</code>是否存在，如果存在，就直接读取：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Person.class;</span><br><span class="line"><span class="keyword">if</span> (cls.isAnnotationPresent(Report.class)) &#123;</span><br><span class="line">    <span class="type">Report</span> <span class="variable">report</span> <span class="operator">=</span> cls.getAnnotation(Report.class);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>是直接读取<code>Annotation</code>，如果<code>Annotation</code>不存在，将返回<code>null</code>：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Person.class;</span><br><span class="line"><span class="type">Report</span> <span class="variable">report</span> <span class="operator">=</span> cls.getAnnotation(Report.class);</span><br><span class="line"><span class="keyword">if</span> (report != <span class="literal">null</span>) &#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读取方法、字段和构造方法的<code>Annotation</code>和Class类似。</p>
<p>但要读取方法参数的<code>Annotation</code>就比较麻烦一点，因为方法参数本身可以看成一个数组，而每个参数又可以定义多个注解。</p>
<p>所以，方法参数的所有注解用一个二维数组来表示。</p>
<p>例如，对于以下方法定义的注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">(<span class="meta">@NotNull</span> <span class="meta">@Range(max=5)</span> String name, <span class="meta">@NotNull</span> String prefix)</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要读取方法参数的注解，我们先用反射获取<code>Method</code>实例，然后读取方法参数的所有注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取Method实例:</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> ...</span><br><span class="line"><span class="comment">// 获取所有参数的Annotation:</span></span><br><span class="line">Annotation[][] annos = m.getParameterAnnotations();</span><br><span class="line"><span class="comment">// 第一个参数（索引为0）的所有Annotation:</span></span><br><span class="line">Annotation[] annosOfName = annos[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (Annotation anno : annosOfName) &#123;</span><br><span class="line">    <span class="keyword">if</span> (anno <span class="keyword">instanceof</span> Range r) &#123; <span class="comment">// @Range注解</span></span><br><span class="line">        <span class="comment">// 获取range注解的max参数值</span></span><br><span class="line">        r.max();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anno <span class="keyword">instanceof</span> NotNull n) &#123; <span class="comment">// @NotNull注解</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="处理注解"><a href="#处理注解" class="headerlink" title="处理注解"></a>处理注解</h4><p>注解本身只是一个标注，被标注的对象如何处理完全由程序自己决定。</p>
<p>例如，JUnit是一个测试框架，它会自动运行所有标记为<code>@Test</code>的方法。</p>
<p>以<code>@Range</code>注解标注一个<code>String</code>字段为例，要求标注了这个注解的字段长度满足注解配置参数要求：</p>
<ol>
<li>定义注解</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Range &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">min</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">max</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">255</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用注解</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="meta">@Range(min=1, max=20)</span></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Range(max=10)</span></span><br><span class="line">    <span class="keyword">public</span> String city;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>处理注解</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">check</span><span class="params">(Person person)</span> <span class="keyword">throws</span> IllegalArgumentException, ReflectiveOperationException &#123;</span><br><span class="line">    <span class="comment">// 遍历所有Field:</span></span><br><span class="line">    <span class="keyword">for</span> (Field field : person.getClass().getFields()) &#123;</span><br><span class="line">        <span class="comment">// 获取Field定义的@Range:</span></span><br><span class="line">        <span class="type">Range</span> <span class="variable">range</span> <span class="operator">=</span> field.getAnnotation(Range.class);</span><br><span class="line">        <span class="comment">// 如果@Range存在:</span></span><br><span class="line">        <span class="keyword">if</span> (range != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取Field的值:</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> field.get(person);</span><br><span class="line">            <span class="comment">// 如果值是String:</span></span><br><span class="line">            <span class="keyword">if</span> (value <span class="keyword">instanceof</span> String s) &#123;</span><br><span class="line">                <span class="comment">// 判断值是否满足@Range的min/max:</span></span><br><span class="line">                <span class="keyword">if</span> (s.length() &lt; range.min() || s.length() &gt; range.max()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Invalid field: &quot;</span> + field.getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样一来，通过标注<code>@Range</code>注解，配合<code>check()</code>方法处理，就完成了<code>Person</code>实例的检查。</p>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p><strong>为什么需要泛型？</strong></p>
<p>复用，类型安全，避免出现误转型</p>
<p><strong>泛型的原理</strong></p>
<p>“类型擦除”，自动转型。</p>
<h3 id="定义泛型"><a href="#定义泛型" class="headerlink" title="定义泛型"></a>定义泛型</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(T e)</span> &#123;...&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;...&#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在类名后头用<code>&lt;T&gt;</code>声明类型参数，这个类型可以是任意类型。</p>
<blockquote>
<p>定义接口泛型也是类似</p>
</blockquote>
<h4 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a><strong>向上转型</strong></h4><p><code>ArrayList&lt;Integer&gt;</code>不可以向上转型为<code>ArrayList&lt;Number&gt;</code>或<code>List&lt;Number&gt;</code>。</p>
<p>&#x3D;&#x3D;<strong>泛型不一致不能向上转型</strong>&#x3D;&#x3D;</p>
<p>如果允许成功赋值，在对它进行读取时就会出现类型错误，如 Double 写入了本就是 Integer 的 Number。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建ArrayList&lt;Integer&gt;类型：</span></span><br><span class="line">ArrayList&lt;Integer&gt; integerList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line"><span class="comment">// 添加一个Integer：</span></span><br><span class="line">integerList.add(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">123</span>));</span><br><span class="line"><span class="comment">// “向上转型”为ArrayList&lt;Number&gt;：</span></span><br><span class="line">ArrayList&lt;Number&gt; numberList = integerList;</span><br><span class="line"><span class="comment">// 添加一个Float，因为Float也是Number：</span></span><br><span class="line">numberList.add(<span class="keyword">new</span> <span class="title class_">Float</span>(<span class="number">12.34</span>));</span><br><span class="line"><span class="comment">// 从ArrayList&lt;Integer&gt;获取索引为1的元素（即添加的Float）：</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> integerList.get(<span class="number">1</span>); <span class="comment">// ClassCastException!</span></span><br></pre></td></tr></table></figure>

<p>允许类型<code>ArrayList&lt;T&gt;</code>可以向上转型为<code>List&lt;T&gt;</code>，必须保证泛型一致。</p>
<p>T 可以是 ?，表示可以是任意类型</p>
<p><code>ArrayList&lt;T&gt;</code>可以向上转型为 <code>ArrayList&lt;?&gt; </code></p>
<h4 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(T first, T last)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.first = first;</span><br><span class="line">        <span class="built_in">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getFirst</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getLast</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对静态方法使用&lt;T&gt;:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Pair&lt;T&gt; <span class="title function_">create</span><span class="params">(T first, T last)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;T&gt;(first, last);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>像这种直接在静态方法中使用泛型参数会报错，但是可以用声明泛型方法的方式来使用泛型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 静态泛型方法应该使用其他类型区分:</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K&gt; Pair&lt;K&gt; <span class="title function_">create</span><span class="params">(K first, K last)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;K&gt;(first, last);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态方法的泛型参数是区别于泛型类的，因为不用指定泛型也可以使用静态方法。</p>
<h4 id="多个泛型"><a href="#多个泛型" class="headerlink" title="多个泛型"></a>多个泛型</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T, K&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> K last;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(T first, K last)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.first = first;</span><br><span class="line">        <span class="built_in">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getFirst</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">public</span> K <span class="title function_">getLast</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类似 <code>Map&lt;K, V&gt;</code></p>
<h3 id="使用泛型"><a href="#使用泛型" class="headerlink" title="使用泛型"></a>使用泛型</h3><p>使用<code>ArrayList</code>带有泛型的类时，如果不声明泛型类型时，泛型类型实际上就是<code>Object</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编译器警告:</span></span><br><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">list.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;World&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">first</span> <span class="operator">=</span> (String) list.get(<span class="number">0</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">second</span> <span class="operator">=</span> (String) list.get(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>此时，只能把<code>&lt;T&gt;</code>当作<code>Object</code>使用，没有发挥泛型的优势，依旧需要手动转型。</p>
<p>当我们定义泛型类型<code>&lt;String&gt;</code>后，<code>List&lt;T&gt;</code>的泛型接口变为强类型<code>List&lt;String&gt;</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无编译器警告:</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;World&quot;</span>);</span><br><span class="line"><span class="comment">// 无强制转型:</span></span><br><span class="line"><span class="type">String</span> <span class="variable">first</span> <span class="operator">=</span> list.get(<span class="number">0</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">second</span> <span class="operator">=</span> list.get(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>如果类型声明了泛型类型，在 new 实例时可以省略，由编译器自动推断。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以省略后面的Number，编译器可以自动推断泛型类型：</span></span><br><span class="line">List&lt;Number&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>



<h3 id="擦拭法"><a href="#擦拭法" class="headerlink" title="擦拭法"></a>擦拭法</h3><p>擦拭法是指，虚拟机对泛型其实一无所知，所有的工作像对泛型的检查和转换都是编译器做的。</p>
<p>擦拭法的效果：</p>
<ul>
<li>编译器把类型<code>&lt;T&gt;</code>视为<code>Object</code>；</li>
<li>编译器根据<code>&lt;T&gt;</code>实现安全的强制转型。</li>
</ul>
<p>使用泛型的时候，我们编写的代码也是编译器看到的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair&lt;String&gt; p = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">first</span> <span class="operator">=</span> p.getFirst();</span><br><span class="line"><span class="type">String</span> <span class="variable">last</span> <span class="operator">=</span> p.getLast();</span><br></pre></td></tr></table></figure>

<p>而虚拟机执行的代码并没有泛型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Pair</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pair</span>(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">first</span> <span class="operator">=</span> (String) p.getFirst();</span><br><span class="line"><span class="type">String</span> <span class="variable">last</span> <span class="operator">=</span> (String) p.getLast();</span><br></pre></td></tr></table></figure>

<p>所以，Java的泛型是由编译器在编译时实行的，<strong>编译器</strong>内部永远把所有类型<code>T</code>视为<code>Object</code>处理，但是，在需要转型的时候，<strong>编译器</strong>会根据<code>T</code>的类型自动为我们实行安全地强制转型。</p>
<h4 id="带来的局限"><a href="#带来的局限" class="headerlink" title="带来的局限"></a>带来的局限</h4><ol>
<li><code>&lt;T&gt;</code>不能是基本类型，因为基本类型无法对Object进行强制转型。</li>
<li>泛型类的 Class 实例都是同一个</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair&lt;String&gt; p1 = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">Pair&lt;Integer&gt; p2 = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line"><span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> p1.getClass();</span><br><span class="line"><span class="type">Class</span> <span class="variable">c2</span> <span class="operator">=</span> p2.getClass();</span><br><span class="line">System.out.println(c1==c2); <span class="comment">// true</span></span><br><span class="line">System.out.println(c1==Pair.class); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>无法用 instanceof 判断带泛型的类型</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair&lt;Integer&gt; p = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line"><span class="comment">// Compile error:</span></span><br><span class="line"><span class="keyword">if</span> (p <span class="keyword">instanceof</span> Pair&lt;String&gt;) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>不能使用 new 关键字实例化 T 类型，因为实际上会变成<code>new Object()</code></li>
</ol>
<h4 id="不能覆写Object类的方法"><a href="#不能覆写Object类的方法" class="headerlink" title="不能覆写Object类的方法"></a>不能覆写Object类的方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(T t)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.val == t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果覆盖了Object方法，会导致两个类被向上转型为Object时，出现类型转换错误。</p>
<h4 id="泛型继承"><a href="#泛型继承" class="headerlink" title="泛型继承"></a>泛型继承</h4><p>一个类可以继承自一个泛型类。例如：父类的类型是<code>Pair&lt;Integer&gt;</code>，子类的类型是<code>IntPair</code>，可以这么继承：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntPair</span> <span class="keyword">extends</span> <span class="title class_">Pair</span>&lt;Integer&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用的时候，因为子类<code>IntPair</code>并没有泛型类型，所以，正常使用即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">IntPair</span> <span class="variable">ip</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntPair</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>前面讲了，我们无法获取<code>Pair&lt;T&gt;</code>的<code>T</code>类型，即给定一个变量<code>Pair&lt;Integer&gt; p</code>，无法从<code>p</code>中获取到<code>Integer</code>类型。</p>
<p>但是在父类是泛型类型的情况下，编译器会把类型<code>T</code>（对<code>IntPair</code>来说，也就是<code>Integer</code>类型）保存到子类的class文件中，不然编译器就不知道<code>IntPair</code>只能存取<code>Integer</code>这种类型。</p>
<h4 id="获取父类泛型类型"><a href="#获取父类泛型类型" class="headerlink" title="获取父类泛型类型"></a>获取父类泛型类型</h4><p>在继承了泛型类型的情况下，子类可以获取父类的泛型类型。</p>
<p>例如：<code>IntPair</code>可以获取到父类的泛型类型<code>Integer</code>。获取父类的泛型类型代码比较复杂：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.ParameterizedType;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Class&lt;IntPair&gt; clazz = IntPair.class;</span><br><span class="line">        <span class="type">Type</span> <span class="variable">t</span> <span class="operator">=</span> clazz.getGenericSuperclass();</span><br><span class="line">        <span class="keyword">if</span> (t <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">            <span class="type">ParameterizedType</span> <span class="variable">pt</span> <span class="operator">=</span> (ParameterizedType) t;</span><br><span class="line">            Type[] types = pt.getActualTypeArguments(); <span class="comment">// 可能有多个泛型类型</span></span><br><span class="line">            <span class="type">Type</span> <span class="variable">firstType</span> <span class="operator">=</span> types[<span class="number">0</span>]; <span class="comment">// 取第一个泛型类型</span></span><br><span class="line">            Class&lt;?&gt; typeClass = (Class&lt;?&gt;) firstType;</span><br><span class="line">            System.out.println(typeClass); <span class="comment">// Integer</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="类型标识继承关系"><a href="#类型标识继承关系" class="headerlink" title="类型标识继承关系"></a>类型标识继承关系</h4><p><img src="/../assets/image-20240423215603321.png" alt="image-20240423215603321"></p>
<h3 id="extends、super"><a href="#extends、super" class="headerlink" title="extends、super"></a>extends、super</h3><h4 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Pair&lt;Integer&gt; p = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> add(p);</span><br><span class="line">        System.out.println(n);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(Pair&lt;? extends Number&gt; p)</span> &#123;</span><br><span class="line">        <span class="type">Number</span> <span class="variable">first</span> <span class="operator">=</span> p.getFirst();</span><br><span class="line">        <span class="type">Number</span> <span class="variable">last</span> <span class="operator">=</span> p.getLast();</span><br><span class="line">        <span class="keyword">return</span> first.intValue() + last.intValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>? extends Number</code> 表示该泛型可以是Number或其子类。</p>
<p>允许传入 <code>Pair&lt;Integer&gt;</code>。</p>
<p>这种使用<code>&lt;? extends Number&gt;</code>的泛型定义称之为上界通配符（Upper Bounds Wildcards），即把泛型类型<code>T</code>的上界限定在<code>Number</code>了。</p>
<p>如果声明的类型是 <code>Pair&lt;Number&gt;</code> ，无法传入 <code>Pair&lt;Integer&gt;</code> ，因为后者无法向上转型为前者。</p>
<p><strong>限制：</strong></p>
<p>方法参数签名<code>setFirst(? extends Number)</code>无法传递任何<code>Number</code>的子类型给<code>setFirst(? extends Number)</code>。</p>
<p>因为 Double 和 Integer 都可以传入，编译器会阻止这种类型不安全的行为。</p>
<p>例外：可以传入 null</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">p.setFirst(<span class="literal">null</span>); <span class="comment">// ok, 但是后面会抛出NullPointerException</span></span><br><span class="line">p.getFirst().intValue(); <span class="comment">// NullPointerException</span></span><br></pre></td></tr></table></figure>

<p><strong>应用场景</strong></p>
<p>使用 extends 限定 T 的上界</p>
<p>例如定义 <code>Pair&lt;T extends Number&gt;</code>，则该泛型参数 T 只能传入 Number 的子类。</p>
<blockquote>
<p>T 和 ? 的区别：</p>
<p>? 表示一个通配符，可以传入任何类型。</p>
<p>T 表示一个泛型参数，在定义泛型类或方法时，需要用 T 来描述其他内容。</p>
</blockquote>
<h4 id="super"><a href="#super" class="headerlink" title="super"></a>super</h4><p>和 extends 相反，super 限定了 T 的下界。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">set</span><span class="params">(Pair&lt;? <span class="built_in">super</span> Integer&gt; p, Integer first, Integer last)</span> &#123;</span><br><span class="line">    p.setFirst(first);</span><br><span class="line">    p.setLast(last);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>? super Integer</code> 表示接收泛型类型为 Integer 或其父类。</p>
<p><strong>限制</strong></p>
<p>super 允许写，不允许读。</p>
<p>因为类型无法向下转型。</p>
<h4 id="对比extends和super通配符"><a href="#对比extends和super通配符" class="headerlink" title="对比extends和super通配符"></a>对比extends和super通配符</h4><p>我们再回顾一下<code>extends</code>通配符。作为方法参数，<code>&lt;? extends T&gt;</code>类型和<code>&lt;? super T&gt;</code>类型的区别在于：</p>
<ul>
<li><code>&lt;? extends T&gt;</code>允许调用读方法<code>T get()</code>获取<code>T</code>的引用，但不允许调用写方法<code>set(T)</code>传入<code>T</code>的引用（传入<code>null</code>除外）；</li>
<li><code>&lt;? super T&gt;</code>允许调用写方法<code>set(T)</code>传入<code>T</code>的引用，但不允许调用读方法<code>T get()</code>获取<code>T</code>的引用（获取<code>Object</code>除外）。</li>
</ul>
<p>一个是允许读不允许写，另一个是允许写不允许读。</p>
<p>先记住上面的结论，我们来看Java标准库的<code>Collections</code>类定义的<code>copy()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Collections</span> &#123;</span><br><span class="line">    <span class="comment">// 把src的每个元素复制到dest中:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">copy</span><span class="params">(List&lt;? <span class="built_in">super</span> T&gt; dest, List&lt;? extends T&gt; src)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;src.size(); i++) &#123;</span><br><span class="line">            <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> src.get(i);</span><br><span class="line">            dest.add(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>为什么 super 支持写，extends 支持读</strong></p>
<p>写：因为 super 可以传入 T 的超类，此时的泛型就有可能是 T 或其超类，在 set 时就允许向上转型赋值；而 extends 允许传入子类，如果对其赋值，就是向下转型了。</p>
<p>写：因为 extends 允许传入子类，此时的泛型就是 T 或其子类，那么 get 时，就可以使用 T （上界）来接收，满足向上转型，而 super 允许传入超类，此时这个 T 就是它的下界，不允许向下赋值。</p>
<p>因此，super和extends的读写，可以单独允许Object和null</p>
<h4 id="无限定通配符"><a href="#无限定通配符" class="headerlink" title="无限定通配符"></a>无限定通配符</h4><p>Java的泛型还允许使用无限定通配符（Unbounded Wildcard Type），即只定义一个<code>?</code>：</p>
<p>因为<code>&lt;?&gt;</code>通配符既没有<code>extends</code>，也没有<code>super</code>，因此：</p>
<ul>
<li>不允许调用<code>set(T)</code>方法并传入引用（<code>null</code>除外）；</li>
<li>不允许调用<code>T get()</code>方法并获取<code>T</code>引用（只能获取<code>Object</code>引用）。</li>
</ul>
<p>换句话说，既不能读，也不能写，那只能做一些<code>null</code>判断：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isNull</span><span class="params">(Pair&lt;?&gt; p)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> p.getFirst() == <span class="literal">null</span> || p.getLast() == <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大多数情况下，可以引入泛型参数<code>&lt;T&gt;</code>消除<code>&lt;?&gt;</code>通配符：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="type">boolean</span> <span class="title function_">isNull</span><span class="params">(Pair&lt;T&gt; p)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> p.getFirst() == <span class="literal">null</span> || p.getLast() == <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>&lt;?&gt;</code>通配符有一个独特的特点，就是：<code>Pair&lt;?&gt;</code>是所有<code>Pair&lt;T&gt;</code>的超类：</p>
<h3 id="泛型和反射"><a href="#泛型和反射" class="headerlink" title="泛型和反射"></a>泛型和反射</h3><h4 id="泛型-Class"><a href="#泛型-Class" class="headerlink" title="泛型 Class"></a>泛型 Class</h4><p>Java的部分反射API也是泛型。例如：<code>Class&lt;T&gt;</code>就是泛型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// compile warning:</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> String.class;</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String) clazz.newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">// no warning:</span></span><br><span class="line">Class&lt;String&gt; clazz = String.class;</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> clazz.newInstance();</span><br></pre></td></tr></table></figure>

<p>调用<code>Class</code>的<code>getSuperclass()</code>方法返回的<code>Class</code>类型是<code>Class&lt;? super T&gt;</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;? <span class="built_in">super</span> String&gt; sup = String.class.getSuperclass();</span><br></pre></td></tr></table></figure>

<h4 id="泛型-Constructor"><a href="#泛型-Constructor" class="headerlink" title="泛型 Constructor"></a>泛型 Constructor</h4><p>构造方法<code>Constructor&lt;T&gt;</code>也是泛型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;Integer&gt; clazz = Integer.class;</span><br><span class="line">Constructor&lt;Integer&gt; cons = clazz.getConstructor(<span class="type">int</span>.class);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> cons.newInstance(<span class="number">123</span>);</span><br></pre></td></tr></table></figure>

<h4 id="泛型数组"><a href="#泛型数组" class="headerlink" title="泛型数组"></a>泛型数组</h4><p>我们可以<strong>声明</strong>带泛型的数组，但不能用<code>new</code>操作符<strong>创建</strong>带泛型的数组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair&lt;String&gt;[] ps = <span class="literal">null</span>; <span class="comment">// ok</span></span><br><span class="line">Pair&lt;String&gt;[] ps = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;String&gt;[<span class="number">2</span>]; <span class="comment">// compile error!</span></span><br></pre></td></tr></table></figure>

<p>可以通过强制转型实现“带泛型”的数组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">Pair&lt;String&gt;[] ps = (Pair&lt;String&gt;[]) <span class="keyword">new</span> <span class="title class_">Pair</span>[<span class="number">2</span>];</span><br></pre></td></tr></table></figure>

<p>但是数组实际上在运行期没有泛型，而是 <code>Pair&lt;Object&gt;[]</code>。</p>
<p>因为类型擦拭，只能通过编译器来强制检查变量<code>ps</code>。</p>
<p><strong>注意：通过绕过泛型声明的引用依旧可以使用任意类型修改创建的数组</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair[] arr = <span class="keyword">new</span> <span class="title class_">Pair</span>[<span class="number">2</span>];</span><br><span class="line">Pair&lt;String&gt;[] ps = (Pair&lt;String&gt;[]) arr;</span><br><span class="line"></span><br><span class="line">ps[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;String&gt;(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>);</span><br><span class="line">arr[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;Integer&gt;(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ClassCastException:</span></span><br><span class="line">Pair&lt;String&gt; p = ps[<span class="number">1</span>];</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> p.getFirst();</span><br></pre></td></tr></table></figure>

<p>虽然这两个变量实际上指向同一个数组，但是操作<code>arr</code>可以传入非String的参数。</p>
<p><strong>要安全地使用泛型声明数组，必须扔掉原来<code>arr</code>的引用：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">Pair&lt;String&gt;[] ps = (Pair&lt;String&gt;[]) <span class="keyword">new</span> <span class="title class_">Pair</span>[<span class="number">2</span>];</span><br></pre></td></tr></table></figure>

<p>上面的代码中，由于拿不到原始数组的引用，就只能对泛型数组<code>ps</code>进行操作，这种操作就是安全的。</p>
<p>带泛型的数组实际上是编译器的类型擦除：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair[] arr = <span class="keyword">new</span> <span class="title class_">Pair</span>[<span class="number">2</span>];</span><br><span class="line">Pair&lt;String&gt;[] ps = (Pair&lt;String&gt;[]) arr;</span><br><span class="line"></span><br><span class="line">System.out.println(ps.getClass() == Pair[].class); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> (String) arr[<span class="number">0</span>].getFirst();</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> ps[<span class="number">0</span>].getFirst();</span><br></pre></td></tr></table></figure>

<p>所以我们不能直接创建泛型数组<code>T[]</code>，因为擦拭后代码变为<code>Object[]</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// compile error:</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Abc</span>&lt;T&gt; &#123;</span><br><span class="line">    T[] createArray() &#123;</span><br><span class="line">        <span class="comment">// 实际上返回 Object[]，换个引用就可以随意get,set任何类型</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">T</span>[<span class="number">5</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>创建泛型数组</strong></p>
<ol>
<li>借助<code>Class&lt;T&gt;</code>来创建泛型数组：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">T[] createArray(Class&lt;T&gt; cls) &#123;</span><br><span class="line">    <span class="keyword">return</span> (T[]) Array.newInstance(cls, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>利用可变参数创建泛型数组<code>T[]</code>：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayHelper</span> &#123;</span><br><span class="line">    <span class="meta">@SafeVarargs</span></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; T[] asArray(T... objs) &#123;</span><br><span class="line">        <span class="keyword">return</span> objs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String[] ss = ArrayHelper.asArray(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">Integer[] ns = ArrayHelper.asArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<h4 id="谨慎使用泛型可变参数"><a href="#谨慎使用泛型可变参数" class="headerlink" title="谨慎使用泛型可变参数"></a>谨慎使用泛型可变参数</h4><p>在上面的例子中，我们看到，通过：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; T[] asArray(T... objs) &#123;</span><br><span class="line">    <span class="keyword">return</span> objs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>似乎可以安全地创建一个泛型数组。但实际上，这种方法非常危险。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] arr = asArray(<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">        <span class="comment">// ClassCastException:</span></span><br><span class="line">        String[] firstTwo = pickTwo(<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(firstTwo));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &lt;K&gt; K[] pickTwo(K k1, K k2, K k3) &#123;</span><br><span class="line">        <span class="comment">// 传入的 k1, k2 参数其实是 Object 类型</span></span><br><span class="line">        <span class="keyword">return</span> asArray(k1, k2);  <span class="comment">// 返回 Object[]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; T[] asArray(T... objs) &#123;</span><br><span class="line">        <span class="comment">// 直接返回可变参数数组，可以识别，返回 T[]</span></span><br><span class="line">        <span class="keyword">return</span> objs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接调用<code>asArray(T...)</code>没有问题，直接将获取到的类型参数数组返回。</p>
<p>而如果在另一个方法中调用该方法，传入参数时，参数的类型已经被擦除了。</p>
<p>所以就会返回Object[]，然后产生<code>ClassCastException</code>。</p>
<p>编译器对所有可变泛型参数都会发出警告，只有确认完全没有问题，才可以用<code>@SafeVarargs</code>消除警告。</p>
<p> &#x3D;&#x3D;如果在<strong>方法内部</strong>创建了泛型数组，最好不要将它返回给外部使用。&#x3D;&#x3D;</p>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><p>List 只是一个接口，用来规范使用方法。</p>
<ul>
<li>在末尾添加一个元素：<code>boolean add(E e)</code></li>
<li>在指定索引添加一个元素：<code>boolean add(int index, E e)</code></li>
<li>删除指定索引的元素：<code>E remove(int index)</code></li>
<li>删除某个元素：<code>boolean remove(Object e)</code></li>
<li>获取指定索引的元素：<code>E get(int index)</code></li>
<li>获取链表大小（包含元素的个数）：<code>int size()</code></li>
</ul>
<p>要创建一个 List 实例，可以借助 <code>ArrayList</code> 或 <code>LinkedList</code>。</p>
<p>一个是线性表，一个是链表，区别如下。</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">ArrayList</th>
<th>LinkedList</th>
</tr>
</thead>
<tbody><tr>
<td align="left">获取指定元素</td>
<td align="left">速度很快</td>
<td>需要从头开始查找元素</td>
</tr>
<tr>
<td align="left">添加元素到末尾</td>
<td align="left">速度很快</td>
<td>速度很快</td>
</tr>
<tr>
<td align="left">在指定位置添加&#x2F;删除</td>
<td align="left">需要移动元素</td>
<td>不需要移动元素</td>
</tr>
<tr>
<td align="left">内存占用</td>
<td align="left">少</td>
<td>较大</td>
</tr>
</tbody></table>
<h4 id="List-of"><a href="#List-of" class="headerlink" title="List.of"></a>List.of</h4><p>Java 11以后，可以用 List.of(…T) 静态方法创建一个<strong>只读</strong>的列表。</p>
<p>注意：</p>
<ol>
<li>不允许传入 null</li>
<li>对只读<code>List</code>调用<code>add()</code>、<code>remove()</code>方法会抛出<code>UnsupportedOperationException</code>。</li>
</ol>
<h4 id="List转Array"><a href="#List转Array" class="headerlink" title="List转Array"></a>List转Array</h4><ol>
<li><p>直接调用 toArray 方法，返回 Object 类型数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object[] array = list.toArray();</span><br></pre></td></tr></table></figure>
</li>
<li><p>传入一个数组，返回该数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] arr = list.toArray(<span class="keyword">new</span> <span class="title class_">Integer</span>[<span class="number">5</span>]);</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>传入的数组类型如果和list类型无法兼容，会抛出 <code>ArrayStoreException</code></li>
<li>如果传入的数组容量比list小，会被截掉</li>
</ul>
</li>
<li><p>传入数组的构造方法引用</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] arr = intList.toArray(Integer[]::<span class="keyword">new</span>)</span><br></pre></td></tr></table></figure>



<h4 id="Array转List"><a href="#Array转List" class="headerlink" title="Array转List"></a>Array转List</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(...T)</span><br></pre></td></tr></table></figure>



<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h4 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h4><p>同 List，Map 只是一个接口</p>
<p><strong>常用方法</strong></p>
<ul>
<li>插入元素：<code>V put(K key, V value)</code></li>
<li>访问value：<code>V get(K key)</code></li>
<li>是否包含某个key：<code>boolean containsKey(K key)</code></li>
<li>是否包含某个value：<code>boolean containsValue(K key)</code></li>
<li>返回所有的key：<code>Set&lt;K&gt; keySet()</code></li>
<li>返回所有的value：<code>Collection&lt;V&gt; values()</code></li>
<li>返回所有的键值对：<code>Set&lt;Entry&lt;K, v&gt;&gt; entrySet()</code></li>
</ul>
<p><strong>注意：</strong></p>
<ol>
<li>不存在重复的key，如果对相同的key进行put，会替换掉这个key映射的value，并返回上次的value。</li>
<li>keySet  不一定是有序的。</li>
</ol>
<p><strong>实现类</strong></p>
<ol>
<li>HashMap：无序</li>
<li>TreeMap：有序，可以传入一个比较器来给key排序，默认按照key本身的Comparator</li>
</ol>
<h4 id="HashMap的本质"><a href="#HashMap的本质" class="headerlink" title="HashMap的本质"></a>HashMap的本质</h4><p>通过空间换时间，用一个大数组来存储value，这样就可以直接索引。</p>
<p><strong>步骤：</strong></p>
<ol>
<li>再通过 key 的 hashCode 方法计算出 hash 值，即该 key 对应 value 在数组中存储的索引值。</li>
<li>如果 hash 值相同，再根据 key 的 equals 方法重新计算。</li>
</ol>
<p><strong>数组长度</strong></p>
<p>HashMap 初始化时默认的数组大小只有 16。</p>
<p>通过类似如下算法的方式，控制 hash 值的分布范围：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> key.hashCode() &amp; <span class="number">0xf</span>; <span class="comment">// 0xf = 15</span></span><br></pre></td></tr></table></figure>

<p>如果添加到超过初始长度后，内部会进行扩容。</p>
<p>&#x3D;&#x3D;为了能方便进行位运算，每次扩容后的长度会保证为 2^n^&#x3D;&#x3D;</p>
<p>为了保证性能，最少创建时就指定相应的容量</p>
<blockquote>
<p>使用 ArrayList 实现类同理</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">10000</span>);</span><br></pre></td></tr></table></figure>

<p>虽然指定容量是<code>10000</code>，但<code>HashMap</code>内部的数组长度总是2n，因此，实际数组长度被初始化为比<code>10000</code>大的<code>16384</code>（214）。</p>
<h4 id="hashcode重复"><a href="#hashcode重复" class="headerlink" title="hashcode重复"></a>hashcode重复</h4><p>假如存入了两个 key，但是非常巧合的是它们的 hashcode 重复了。</p>
<p>那么，在<code>HashMap</code>的数组中，存储的就不是一个 value 了</p>
<p><strong>而是一个由重复的 hashcode 对应 key 的 value 的 <code>List</code>，包含这两个 key 对应的键值对。</strong></p>
<p>于是查找的方法，就不只是直接索引了，而是索引之后再遍历这个 list，找到相应的 key。</p>
<p>如果冲突的概率越大，这个<code>List</code>就越长，<code>Map</code>的<code>get()</code>方法效率就越低</p>
<p>不同的<code>key</code>具有相同的<code>hashCode()</code>的情况称之为<strong>哈希冲突</strong>。</p>
<blockquote>
<p>在冲突的时候，一种最简单的解决办法是用<code>List</code>存储<code>hashCode()</code>相同的<code>key-value</code>。</p>
<p>也可以用链表，树等结构</p>
</blockquote>
<p>总之：hash 值的唯一性决定了 HashMap 的查询性能。</p>
<h4 id="对比-Hashtable"><a href="#对比-Hashtable" class="headerlink" title="对比 Hashtable"></a>对比 Hashtable</h4><ol>
<li>继承类不同 dictionary</li>
<li>提供接口不同</li>
<li>对 key-value 的 null 值</li>
<li>线程安全</li>
<li>遍历方式</li>
<li>容量分配</li>
<li>hash值计算方式</li>
</ol>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><h4 id="使用-3"><a href="#使用-3" class="headerlink" title="使用"></a>使用</h4><p><code>Set</code>用于存储不重复的元素集合，它主要提供以下几个方法：</p>
<ul>
<li>将元素添加进<code>Set&lt;E&gt;</code>：<code>boolean add(E e)</code></li>
<li>将元素从<code>Set&lt;E&gt;</code>删除：<code>boolean remove(Object e)</code></li>
<li>判断是否包含元素：<code>boolean contains(Object e)</code></li>
</ul>
<h4 id="HashSet的本质"><a href="#HashSet的本质" class="headerlink" title="HashSet的本质"></a>HashSet的本质</h4><p><code>HashSet</code>仅仅是对<code>HashMap</code>的一个简单封装，只管理key，而放入相同的Object作为value。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSet</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Set</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="comment">// 持有一个HashMap:</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;E, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 放入HashMap的value:</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.put(e, PRESENT) == <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.containsKey(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.remove(o) == PRESENT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="SortedSet"><a href="#SortedSet" class="headerlink" title="SortedSet"></a>SortedSet</h4><p>Set 是无序的，而 SortedSet 接口继承至 Set，并且是有序的。</p>
<p>实现类是：TreeSet，需要传入一个比较器，如果没有就使用 key 默认的比较器。</p>
<h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><blockquote>
<p>File类，与输入输出流都存放在Java.io包内。</p>
</blockquote>
<p>&#x3D;&#x3D;所有的输入输出类，都必须被异常处理包裹，捕捉FileNotFoundException&#x3D;&#x3D;</p>
<h5 id="1-File类"><a href="#1-File类" class="headerlink" title="1. File类"></a>1. File类</h5><p>File对象主要用来获取文件本身的一些信息，不涉及对文件的读写操作。</p>
<p><strong>构造函数</strong></p>
<ul>
<li>File(String filename);</li>
<li>File(String directoryPath,String filename);</li>
<li>File(File f，String filename);</li>
</ul>
<p>&#x3D;&#x3D;即使文件不存在，也不会报出异常&#x3D;&#x3D;</p>
<p><strong>常用方法</strong></p>
<ul>
<li>public String getName() 获取文件的名字。</li>
<li>public boolean canRead() 判断文件是否是可读的。</li>
<li>public boolean canWrite() 判断文件是否可被写入。</li>
<li>public boolean exits() 判断文件是否存在。</li>
<li>public <strong>long</strong> length() 获取文件的长度（单位是字节）。</li>
</ul>
<p>即长度为该文件内容为多少个字节，返回类型是long。</p>
<p>假如文件内容为：我是who12(整型)1000（long类型），那么读取到的length为4+3+4+8 &#x3D; 19个字节。</p>
<ul>
<li>public String getAbsolutePath() 获取文件的绝对路径。</li>
<li>public boolean isFile() 判断文件是否是一个普通文件，而不是目录。</li>
<li>public boolean isDirectroy() 判断文件是否是一个目录。</li>
</ul>
<h5 id="2-输入输出流"><a href="#2-输入输出流" class="headerlink" title="2. 输入输出流"></a>2. 输入输出流</h5><ul>
<li>FileInputStream</li>
</ul>
<p>以字节的形式读取文件</p>
<p>FileInputStream(String name);<br>FileInputStream(File file);<br>int read() 读取单个字节的数据<br>int read(byte b[]) 读取到字节数组b中，返回读取的实际字节长度，如果到达文件末尾则返回-1。<br>int read(byte b[]，int off，int len) 读取文件内容从off位置len个字节到字节数组b中</p>
<ul>
<li>FileOutputStream</li>
</ul>
<p>以字节的形式写入文件</p>
<p><strong>区别</strong> void write(byte b[],int off,int len) 从字节数组中偏移量off处取len个字节写到目的地。</p>
<ul>
<li>FileReader</li>
</ul>
<p>以字符的形式读取文件</p>
<p>nt read() 读取单个字符的数据<br>int read(char b[]) 读取到字符数组b中<br>int read(char b[]，int off，int len) 读取从off位置len个字符到字符数组b中</p>
<ul>
<li>FileWriter</li>
</ul>
<p>以字符的形式写入文件</p>
<p>使用方法类比即可</p>
<h5 id="3-缓冲流"><a href="#3-缓冲流" class="headerlink" title="3. 缓冲流"></a>3. 缓冲流</h5><p>缓冲流只能指向FileWriter或FileReader类对象，相较于提供了更多输入输出的方法，可以提高大文件（数据）的读写速度。</p>
<ul>
<li>BufferedReader，BufferedWriter</li>
</ul>
<p>readLine() 读取文本行<br>write(String s,int off,int len) 把字符串s写到文件中<br>newLine(); 向文件写入一个回行符</p>
<h5 id="4-随机访问文件流"><a href="#4-随机访问文件流" class="headerlink" title="4. 随机访问文件流"></a>4. 随机访问文件流</h5><p>RandomAccessFile类可以同时实现输入和输出操作。</p>
<p>构造函数：</p>
<p>RandomAccessFile(String name,String mode) ;<br>RandomAccessFile(File file,String mode) ;</p>
<p>mode指对文件的操作方式，如：r 表示只读，rw表示读和写，w表示写入。</p>
<p>使用方法：</p>
<p>read();</p>
<p>writeInt(); writeLong();</p>
<p>seek(long a)  定位RandomAccessFile流的读写位置<br>getFilePointer() 获取流的当前读写位置</p>
<p><strong>还有对象流（用来输入输出对象）等一些乱七八糟的</strong></p>
<h2 id="日期与时间"><a href="#日期与时间" class="headerlink" title="日期与时间"></a>日期与时间</h2><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><h2 id="加密与安全"><a href="#加密与安全" class="headerlink" title="加密与安全"></a>加密与安全</h2><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>多线程可以让程序同时执行多个任务。</p>
<p>但它的本质是<strong>多个任务轮流进行</strong>，比如让浏览器执行0.001秒，让QQ执行0.001秒，再让音乐播放器执行0.001秒，在人看来，CPU就是在同时执行多个任务。</p>
<p>即使是多核CPU，因为任务的数量往往多于CPU的核数，所以任务也是交替进行的。 </p>
<p><strong>为什么多线程操作在程序中往往比单线程快？</strong></p>
<p>以MySQL插入数据为例</p>
<p>因为MySQL内部将调度任务分为了多个线程，如果插入操作是单线程的，就无法占满所有的线程。</p>
<p>相当于给你10个工人，你却只用了一个工人。</p>
<blockquote>
<p>为什么MySQL内部需要多线程？</p>
<p>可能是因为有一些操作需要同时进行，如守护线程 :question:</p>
</blockquote>
<p>总之：在应用多线程中间件（到达目的地的管道）时，同时使用多线程操作才会比单线程快。</p>
<h3 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a><strong>进程与线程</strong></h3><p><img src="/assets/image-20240409104301471.png" alt="image-20240409104301471"></p>
<p>在计算机中，<strong>一个任务整体称为一个进程</strong>。</p>
<p>例如，浏览器就是一个进程，视频播放器是另一个进程，类似的，音乐播放器和Word都是进程。</p>
<p>一个任务整体（进程）里可以包含多个子任务（线程）。</p>
<p>例如，浏览器可以打开多个窗口，同时查看不同网站的内容，此时浏览器进程程执行了多个显示窗口的线程。</p>
<p><strong>进程与线程的关系</strong>：一个进程可以包含一个或多个线程，但<strong>至少</strong>会有一个线程。</p>
<blockquote>
<p><strong>操作系统调度的最小任务单位其实不是进程，而是线程。</strong></p>
</blockquote>
<p><strong>多进程和多线程对比</strong>：</p>
<p>多进程的缺点：</p>
<ol>
<li><p>开销大，创建进程开销大，尤其是在Windows系统上；</p>
</li>
<li><p>通信慢，进程间通信 比 线程间通信要慢，因为线程间通信就是读写同一个变量，速度很快。</p>
</li>
</ol>
<p>多进程的优点：</p>
<ol>
<li><p>稳定性高，多进程稳定性比多线程高，</p>
<p>因为在多进程的情况下，一个Java进程崩溃不会影响其他进程，而在多线程的情况下，任何一个线程崩溃会直接导致整个进程崩溃。</p>
</li>
</ol>
<h3 id="JVM-多线程"><a href="#JVM-多线程" class="headerlink" title="JVM 多线程"></a>JVM 多线程</h3><p>Java 语言内置了多线程支持，一个Java程序实际上是一个JVM进程。</p>
<p>JVM进程用一个主线程来执行<code>main()</code>方法，在<code>main()</code>方法内部也可以启动多个子线程。</p>
<p>此外，JVM还有负责垃圾回收的其他工作线程等。</p>
<p>和单线程相比，<strong>多线程编程的特点</strong>在于：多线程经常需要读写共享数据，并且需要同步。</p>
<h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><p><strong>创建步骤：</strong></p>
<ol>
<li>实例化一个Thread类对象，重写 run() 方法。</li>
<li>再调用Thread对象的start()方法，开启一个新线程。</li>
<li>线程启动后，会自动调用Thread对象的 run() 方法。</li>
</ol>
<p>在这种创建方法中，run方法体的内容就代表这该线程需要执行的任务。</p>
<p><strong>重写 run 的几种方法：</strong></p>
<ol>
<li>继承<code>Thread</code>类，重写<code>run()</code>方法：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start new thread!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>创建<code>Thread</code>实例时，传入一个<code>Runnable</code>实例：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">        t.start(); <span class="comment">// 启动新线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start new thread!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>或者直接传入Runable接口匿名类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>也可以使用 Java 8 后的 lambda 表达式</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>又或者创建 Thread 匿名类，重写run方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：</p>
<ul>
<li><p>在通过start()方法启动新线程后，该线程不一定立即执行。</p>
</li>
<li><p>直接调用线程的run()方法，无法启动新线程，只是执行一个普通方法而已。</p>
<p>线程的开启由 start() 方法代理，执行 run() 方法内容。</p>
</li>
</ul>
<p><strong>线程休眠</strong></p>
<p>通过调用 <code>Thread.sleep(milliseconds)</code> 静态方法，可以使线程休眠 x 毫秒</p>
<p>线程休眠方法会抛出 <code>InterruptedException</code> checked异常，必须显式捕获异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>设置线程的优先级</strong></p>
<p>可以在线程内部调用 <code>Thread.setPriority(n)</code>设置线程的优先级（1 - 10），默认值是5。</p>
<p>优先级高的线程被操作系统调度的优先级较高。</p>
<p>操作系统对高优先级线程可能调度更频繁，<strong>但无法确保高优先级的线程一定会先执行。</strong></p>
<h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><p>一个新的线程开启后，只会执行一次 run 方法，执行完毕代表该线程结束。</p>
<p>线程的状态有以下几种：</p>
<ul>
<li>New：新创建的线程，尚未执行；</li>
<li>Runnable：运行中的线程，正在执行<code>run()</code>方法的Java代码；</li>
<li>Blocked：运行中的线程，因为某些操作被阻塞而挂起；</li>
<li>Waiting：运行中的线程，因为某些操作在等待中；</li>
<li>Timed Waiting：运行中的线程，因为执行<code>sleep()</code>方法正在计时等待；</li>
<li>Terminated：线程已终止，因为<code>run()</code>方法执行完毕。</li>
</ul>
<p><img src="/assets/image-20240409113233199.png" alt="image-20240409113233199"></p>
<p>当线程启动后，它可以在<code>Runnable</code>、<code>Blocked</code>、<code>Waiting</code>和<code>Timed Waiting</code>这几个状态之间切换，直到最后变成<code>Terminated</code>状态，线程终止。</p>
<p><strong>线程终止的原因</strong>有：</p>
<ul>
<li>线程正常终止：<code>run()</code>方法执行到<code>return</code>语句返回；</li>
<li>线程意外终止：<code>run()</code>方法因为未捕获的异常导致线程终止；</li>
<li>对某个线程的<code>Thread</code>实例调用<code>stop()</code>方法强制终止（强烈不推荐使用）。</li>
</ul>
<h3 id="等待线程"><a href="#等待线程" class="headerlink" title="等待线程"></a><strong>等待线程</strong></h3><p>一个线程还可以等待另一个线程直到其运行结束。</p>
<p>例如，<code>main</code>线程在启动<code>t</code>线程后，可以通过<code>t.join()</code>等待<code>t</code>线程结束后再继续运行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;start&quot;</span>);</span><br><span class="line">        t.start();</span><br><span class="line">        t.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>join</code> <strong>含义理解</strong>：</p>
<p>t 线程加入 main 线程任务中，作为任务执行的一个步骤，只有等 t 执行完毕，main 线程任务的步骤才可以继续往下执行。</p>
<p>&#x3D;&#x3D;改正：不是等 t 执行完毕，而是等该线程调度结束，例如，死循环线程不会一直执行。&#x3D;&#x3D;</p>
<p>如果<code>t</code>线程已经结束，对实例<code>t</code>调用<code>join()</code>会立刻返回。</p>
<p>此外，<code>join(long)</code>的重载方法也可以指定一个等待时间，超过等待时间后就不再继续等待（就不要它加入了嘿嘿）。</p>
<h3 id="中断线程"><a href="#中断线程" class="headerlink" title="中断线程"></a>中断线程</h3><p>如果线程需要执行一个 <strong>长时间任务</strong>，就可能需要能<strong>控制的</strong>中断线程，确保这个任务是可控的。</p>
<p>中断线程有三种方法：</p>
<ol>
<li><strong>调用线程对象的<code>interrupt()</code>方法</strong></li>
</ol>
<p>通过调用interrupt方法，给线程传递一个中断的信号。</p>
<p><strong>目标线程需要通过调用继承 Thread 的 <code>isInterrupted()</code> 方法，反复检测自身状态是否是 interrupted 状态。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        t.start();</span><br><span class="line">        Thread.sleep(<span class="number">1</span>); 	<span class="comment">// 暂停 Main 线程1毫秒，确保线程 t 运行一次再结束。</span></span><br><span class="line">        t.interrupt(); 		<span class="comment">// 中断 t 线程</span></span><br><span class="line">        t.join(); 			<span class="comment">// 将 t 线程加入到 main 线程中，确保 “end” 最后输出</span></span><br><span class="line">        System.out.println(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 检测中断信号</span></span><br><span class="line">        <span class="keyword">while</span> (! isInterrupted()) &#123;</span><br><span class="line">            n ++;</span><br><span class="line">            System.out.println(n + <span class="string">&quot; hello!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong>首先开启了一个新的线程 t，该线程监听中断信号不断循环输出 hello（模拟长时间任务），然后 main 线程发出中断信号，同时 t 线程中的循环监听到了中断信号，随后停止运行，重新回到 main 线程继续执行，最后输出 “end”。</p>
<p><strong>注意：</strong>如果线程内没有检测中断信号，只是调用 <code>interrupt()</code> 方法线程是不会中断的。</p>
<p><strong>应用场景：</strong></p>
<p>首先需要注意的是，通过 interrupt 方法中断线程的前提，是目标线程必须时刻监听中断信号。</p>
<p>因此，目标线程应该将<strong>长时间任务转化为分片的任务</strong>，循环进行，同时监听中断信号。</p>
<ol start="2">
<li><strong>监听目标线程内其他线程的 join 方法。</strong></li>
</ol>
<p>假设有两个线程 A，B。</p>
<p>A 线程中对 B 线程调用了 join() 方法，而此时 A 线程又收到了 interrupt 信号</p>
<p>那么 join 方法就会抛出一个 <code>InterruptedException</code> 异常，A 线程就会结束运行。</p>
<p><strong>结束点</strong>：目标线程内部其他线程的 join 时刻</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        <span class="comment">// 开启线程 A</span></span><br><span class="line">        a.start();</span><br><span class="line">        a.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        <span class="comment">// 开启线程 B</span></span><br><span class="line">        b.start();</span><br><span class="line">        <span class="comment">// 捕获异常，但不做处理</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            b.join();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;&#125;</span><br><span class="line">        <span class="comment">// 中断线程 B</span></span><br><span class="line">        b.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(!isInterrupted())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;run&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">break</span>;	<span class="comment">// 如果不加break，概率导致死循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>为什么线程 B 监听了中断信号，在捕获异常时还需要 break？</strong></p>
<p>因为在对 B 线程调用 interrupt 方法时，如果线程 B 本身就在 waiting，sleeping 状态时，内部的 sleep 方法会抛出 InterrputedException 异常，并重置中断状态（isInterrupted&#x3D;false），所以要在捕获到异常时break。</p>
<p>:question: 上方答案存疑</p>
<ol start="3">
<li><strong>定义标志变量结束线程</strong></li>
</ol>
<p>例如，定义一个变量 running，然后在目标线程中监听其值来决定是否结束线程（类似 Thread 自身维护的 isInterrupt）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">HelloThread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloThread</span>();</span><br><span class="line">        t.start();</span><br><span class="line">        Thread.sleep(<span class="number">1</span>);</span><br><span class="line">        t.running = <span class="literal">false</span>; <span class="comment">// 将标志变量设置为false，结束线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HelloThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">running</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (running) &#123;</span><br><span class="line">            n ++;</span><br><span class="line">            System.out.println(n + <span class="string">&quot; hello!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;end!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>running 在此处代码中，同时作为了 main 和 t 线程之间共享的变量。</p>
<p><strong>变量的更新机制</strong></p>
<p>在Java虚拟机中，变量是保存在主内存的。</p>
<p>每个线程<strong>访问</strong>变量时，会先生成一个副本保存在自己的工作内存中。</p>
<p>如果线程<strong>修改</strong>了变量的值，虚拟机会在不确定的时刻再把修改后的值写回到主内存，存在线程之间变量不一致的问题！</p>
<p>例如，running &#x3D; false，然后 main 修改其为 true，但是没有写到主内存，那么此时线程 A 访问 running 仍会的到 true，而不会立刻结束线程，只有在回写到主内存后才会结束线程。</p>
<p>而 <code>volatile</code> 关键字的目的是告诉虚拟机：</p>
<ul>
<li>每次访问变量时，总是获取主内存的最新值；</li>
<li>每次修改变量后，立刻回写到主内存。</li>
</ul>
<p>这样就可以确保线程之间变量的一致性。</p>
<h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p>有一种线程的目的就是无限循环，无法设定结束条件。</p>
<p>例如，一个定时任务的线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TimerThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(LocalTime.now());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>已知 JVM 需要所有线程都运行结束后，才会退出。</strong> </p>
<p>如果存在这样一个无限执行的线程，且与任务无关，但是又需要在所有任务结束后，关闭 JVM 终止程序，该如何操作呢。</p>
<p>答案：守护线程。</p>
<p><strong>守护线程是指为其他线程服务的线程。</strong></p>
<p><strong>JVM 关闭时无需关心守护线程是否结束，只要其他线程结束就终止程序，同时顺带关闭守护线程</strong>。</p>
<p>创建守护线程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">t.setDaemon(<span class="literal">true</span>);</span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure>

<p>目标线程通过调用 setDeamon(true)；来将本线程设为守护线程。</p>
<p><strong>注意：</strong>守护线程不应该持有任何需要手动关闭的资源，如打开文件。因为该线程何时关闭是不确定的，无法释放资源。</p>
<h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><p><strong>同步：</strong>指两个变量始终保持一定的相对关系，可以是同时，也可以是完成同一个操作一前一后（你先做，再到我做）。</p>
<p>从 volatile 那一节中知道，如果多个线程同时读写共享的变量，会出现数据不一致的问题。</p>
<p>假设有两个加法线程，同时操作同一个变量，都执行加法操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">n = n + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>这一行语句被 JVM 解析成 3 条指令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ILOAD</span><br><span class="line">IADD</span><br><span class="line">ISTORE</span><br></pre></td></tr></table></figure>

<p><img src="/assets/image-20240410233303176.png" alt="image-20240410233303176"></p>
<p>如果线程 1 在LOAD后就被中断，转而执行线程 2，此时 n 还是 100，就会出现两个线程同时写入 101 给 n，而不是正常的 102。</p>
<p><strong>如何让线程 2 每次都基于线程 1 的结果继续运算呢？</strong></p>
<p>只需要保证当一个线程进行 LOAD, ADD, STORE 操作时，其他线程必须等待这一个线程执行完之后再依次执行，确保操作的<strong>原子性</strong>。</p>
<p>这样的操作被称为<strong>原子操作</strong></p>
<p><img src="/assets/image-20240410233957456.png" alt="image-20240410233957456"></p>
<p>这样的操作称为加锁，解锁。</p>
<p>通过加锁和解锁的操作，就能保证3条指令执行期间只有一个线程，不会有其他线程会进入此指令区间。</p>
<p>只有在执行线程解锁，将锁释放后，其他线程才能获得锁并执行这 3 条指令。</p>
<h4 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a><strong>synchronized</strong></h4><p>Java 使用 <code>synchronized</code> 关键字对一个对象进行加锁，保证了代码块在任意时刻最多只有一个线程能执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">add</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AddThread</span>();</span><br><span class="line">        <span class="type">var</span> <span class="variable">dec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DecThread</span>();</span><br><span class="line">        add.start();</span><br><span class="line">        dec.start();</span><br><span class="line">        add.join();</span><br><span class="line">        dec.join();</span><br><span class="line">        System.out.println(Counter.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Counter.lock) &#123;</span><br><span class="line">                Counter.count += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DecThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Counter.lock) &#123;</span><br><span class="line">                Counter.count -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里以 lock 作为锁，每个线程执行加减操作时需要先获取锁，如果这把锁被其他线程占用了，就需要等待锁被释放后，重新获取锁才能执行。</p>
<h4 id="保持线程之间同步的步骤："><a href="#保持线程之间同步的步骤：" class="headerlink" title="保持线程之间同步的步骤："></a><strong>保持线程之间同步的步骤：</strong></h4><ol>
<li>划出需要同步的代码块；</li>
<li>选择同一个对象作为锁；</li>
<li>使用 <code>synchronized(lockObject) &#123; ... &#125;</code> 包裹代码块。</li>
</ol>
<p><strong>注意</strong>：</p>
<ul>
<li>锁的对象必须是同一个，如果不同就会有两把锁，出现两个线程异步执行的情况。</li>
<li>获取锁和释放锁需要消耗一定的时间，所以，<code>synchronized</code>会降低程序的执行效率、性能。</li>
<li>不用担心同步过程中会抛出异常，锁会被正确释放。</li>
</ul>
<h4 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a><strong>原子操作</strong></h4><p>具有原子性的操作被称为原子操作。原子：不可以再被分解的物质。</p>
<p><strong>原子操作是指不能被中断的一个或一系列操作。</strong></p>
<p>对于原子操作不需要使用锁，因为每一个原子操作，都是在“一下”完成的，不被其他线程打断。</p>
<p>JVM规范定义了几种原子操作：</p>
<ul>
<li>基本类型（<code>long</code>和<code>double</code>除外，没有明确规定）赋值，例如：<code>int n = m</code>；</li>
<li>引用类型赋值，例如：<code>List&lt;String&gt; list = anotherList</code>。</li>
</ul>
<p>但如果是多行赋值操作，就需要给操作加锁（对象本身）了。</p>
<p>锁的对象随实际需要改变，这里假设多个线程用到了同一个 Pair 实例对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> x，<span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.x = x;</span><br><span class="line">            <span class="built_in">this</span>.y = y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 同时，读的操作也许加锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] get() &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="type">int</span>[] copy = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">            copy[<span class="number">0</span>] = x;</span><br><span class="line">            copy[<span class="number">1</span>] = y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果“写”操作不加锁，就会出现当 A 线程给 pair 对象的 x 赋值时，被 B 线程打断并重新把 x 赋值为另一个值，这时候 A 线程的逻辑就会不严谨。</p>
<p> 假设当前坐标是<code>(100, 200)</code>。</p>
<p>那么当设置新坐标为<code>(110, 220)</code>时，如果“读”操作不加锁，读到的值可能有：</p>
<ul>
<li>(100, 200)：x，y更新前；</li>
<li>(110, 200)：x更新后，y更新前就调用了 pair 的 get 方法；</li>
<li>(110, 220)：x，y更新后。</li>
</ul>
<p>加锁可以保证读的值不被污染，并且是最新。</p>
<p><strong>有时也可以巧妙的将非原子操作转换为原子操作</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] pair;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> x，<span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="comment">// 局部变量不需要同步</span></span><br><span class="line">        <span class="type">int</span>[] ps = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; x，y &#125;; </span><br><span class="line">        <span class="built_in">this</span>.pair = ps;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] get() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;x, y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 ps 是局部变量，不被其他线程可见，不存在被其他线程中途修改的问题。</p>
<p><strong>每个线程都会有各自的局部变量，互不影响，并且互不可见，并不需要同步。</strong></p>
<p>将多行赋值改为引用赋值，确保操作被“一次”执行，保证原子性。</p>
<p>同理这里的读操作也转为了原子操作，x,y 每次都同步读取，不存在读了线程 A 设置的 x 后，y 又变成了线程 B 设置的。</p>
<p>缺点就是无法保证每次都是最新的状态，可以再添加 <code>volatile</code> 关键字，确保实时性。</p>
<p>看到这里应该就明白 <code>volatile</code> 和 <code>synchronized</code> 之间的区别的吧。</p>
<p>区别：</p>
<ol>
<li>volatile 只用于保证状态更新后能被实时写入主内存，保证状态的实时性。</li>
<li>synchronized 则用于保证一连串操作同时只有一个线程在执行。</li>
</ol>
<p>如果用 volatile 来限制 n &#x3D; n + 1，只能确保每个线程更新后能立马写回主内存，但无法确保每个线程用来更新的值是其他线程执行完之后的值，还是操作了同一个值。</p>
<p>总之，volatile 只注重变量被赋值后“真正”更新的实时性。</p>
<h4 id="不可变对象无需同步"><a href="#不可变对象无需同步" class="headerlink" title="不可变对象无需同步"></a>不可变对象无需同步</h4><p>如果多线程读写的是一个不可变对象（如String，List），那么无需同步。</p>
<p>因为不会修改这个对象的状态，而是修改对象本身。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Data &#123;</span><br><span class="line">    List&lt;String&gt; names;</span><br><span class="line">    void set(String[] names) &#123;</span><br><span class="line">        this.names = List.of(names);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;String&gt; get() &#123;</span><br><span class="line">        return this.names;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到<code>set()</code>方法内部创建了一个不可变<code>List</code>，这个<code>List</code>包含的对象也是不可变对象<code>String</code>，因此，整个<code>List&lt;String&gt;</code>对象都是不可变的，因此读写均无需同步。</p>
<p>对于读写的操作的同步问题</p>
<p>其实只需要多加思考如何保证写的操作是“阶段性”的，那么读就很容易保持阶段性（同步）。</p>
<h4 id="总结多线程"><a href="#总结多线程" class="headerlink" title="总结多线程"></a><strong>总结多线程</strong></h4><p>深入理解多线程还需理解变量在栈上的存储方式，基本类型和引用类型的存储方式也不同。</p>
<p>什么时候需要考虑多线程问题？</p>
<ol>
<li>并发高的场景</li>
<li>修改线程共享变量（对象变量等）的时候</li>
</ol>
<p>为什么需要多线程？</p>
<p>每个任务分别做一点，和任务交替完成，总和不是一样的吗？</p>
<p>是的，但是前提是这写些个任务之间是可以“相加”的关系，前后结果没有太大联系。</p>
<p>但如果前一个任务和后一个任务中，<strong>有一部分成果是一致的呢？基于某一个相同的结果呢？</strong></p>
<p>&#x3D;&#x3D;那多线程带来的效率就是幂级的提升&#x3D;&#x3D;</p>
<h3 id="synchronized-方法"><a href="#synchronized-方法" class="headerlink" title="synchronized 方法"></a>synchronized 方法</h3><p>在业务逻辑中，如果自由的自定义 <code>synchronized</code> 代码块，会显得代码逻辑混乱。</p>
<p>因此，常常将同步的行为整体封装为一个类，如计数器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">            count += n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dec</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">            count -= n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该计数器的加减操作以自身 this 实例为锁，支持同时创建多个实例，每个实例内部维护各自的 COUNT 不因为线程而错乱。</p>
<p>如果一个类被设计为允许 多线程 正确访问，我们就说这个类是<strong>线程安全</strong>的。</p>
<p>还有一些不变类，例如<code>String</code>，<code>Integer</code>，<code>LocalDate</code>，它们的所有成员变量都是<code>final</code>，多线程同时访问时只能读不能写，这些不变类也是线程安全的。</p>
<p>最后，类似<code>Math</code>这些只提供静态方法，没有成员变量的类，也是线程安全的。</p>
<p>事实上大部分情况下，大部分类，例如<code>ArrayList</code>，都是非线程安全的类，我们不能在多线程中安全的使用它们。</p>
<p><strong>即使是上升为 List 引用，也是线程非安全的，因为内部的作用域还是 ArrayList 本身</strong></p>
<blockquote>
<p>只能访问，不能插入和修改元素，因为 length 和 元素内存值 会不一致。</p>
</blockquote>
<p>&#x3D;&#x3D;没有特殊说明时，一个类默认是非线程安全的。&#x3D;&#x3D;</p>
<blockquote>
<p>因为内置线程安全会影响性能，应交由开发者自由控制。</p>
</blockquote>
<p><strong>synchronized 方法修饰符</strong></p>
<p>当锁的对象是 this 实例时，以下两种写法等价。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123; <span class="comment">// 锁住this</span></span><br><span class="line">        count += n;</span><br><span class="line">    &#125; <span class="comment">// 解锁</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> n)</span> &#123; <span class="comment">// 锁住this</span></span><br><span class="line">    count += n;</span><br><span class="line">&#125; <span class="comment">// 解锁</span></span><br></pre></td></tr></table></figure>

<p><strong>static 方法加锁</strong></p>
<p>由于 static 方法没有 this 实例，因此其锁住的是一个类的 Class 实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(Counter.class) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>Java的线程锁是可重入的锁。</p>
<p><strong>可重入锁</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            dec(-n);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            count += n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">dec</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        count += n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码先执行 add，然后在 add 内部再执行 dec，可以看到两个方法都是以 this 为锁对象的。</p>
<p><strong>像这种同一把锁可以允许同一个线程多次获取的情况，就是可重入锁。</strong></p>
<p><strong>如果不同线程获取不同锁呢？</strong></p>
<p>会造成 <strong>死锁</strong> 发生。</p>
<p>死锁通俗来说，就是这把锁无法被再次正常使用了，获取不到也释放不了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> m)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(lockA) &#123; <span class="comment">// 获得lockA的锁</span></span><br><span class="line">        <span class="built_in">this</span>.value += m;</span><br><span class="line">        <span class="keyword">synchronized</span>(lockB) &#123; <span class="comment">// 获得lockB的锁</span></span><br><span class="line">            <span class="built_in">this</span>.another += m;</span><br><span class="line">        &#125; <span class="comment">// 释放lockB的锁</span></span><br><span class="line">    &#125; <span class="comment">// 释放lockA的锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dec</span><span class="params">(<span class="type">int</span> m)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(lockB) &#123; <span class="comment">// 获得lockB的锁</span></span><br><span class="line">        <span class="built_in">this</span>.another -= m;</span><br><span class="line">        <span class="keyword">synchronized</span>(lockA) &#123; <span class="comment">// 获得lockA的锁</span></span><br><span class="line">            <span class="built_in">this</span>.value -= m;</span><br><span class="line">        &#125; <span class="comment">// 释放lockA的锁</span></span><br><span class="line">    &#125; <span class="comment">// 释放lockB的锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设同时有两个线程，分别执行 add 和 dec 方法，首先都获取到了 lockA 和 lockB，就会出现这样一个情况：</p>
<ul>
<li>线程1：准备获得<code>lockB</code>，失败，等待中；</li>
<li>线程2：准备获得<code>lockA</code>，失败，等待中。</li>
</ul>
<p>两个线程都因为想要获取对方的锁，而无限等待，造成死锁。</p>
<p><strong>死锁发生后，没有任何机制能解除死锁，只能强制结束JVM进程。</strong><br>&#x3D;&#x3D;如何避免死锁&#x3D;&#x3D;</p>
<p>答案：只要保证获取锁的顺序一致。</p>
<p>所有线程都遵循这个顺序同步，只要存在线程获取到锁开始了，其他线程就必须等待，不允许步骤交叉进行。</p>
<p>将 dec 方法改为如下代码，即可避免死锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dec</span><span class="params">(<span class="type">int</span> m)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(lockA) &#123; <span class="comment">// 获得lockA的锁</span></span><br><span class="line">        <span class="built_in">this</span>.value -= m;</span><br><span class="line">        <span class="keyword">synchronized</span>(lockB) &#123; <span class="comment">// 获得lockB的锁</span></span><br><span class="line">            <span class="built_in">this</span>.another -= m;</span><br><span class="line">        &#125; <span class="comment">// 释放lockB的锁</span></span><br><span class="line">    &#125; <span class="comment">// 释放lockA的锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，大部分情况下的业务逻辑都比这个复杂，可能这个服务和另一个服务交叉获取了锁，无法被明显的发现而造成死锁。</p>
<p>这时候可以借助第三方工具，如 redis，给“锁”设置一个过期时间，超出过期时间后就自动释放。</p>
<h3 id="wait和notify"><a href="#wait和notify" class="headerlink" title="wait和notify"></a>wait和notify</h3><p>synchronized 解决了多线程竞争问题，但是没有解决协调问题。</p>
<p>竞争：多个线程争夺执行权</p>
<p>协调：多个线程之间配合交换执行权</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TaskQueue</span> &#123;</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">addTask</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.queue.add(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title function_">getTask</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码看上去没有问题：<code>getTask()</code>内部先判断队列是否为空，如果为空，就循环等待，直到另一个线程往队列中放入了一个任务，<code>while()</code>循环退出，就可以返回队列的元素了。</p>
<p>但实际上<code>while()</code>循环永远不会退出。因为线程在执行<code>while()</code>循环时，已经在<code>getTask()</code>入口获取了<code>this</code>锁，其他线程根本无法调用<code>addTask()</code>，因为<code>addTask()</code>执行条件也是获取<code>this</code>锁。</p>
<p>在队列为空的时候 getTask 获取了锁并进入了死循环，导致永远无法 addTask，造成了逻辑死锁。</p>
<p><strong>正确的逻辑</strong>：一个线程可以调用<code>getTask()</code>从队列中获取任务。如果队列为空，则该线程应该等待，直到其他线程往队列中添加了任务之后被唤醒。</p>
<p><strong>借助 wait 和 notify 改造代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TaskQueue</span> &#123;</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">addTask</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.queue.add(s);</span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title function_">getTask</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">            <span class="built_in">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当队列为空时，该线程调用 wait 方法等待。</p>
<p><strong>wait 期间会<em>释放</em>线程获得的锁，<code>wait()</code>方法返回后，线程又会重新试图获得锁。</strong></p>
<p><code>wait()</code>方法必须在当前获取的锁对象上调用，这里获取的是<code>this</code>锁，因此调用<code>this.wait()</code>。</p>
<p><strong>notifyAll 和 notify</strong></p>
<p>内部调用了<code>this.notifyAll()</code>而不是<code>this.notify()</code>，使用<code>notifyAll()</code>将唤醒所有当前正在<code>this</code>锁等待的线程，而<code>notify()</code>只会唤醒其中一个（具体哪个依赖操作系统，有一定的随机性）。</p>
<p>通常来说，<code>notifyAll()</code>更安全。有些时候，如果我们的代码逻辑考虑不周，用<code>notify()</code>会导致只唤醒了一个线程，而其他线程可能永远等待下去醒不过来了。</p>
<p><strong>注意：</strong></p>
<p>在<code>while()</code>循环中调用<code>wait()</code>，而不是<code>if</code>语句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title function_">getTask</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (queue.isEmpty()) &#123;</span><br><span class="line">        <span class="built_in">this</span>.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述的写法是错误的，因为可能会有多个线程同时 getTask，而没有获取到锁的线程，会再次进入 wait，如果这里是 if 的话，当线程被唤醒后不会继续判断，而是继续往下执行。</p>
<h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a><strong>ReentrantLock</strong></h3><p>Java 5开始，引入了 <code>java.util.concurrent</code> 并发工具包。</p>
<p>它提供了大量更高级的并发功能，能大大简化多线程程序的编写。</p>
<p>虽然 Java 可以直接用<code>synchronized</code>关键字加锁，但这种锁有很大的缺点。</p>
<ol>
<li>使用起来不方便，需要嵌套代码，非常“重量级”</li>
<li>获取锁失败时必须一直等待，没有额外的尝试，等待超时机制。</li>
</ol>
<p><code>java.util.concurrent.locks</code> 包提供的 <code>ReentrantLock</code> 可以用于替代 <code>synchronized</code> 加锁，也是一把可重入锁。</p>
<p>分别给出 synchronized 和 ReentrantLock 加锁代码：</p>
<p><strong>synchronized</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">            count += n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ReentrantLock</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            count += n;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为确保锁住是 this 实例，将 ReentrantLock 声明为对象属性。</p>
<p><strong>对比</strong></p>
<p>因为<code>synchronized</code>是Java语言层面提供的语法，所以我们不需要考虑异常。</p>
<p>而<code>ReentrantLock</code>是Java代码实现的锁，我们就必须先手动获取锁，然后在确保无论是否发生异常，都要在<code>finally</code>中正确释放锁。</p>
<p><strong>尝试机制</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 尝试获取锁，最多等待 1 秒</span></span><br><span class="line"><span class="keyword">if</span> (lock.tryLock(<span class="number">1</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 tryLock 尝试获取锁并设置尝试的时间，返回一个 boolean 值。</p>
<p>如果超时返回 false，可以进行一些额外的操作，而不是一直等待下去。</p>
<h3 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h3><p>synchronized 具有 wait 和 notify 功能，ReentrantLock 该如何呢？</p>
<p>同样提供了 Condition 类，可以使用<code>Condition</code>对象来实现<code>wait</code>和<code>notify</code>的功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TaskQueue</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addTask</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            queue.add(s);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getTask</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> queue.remove();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用方式和 wait 和 notify 类似。</p>
<p>注意：引用的<code>Condition</code>对象必须从<code>Lock</code>实例的<code>newCondition()</code>返回，这样才能正确协调获取这同一把锁的线程。</p>
<p><code>Condition</code>提供的<code>await()</code>、<code>signal()</code>、<code>signalAll()</code>原理和<code>synchronized</code>锁对象的<code>wait()</code>、<code>notify()</code>、<code>notifyAll()</code>是一致的，并且其行为也是一样的：</p>
<ul>
<li><code>await()</code>会释放当前锁，进入等待状态；</li>
<li><code>signal()</code>会唤醒某个等待线程；</li>
<li><code>signalAll()</code>会唤醒所有等待线程；</li>
<li>唤醒线程从<code>await()</code>返回后需要重新获得锁。</li>
</ul>
<p>此外，和<code>tryLock()</code>类似，<code>await()</code>可以在等待指定时间后，如果还没有被其他线程通过<code>signal()</code>或<code>signalAll()</code>唤醒，可以自己醒来：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (condition.await(1, TimeUnit.SECOND)) &#123;</span><br><span class="line">    // 被其他线程唤醒</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // 指定时间内没有被其他线程唤醒</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a>ReadWriteLock</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] counts = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inc</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            counts[index] += <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] get() &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Arrays.copyOf(counts, counts.length);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ReentrantLock 保证了某一段操作同时只有一个线程在执行，但是对于不影响内存的操作：“读”，难道也只能同时允许一个线程进入吗？？</p>
<p>但是如果不加锁，又会出现数据不一致的情况。</p>
<p>实际上我们想要的是：允许多个线程同时读，但只要有一个线程在写，其他线程就必须等待：</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">读</th>
<th align="left">写</th>
</tr>
</thead>
<tbody><tr>
<td align="left">读</td>
<td align="left">允许</td>
<td align="left">不允许</td>
</tr>
<tr>
<td align="left">写</td>
<td align="left">不允许</td>
<td align="left">不允许</td>
</tr>
</tbody></table>
<p>使用<code>ReadWriteLock</code>可以解决这个问题，它保证：</p>
<ul>
<li>只允许一个线程写入（其他线程既不能写入也不能读取）；</li>
<li>没有写入时，多个线程允许同时读（提高性能）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReadWriteLock</span> <span class="variable">rwlock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="comment">// 获取读锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">rlock</span> <span class="operator">=</span> rwlock.readLock();</span><br><span class="line">    <span class="comment">// 获取写锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">wlock</span> <span class="operator">=</span> rwlock.writeLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] counts = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inc</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        wlock.lock(); <span class="comment">// 加写锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            counts[index] += <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            wlock.unlock(); <span class="comment">// 释放写锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] get() &#123;</span><br><span class="line">        rlock.lock(); <span class="comment">// 加读锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Arrays.copyOf(counts, counts.length);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rlock.unlock(); <span class="comment">// 释放读锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>内部应该是维护了一个状态量，同时监控读写锁的状态，满足 无写-无读 的情况才可以写</p>
</blockquote>
<p>使用<code>ReadWriteLock</code>时，适用条件是同一个数据，有大量线程读取，但仅有少数线程修改。</p>
<p>例如，一个论坛的帖子，回复可以看做写入操作，它是不频繁的，但是，浏览可以看做读取操作，是非常频繁的，这种情况就可以使用<code>ReadWriteLock</code>。</p>
<h3 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h3><p><code>ReadWriteLock</code> 仍然存在效率问题。</p>
<p>如果有线程正在读，写线程需要等待读线程释放锁后才能获取写锁，即读的过程中不允许写，这是一种悲观的读锁。</p>
<p>悲观：读的过程中一定会有其他线程执行写操作，为确保一致性应拒绝。</p>
<p>而 StampedLock 是一种乐观锁，允许在读的同时进行写；但是这样会造成数据不一致，需要额外编写代码维护一致性。</p>
<p>乐观：读的过程不会被写入，允许写操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">StampedLock</span> <span class="variable">stampedLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StampedLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">(<span class="type">double</span> deltaX, <span class="type">double</span> deltaY)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> stampedLock.writeLock(); <span class="comment">// 获取写锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            x += deltaX;</span><br><span class="line">            y += deltaY;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            stampedLock.unlockWrite(stamp); <span class="comment">// 释放写锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">distanceFromOrigin</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> stampedLock.tryOptimisticRead(); <span class="comment">// 获得一个乐观读锁</span></span><br><span class="line">        <span class="comment">// 注意下面两行代码不是原子操作</span></span><br><span class="line">        <span class="comment">// 假设x,y = (100,200)</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">currentX</span> <span class="operator">=</span> x;</span><br><span class="line">        <span class="comment">// 此处已读取到x=100，但x,y可能被写线程修改为(300,400)</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">currentY</span> <span class="operator">=</span> y;</span><br><span class="line">        <span class="comment">// 此处已读取到y，如果没有写入，读取是正确的(100,200)</span></span><br><span class="line">        <span class="comment">// 如果有写入，读取是错误的(100,400)</span></span><br><span class="line">        <span class="keyword">if</span> (!stampedLock.validate(stamp)) &#123; <span class="comment">// 检查乐观读锁后是否有其他写锁发生</span></span><br><span class="line">            stamp = stampedLock.readLock(); <span class="comment">// 获取一个悲观读锁</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                currentX = x;</span><br><span class="line">                currentY = y;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                stampedLock.unlockRead(stamp); <span class="comment">// 释放悲观读锁</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.sqrt(currentX * currentX + currentY * currentY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给乐观读的操作加一个 validate 确保数据一致性，如果有其他线程写入，则获取悲观读锁重新读，保证一致性。</p>
<h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><p>Semaphore：信号量。</p>
<p>前面学习各种锁的实现。</p>
<p>本质上锁的目的是保护一种受限资源，保证同一时刻只有一个线程能访问（ReentrantLock），或者只有一个线程能写入（ReadWriteLock）。</p>
<p>还有一种受限资源，目的是控制一种资源访问量，可能是不存在并发问题的只读操作。</p>
<p>例如，一个服务器同时只能允许 10 个人进入。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccessLimitControl</span> &#123;</span><br><span class="line">    <span class="comment">// 任意时刻仅允许最多3个线程获取许可:</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">access</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 如果超过了许可数量,其他线程将在此等待:</span></span><br><span class="line">        semaphore.acquire();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">            <span class="keyword">return</span> UUID.randomUUID().toString();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放资源</span></span><br><span class="line">            semaphore.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用<code>acquire()</code>可能会进入等待，直到满足条件为止。也可以使用<code>tryAcquire()</code>指定等待时间：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (semaphore.tryAcquire(3, TimeUnit.SECONDS)) &#123;</span><br><span class="line">    // 指定等待时间3秒内获取到许可:</span><br><span class="line">    try &#123;</span><br><span class="line">        // TODO:</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        semaphore.release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要对某一受限资源进行限流访问，可以使用<code>Semaphore</code>，保证同一时间最多N个线程访问受限资源。</p>
<blockquote>
<p>线程容量和QBS区别</p>
</blockquote>
<h3 id="Concurrent集合"><a href="#Concurrent集合" class="headerlink" title="Concurrent集合"></a>Concurrent集合</h3><p>在前面通过 ReentrantLock 和 Condition 实现了一个阻塞的任务队列 BlockingQueue。</p>
<p><code>BlockingQueue</code>的意思就是说，当一个线程调用这个<code>getTask()</code>方法时，该方法内部可能会让线程变成等待状态，直到队列条件满足不为空，线程被唤醒后，<code>getTask()</code>方法才会返回。</p>
<p>除了<code>BlockingQueue</code>外，针对<code>List</code>、<code>Map</code>、<code>Set</code>、<code>Deque</code>等，<code>java.util.concurrent</code>包也提供了对应的并发集合类。我们归纳一下：</p>
<table>
<thead>
<tr>
<th align="left">interface</th>
<th align="left">non-thread-safe</th>
<th align="left">thread-safe</th>
</tr>
</thead>
<tbody><tr>
<td align="left">List</td>
<td align="left">ArrayList</td>
<td align="left">CopyOnWriteArrayList</td>
</tr>
<tr>
<td align="left">Map</td>
<td align="left">HashMap</td>
<td align="left">ConcurrentHashMap</td>
</tr>
<tr>
<td align="left">Set</td>
<td align="left">HashSet &#x2F; TreeSet</td>
<td align="left">CopyOnWriteArraySet</td>
</tr>
<tr>
<td align="left">Queue</td>
<td align="left">ArrayDeque &#x2F; LinkedList</td>
<td align="left">ArrayBlockingQueue &#x2F; LinkedBlockingQueue</td>
</tr>
<tr>
<td align="left">Deque 双向队列</td>
<td align="left">ArrayDeque &#x2F; LinkedList</td>
<td align="left">LinkedBlockingDeque</td>
</tr>
</tbody></table>
<p>使用这些并发集合与使用非线程安全的集合类完全相同。我们以<code>ConcurrentHashMap</code>为例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = new ConcurrentHashMap&lt;&gt;();</span><br><span class="line">// 在不同的线程读写:</span><br><span class="line">map.put(&quot;A&quot;, &quot;1&quot;);</span><br><span class="line">map.put(&quot;B&quot;, &quot;2&quot;);</span><br><span class="line">map.get(&quot;A&quot;, &quot;1&quot;);</span><br></pre></td></tr></table></figure>

<p>操作和原生集合使用一致，所有的同步和加锁的逻辑都在集合内部实现了</p>
<p><code>java.util.Collections</code>工具类还提供了一个<strong>旧的线程安全集合转换器</strong>，可以这么用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Map unsafeMap = new HashMap();</span><br><span class="line">Map threadSafeMap = Collections.synchronizedMap(unsafeMap);</span><br></pre></td></tr></table></figure>

<p>但是它实际上是封装了了非线程安全的<code>Map</code>，对所有读写方法都用<code>synchronized</code>加锁。</p>
<p>这样获得的线程安全集合的性能比<code>java.util.concurrent</code>集合要低很多，所以不推荐使用。</p>
<h3 id="Atomic-类"><a href="#Atomic-类" class="headerlink" title="Atomic 类"></a>Atomic 类</h3><p>Java的<code>java.util.concurrent</code>包除了提供底层锁、并发集合外，还提供了一组原子操作的封装类，它们位于<code>java.util.concurrent.atomic</code>包。</p>
<p>我们以<code>AtomicInteger</code>为例，它提供的主要操作有：</p>
<ul>
<li>增加值并返回新值：<code>int addAndGet(int delta)</code></li>
<li>加1后返回新值：<code>int incrementAndGet()</code></li>
<li>获取当前值：<code>int get()</code></li>
<li>用CAS方式设置：<code>int compareAndSet(int expect, int update)</code></li>
</ul>
<p>Atomic类是通过无锁（lock-free）的方式实现的线程安全（thread-safe）访问。它的主要原理是利用了CAS：Compare and Set。</p>
<p>如果我们自己通过CAS编写<code>incrementAndGet()</code>，它大概长这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以把这里的 var 看成对象属性，参数（局部变量）在多线程中是不共享的。</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">incrementAndGet</span><span class="params">(AtomicInteger <span class="keyword">var</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> prev, next;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prev = <span class="keyword">var</span>.get();</span><br><span class="line">        next = prev + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> ( ! <span class="keyword">var</span>.compareAndSet(prev, next));</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CAS：将比较和写入封装成原子性操作。</p>
<p>用一个以 CAS 为条件的 do~while 循环包裹 inc 和 get 操作，只要在自增后原值不变则返回值，如果期间改变了就重复操作。</p>
<p>利用<code>AtomicLong</code>可以编写一个多线程安全的全局唯一ID生成器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class IdGenerator &#123;</span><br><span class="line">    AtomicLong var = new AtomicLong(0);</span><br><span class="line"></span><br><span class="line">    public long getNextId() &#123;</span><br><span class="line">        return var.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在高度竞争的情况下，还可以使用Java 8提供的<code>LongAdder</code>和<code>LongAccumulator</code>。</p>
<p>应用：</p>
<ul>
<li>原子操作实现了无锁的线程安全；</li>
<li>适用于计数器，累加器等。</li>
</ul>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>为什么需要线程池？</p>
<p>因为创建线程需要操作系统资源（线程资源，栈空间等），频繁创建和销毁大量线程需要消耗大量时间。</p>
<p>而大多数情况下因为每个线程执行的任务不一定会同时完成，而是有一些线程提前完成。</p>
<p>那如果需要继续完成类似的任务，要继续创建新的线程来执行吗？</p>
<p>不是的，为了避免频繁创建线程浪费资源，选择创建一个线程池，当线程执行结束后，会被收回线程池，以供下次调用，就不用创建新线程了。</p>
<p><strong>创建线程池</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个固定大小的线程池:</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            es.submit(<span class="keyword">new</span> <span class="title class_">Task</span>(<span class="string">&quot;&quot;</span> + i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭线程池:</span></span><br><span class="line">        es.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>提交任务后，会异步的执行完这一些任务。</p>
<p>线程池在程序结束的时候要关闭。有三种关闭的方式：</p>
<ol>
<li>使用<code>shutdown()</code>方法关闭线程池的时候，它会等待正在执行的任务先完成，然后再关闭。</li>
<li><code>shutdownNow()</code>会立刻停止正在执行的任务，</li>
<li><code>awaitTermination()</code>则会等待指定的时间让线程池关闭。</li>
</ol>
<p>因为<code>ExecutorService</code>只是接口，Java标准库提供的几个常用实现类有：</p>
<ul>
<li>FixedThreadPool：线程数固定的线程池；</li>
<li>CachedThreadPool：线程数根据任务动态调整的线程池；</li>
<li>SingleThreadExecutor：仅单线程执行的线程池。</li>
</ul>
<p>创建这些线程池的方法都被封装到<code>Executors</code>这个工厂类中，可以选择创建需要的线程池。</p>
<p><strong>ScheduledThreadPool</strong></p>
<p>还有一种任务，需要定期反复执行，例如，每秒刷新证券价格。</p>
<p>这种任务本身固定，需要反复执行的，可以使用<code>ScheduledThreadPool</code>。</p>
<p>创建一个<code>ScheduledThreadPool</code>仍然是通过<code>Executors</code>类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ScheduledExecutorService ses = Executors.newScheduledThreadPool(4);</span><br></pre></td></tr></table></figure>

<p>我们可以提交一次性任务，它会在指定延迟后只执行一次：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 1秒后执行一次性任务:</span><br><span class="line">ses.schedule(new Task(&quot;one-time&quot;), 1, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<p>如果任务以固定的每3秒执行，我们可以这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 2秒后开始执行定时任务，每3秒执行:</span><br><span class="line">ses.scheduleAtFixedRate(new Task(&quot;fixed-rate&quot;), 2, 3, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<p>如果任务以固定的3秒为间隔执行，我们可以这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 2秒后开始执行定时任务，以3秒为间隔执行:</span><br><span class="line">ses.scheduleWithFixedDelay(new Task(&quot;fixed-delay&quot;), 2, 3, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<p>注意FixedRate和FixedDelay的区别。FixedRate是指任务总是<strong>以固定时间间隔触发</strong>，不管任务执行多长时间：</p>
<p><img src="/assets/image-20240415131920186.png" alt="image-20240415131920186"></p>
<p>而FixedDelay是指，上一次任务<strong>执行完毕</strong>后，等待固定的时间间隔，再执行下一次任务：</p>
<p><img src="/assets/image-20240415131957807.png" alt="image-20240415131957807"></p>
<p><strong>注意：</strong></p>
<ol>
<li><p>在FixedRate模式下，假设每秒触发，如果某次任务执行时间超过1秒，后续任务会不会并发执行？</p>
<p>也就是原定于每 1 秒执行一次的任务，但是上次任务还没有执行完，还会根据每秒一次执行吗？</p>
<p>答案：不会，如果任务执行时间超出了触发间隔，会在这一次任务执行完毕后，再执行下一次任务，如果下一次任务没有超出时间间隔，则保持间隔时间触发，如果又超出了，继续等待至完毕后再执行下一次，变成了顺序执行固定任务。</p>
</li>
<li><p>如果任务抛出了异常，后续任务是否继续执行？</p>
<p>答案：如果一个定时任务中任何一次执行出现了问题，这么这个 schedule 就会停止。</p>
</li>
</ol>
<p><strong>Timer</strong></p>
<p>Java标准库还提供了一个<code>java.util.Timer</code>类，这个类也可以定期执行任务，但是，一个<code>Timer</code>会对应一个<code>Thread</code>，所以，一个<code>Timer</code>只能定期执行一个任务，多个定时任务必须启动多个<code>Timer</code>，而一个<code>ScheduledThreadPool</code>就可以调度多个定时任务，所以，我们完全可以用<code>ScheduledThreadPool</code>取代旧的<code>Timer</code>。</p>
<h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><p><code>Runnable</code>接口有个问题，它的方法没有返回值。</p>
<p>如果任务需要一个返回结果，那么只能保存到变量，还要额外封装方法读取，要考虑诸多因素非常不便。</p>
<p>所以，Java标准库还提供了一个<code>Callable</code>接口，和<code>Runnable</code>接口比，它多了一个返回值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> longTimeCalculation(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并且<code>Callable</code>接口是一个泛型接口，可以返回指定类型的结果。</p>
<p>在线程池中的 submit 中，如果提供一个 Callable 接口，就会返回一个<code>Future</code>类型，一个<code>Future</code>类型的实例代表一个未来能获取结果的对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">4</span>); </span><br><span class="line"><span class="comment">// 定义任务:</span></span><br><span class="line">Callable&lt;String&gt; task = <span class="keyword">new</span> <span class="title class_">Task</span>();</span><br><span class="line"><span class="comment">// 提交任务并获得Future:</span></span><br><span class="line">Future&lt;String&gt; future = executor.submit(task);</span><br><span class="line"><span class="comment">// 从Future获取异步执行返回的结果:</span></span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> future.get(); <span class="comment">// 可能阻塞</span></span><br></pre></td></tr></table></figure>

<p>在调用<code>get()</code>时，如果异步任务已经完成，我们就直接获得结果。</p>
<p>如果异步任务还没有完成，那么<code>get()</code>会阻塞，直到任务完成后才返回结果。</p>
<p>一个<code>Future&lt;V&gt;</code>接口表示一个未来可能会返回的结果，它定义的方法有：</p>
<ul>
<li><code>get()</code>：获取结果（可能会等待）</li>
<li><code>get(long timeout, TimeUnit unit)</code>：获取结果，但只等待指定的时间；</li>
<li><code>cancel(boolean mayInterruptIfRunning)</code>：取消当前任务；</li>
<li><code>isDone()</code>：判断任务是否已完成。</li>
</ul>
<h3 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h3><p>使用<code>Future</code>获得异步执行结果时，由于 get 结果并进行处理会进行阻塞或者封装一些其他的方法，非常麻烦。</p>
<p>从Java 8开始引入了<code>CompletableFuture</code>，它针对<code>Future</code>做了改进，可以传入回调对象，当异步任务完成或者发生异常时，自动调用回调对象的回调方法。</p>
<p><strong>使用方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建异步执行任务:</span></span><br><span class="line">        CompletableFuture&lt;Double&gt; cf = CompletableFuture.supplyAsync(Main::fetchPrice);</span><br><span class="line">        <span class="comment">// 如果执行成功:</span></span><br><span class="line">        cf.thenAccept((result) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;price: &quot;</span> + result);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 如果执行异常:</span></span><br><span class="line">        cf.exceptionally((e) -&gt; &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭:</span></span><br><span class="line">        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行成功：thenAccept；执行异常：exceptionally。</p>
<p>supplyAsync接收的是一个Supplier接口函数，thenAccept, exceptionally接收一个Consumer接口函数</p>
<p>相比于 Future 优点：</p>
<ul>
<li>异步任务<strong>结束时</strong>，会自动回调某个对象的方法；</li>
<li>异步任务<strong>出错时</strong>，会自动回调某个对象的方法；</li>
<li>主线程设置好回调后，不再关心异步任务的执行。</li>
</ul>
<p><strong>CompletableFuture 还可以制作串行、并行及两者结合的异步操作</strong></p>
<p><strong>串行</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 第一个任务:</span></span><br><span class="line">        CompletableFuture&lt;String&gt; cfQuery = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> queryCode(<span class="string">&quot;中国石油&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// cfQuery成功后继续执行下一个任务:</span></span><br><span class="line">        CompletableFuture&lt;Double&gt; cfFetch = cfQuery.thenApplyAsync((code) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> fetchPrice(code);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// cfFetch成功后打印结果:</span></span><br><span class="line">        cfFetch.thenAccept((result) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;price: &quot;</span> + result);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭:</span></span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 thenApplyAsync 接着上一步异步继续执行，并且返回一个新的 CompletableFuture 对象。</p>
<p><strong>并行串行结合</strong></p>
<p>考虑如下这样的一个场景：</p>
<p>同时从新浪和网易查询证券代码，只要任意一个返回结果，就进行下一步查询价格，查询价格也同时从新浪和网易查询，只要任意一个返回结果，就完成操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 两个CompletableFuture执行异步查询:</span></span><br><span class="line">        CompletableFuture&lt;String&gt; cfQueryFromSina = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> queryCode(<span class="string">&quot;中国石油&quot;</span>, <span class="string">&quot;https://finance.sina.com.cn/code/&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        CompletableFuture&lt;String&gt; cfQueryFrom163 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> queryCode(<span class="string">&quot;中国石油&quot;</span>, <span class="string">&quot;https://money.163.com/code/&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用anyOf合并为一个新的CompletableFuture:</span></span><br><span class="line">        CompletableFuture&lt;Object&gt; cfQuery = CompletableFuture.anyOf(cfQueryFromSina, cfQueryFrom163);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 两个CompletableFuture执行异步查询:</span></span><br><span class="line">        CompletableFuture&lt;Double&gt; cfFetchFromSina = cfQuery.thenApplyAsync((code) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> fetchPrice((String) code, <span class="string">&quot;https://finance.sina.com.cn/price/&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        CompletableFuture&lt;Double&gt; cfFetchFrom163 = cfQuery.thenApplyAsync((code) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> fetchPrice((String) code, <span class="string">&quot;https://money.163.com/price/&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用anyOf合并为一个新的CompletableFuture:</span></span><br><span class="line">        CompletableFuture&lt;Object&gt; cfFetch = CompletableFuture.anyOf(cfFetchFromSina, cfFetchFrom163);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最终结果:</span></span><br><span class="line">        cfFetch.thenAccept((result) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;price: &quot;</span> + result);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭:</span></span><br><span class="line">        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述的执行流程，可以用下图解释：</p>
<p><img src="/assets/image-20240415134338932.png" alt="image-20240415134338932"></p>
<p>除了<code>anyOf()</code>可以实现“任意个<code>CompletableFuture</code>只要一个成功”，<code>allOf()</code>可以实现“所有<code>CompletableFuture</code>都必须成功”，这些组合操作可以实现非常复杂的异步流程控制。</p>
<p>最后我们注意<code>CompletableFuture</code>的命名规则：</p>
<ul>
<li><code>xxx()</code>：表示该方法将继续在已有的线程中执行；</li>
<li><code>xxxAsync()</code>：表示将异步在线程池中执行。</li>
</ul>
<p><strong>注意</strong>：不管是 thenApplyAsync 还是 anyOf, allOf 等操作对 CompletableFuture 进行整合，都会返回一个新的 CompletableFuture 对象，最终结果应基于最后一个组合对象操作。</p>
<blockquote>
<p>还有个 runAsync 方法，可以不需要返回值也能使用。</p>
</blockquote>
<h3 id="ForkJoin"><a href="#ForkJoin" class="headerlink" title="ForkJoin"></a>ForkJoin</h3><p>Java 7开始引入了一种新的Fork&#x2F;Join线程池，它可以执行一种特殊的任务：把一个大任务拆成多个小任务并行执行。</p>
<p>以大数据进行并行求和为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建2000个随机数组成的数组:</span></span><br><span class="line">        <span class="type">long</span>[] array = <span class="keyword">new</span> <span class="title class_">long</span>[<span class="number">2000</span>];</span><br><span class="line">        <span class="type">long</span> <span class="variable">expectedSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            array[i] = random();</span><br><span class="line">            expectedSum += array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Expected sum: &quot;</span> + expectedSum);</span><br><span class="line">        <span class="comment">// fork/join:</span></span><br><span class="line">        ForkJoinTask&lt;Long&gt; task = <span class="keyword">new</span> <span class="title class_">SumTask</span>(array, <span class="number">0</span>, array.length);</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> ForkJoinPool.commonPool().invoke(task);</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;Fork/join sum: &quot;</span> + result + <span class="string">&quot; in &quot;</span> + (endTime - startTime) + <span class="string">&quot; ms.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">random</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> random.nextInt(<span class="number">10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SumTask</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Long&gt; &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THRESHOLD</span> <span class="operator">=</span> <span class="number">500</span>;</span><br><span class="line">    <span class="type">long</span>[] array;</span><br><span class="line">    <span class="type">int</span> start;</span><br><span class="line">    <span class="type">int</span> end;</span><br><span class="line"></span><br><span class="line">    SumTask(<span class="type">long</span>[] array, <span class="type">int</span> start, <span class="type">int</span> end) &#123;</span><br><span class="line">        <span class="built_in">this</span>.array = array;</span><br><span class="line">        <span class="built_in">this</span>.start = start;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Long <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (end - start &lt;= THRESHOLD) &#123;</span><br><span class="line">            <span class="comment">// 如果任务足够小,直接计算:</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; end; i++) &#123;</span><br><span class="line">                sum += <span class="built_in">this</span>.array[i];</span><br><span class="line">                <span class="comment">// 故意放慢计算速度:</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 任务太大,一分为二:</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> (end + start) / <span class="number">2</span>;</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;split %d~%d ==&gt; %d~%d, %d~%d&quot;</span>, start, end, start, middle, middle, end));</span><br><span class="line">        <span class="type">SumTask</span> <span class="variable">subtask1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SumTask</span>(<span class="built_in">this</span>.array, start, middle);</span><br><span class="line">        <span class="type">SumTask</span> <span class="variable">subtask2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SumTask</span>(<span class="built_in">this</span>.array, middle, end);</span><br><span class="line">        invokeAll(subtask1, subtask2);</span><br><span class="line">        <span class="type">Long</span> <span class="variable">subresult1</span> <span class="operator">=</span> subtask1.join();</span><br><span class="line">        <span class="type">Long</span> <span class="variable">subresult2</span> <span class="operator">=</span> subtask2.join();</span><br><span class="line">        <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> subresult1 + subresult2;</span><br><span class="line">        System.out.println(<span class="string">&quot;result = &quot;</span> + subresult1 + <span class="string">&quot; + &quot;</span> + subresult2 + <span class="string">&quot; ==&gt; &quot;</span> + result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>观察上述代码的执行过程，一个大的计算任务0<del>2000首先分裂为两个小任务0</del>1000和1000<del>2000，这两个小任务仍然太大，继续分裂为更小的0</del>500，500<del>1000，1000</del>1500，1500~2000，最后，计算结果被依次合并，得到最终结果。</p>
<blockquote>
<p>该例子并不适用，因为本质是同源的，多线程最大的优势是在应用不同源。</p>
</blockquote>
<blockquote>
<p>同源：每次切换一个线程加一点数，和一次加完所有的数是一样的（也不一定，多核CPU下，当然是一个任务能占据更多核速度最快）。</p>
<p>不同源：每次切换一个线程和不同“服务”通信，所有服务并行执行。</p>
</blockquote>
<p>Fork&#x2F;Join线程池在Java标准库中就有应用。</p>
<p>Java标准库提供的<code>java.util.Arrays.parallelSort(array)</code>可以进行并行排序，它的原理就是内部通过Fork&#x2F;Join对大数组分拆进行并行排序，在多核CPU上就可以大大提高排序的速度。</p>
<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>多线程是Java实现多任务的基础。</p>
<p><strong>获取多线程id</strong></p>
<p><code>Thread</code>对象代表一个线程，我们可以在代码中调用<code>Thread.currentThread()</code>获取当前线程。</p>
<p><strong>传递状态</strong></p>
<p>通常一个任务需要多个方法完成，对象如何在多个方法中传递相同的状态？</p>
<p>定义一个对象属性？多线程共享会不一致该怎么办？</p>
<p>Java标准库提供了一个特殊的<code>ThreadLocal</code>，它可以确保每一个线程中都维护各自的一个对象属性值。</p>
<p><code>ThreadLocal</code>实例通常总是以<strong>静态字段初始化</strong>如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> ThreadLocal&lt;User&gt; threadLocalUser = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p><strong>使用方式</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加载器</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">processUser</span><span class="params">(user)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        threadLocalUser.set(user);</span><br><span class="line">        step1();</span><br><span class="line">        step2();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        threadLocalUser.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以把<code>ThreadLocal</code>看成一个全局<code>Map&lt;Thread, Object&gt;</code>：每个线程获取<code>ThreadLocal</code>变量时，总是使用<code>Thread</code>自身作为key：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">threadLocalValue</span> <span class="operator">=</span> threadLocalMap.get(Thread.currentThread());</span><br></pre></td></tr></table></figure>

<p>因此，<code>ThreadLocal</code>相当于给每个线程都开辟了一个独立的存储空间，各个线程的<code>ThreadLocal</code>关联的实例互不干扰。</p>
<p>最后，特别注意<code>ThreadLocal</code>一定要在<code>finally</code>中清除：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    threadLocalUser.set(user);</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    threadLocalUser.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是因为当前线程执行完相关代码后，很可能会被重新放入线程池中，如果<code>ThreadLocal</code>没有被清除，该线程执行其他代码时，会把上一次的状态带进去。</p>
<p>而且 ThreadLocal 可以维护的线程数是有限的，如果超出了限制，会造成内存污染，共用一个对象的情况。</p>
<p><strong>实现 AutoCloseable 接口</strong></p>
<p>为了保证能释放<code>ThreadLocal</code>关联的实例，我们可以通过<code>AutoCloseable</code>接口配合<code>try (resource) &#123;...&#125;</code>结构，让编译器自动为我们关闭。</p>
<p>例如，将用于保存当前用户名的<code>ThreadLocal</code>封装为一个<code>UserContext</code>对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserContext</span> <span class="keyword">implements</span> <span class="title class_">AutoCloseable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; ctx = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserContext</span><span class="params">(String user)</span> &#123;</span><br><span class="line">        ctx.set(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">currentUser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ctx.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        ctx.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用的时候，我们借助<code>try (resource) &#123;...&#125;</code>结构，可以这么写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try (var ctx = new UserContext(&quot;Bob&quot;)) &#123;</span><br><span class="line">    // 可任意调用UserContext.currentUser():</span><br><span class="line">    String currentUser = UserContext.currentUser();</span><br><span class="line">&#125; // 在此自动调用UserContext.close()方法释放ThreadLocal关联对象</span><br></pre></td></tr></table></figure>

<p>将 UserContext 实例对象的作用限定在 try {} 中，当离开作用域时自动回收该实例，并调用 close 方法移除 ThreadLocal 关联对象（有点像析构方法接口）。</p>
<h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><h2 id="易混概念"><a href="#易混概念" class="headerlink" title="易混概念"></a>易混概念</h2><ol>
<li>主类: 所有定义了main方法的类叫做主类，开发者常在类中定义main方法，用来调试代码</li>
<li>在基本数据类型变量声明时，不能用占用内存大的值赋给占用内存小的变量类型，如 float a &#x3D; 1.19; 1.19 默认是double型，因此该语句会编译出错; &#x3D;&#x3D;2e9&#x3D;&#x3D;科学计数，默认也是double型!!!</li>
<li>使用…声明可变长参数，如int sort(int… a);</li>
<li>命令行参数</li>
</ol>
<blockquote>
<p>各个类的main方法可以相互调用</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(String str: args) &#123;</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] strs = &#123;<span class="string">&quot;hello&quot;</span>，<span class="string">&quot;world&quot;</span>&#125;;</span><br><span class="line">        B.main(strs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>重载是&#x3D;&#x3D;多态&#x3D;&#x3D;的一种。</li>
<li>不管是继承还是实现接口，重写方法时都不可以降低方法的可见性（Visiability）</li>
</ol>
<blockquote>
<p>如：继承的public方法不能重写为protected方法，但是protected方法重写后可改为public。</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Redisson分布式锁、联锁</title>
    <url>/2024/03/29/240329/</url>
    <content><![CDATA[<h1 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h1><h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><ol>
<li>引入依赖</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.13.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>配置 RedissonClient</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedissonConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedissonClient <span class="title function_">redissonClient</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        <span class="comment">// 配置redis地址</span></span><br><span class="line">        config.useSingleServer()</span><br><span class="line">            .setAddress(<span class="string">&quot;redis://192.168.59.128:6379&quot;</span>)</span><br><span class="line">            .setPassword(<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建redisson客户端</span></span><br><span class="line">        <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>获取锁</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> RedissonClient.getLock(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">lock.tryLock();</span><br><span class="line">lock.unlock();</span><br></pre></td></tr></table></figure>

<h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><ol>
<li><p>可重入</p>
<p>将存储结构改为 Hash 类型，field 为线程标识，value 为重入次数，记录锁重入的次数并每次重入刷新有效期。</p>
<p>释放锁的时候判断是否重入次数变为0，否则-1</p>
</li>
<li><p>可重试</p>
<p>允许设置 waitTime，在等待时间范围内不断重新获取锁</p>
</li>
<li><p>超时释放</p>
<p>设立 watchdog 任务机制，只要服务还在进行就不停续约，如果服务宕机就会过期释放</p>
</li>
<li><p>联锁</p>
<p>允许使用多个 Redis 节点，必须在所有节点获取到锁才算成功，如果有一个节点宕机即使主从不一致，也无法从一个节点就获取到锁。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>每日总结</category>
      </categories>
      <tags>
        <tag>Redisson</tag>
        <tag>Watchdog</tag>
        <tag>Redis</tag>
        <tag>分布式锁</tag>
        <tag>联锁</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux，分布式锁</title>
    <url>/2024/03/28/240328/</url>
    <content><![CDATA[<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>链接文件：一个可以“通向”其他文件的文件。</p>
<p>分为 软链接 和 硬链接。</p>
<p><strong>软链接：</strong>类似 Windows 的快捷方式，不是一个实质的文件，当链接的文件被销毁后，也就失去作用了</p>
<p><strong>硬链接：</strong>直接和 另一个文件 通向 相同的内存，和链接的文件共享文件内容，这边修改了那边也会跟着变</p>
<blockquote>
<p>和 Docker 的 Volume 有点像</p>
</blockquote>
<p><strong>命令</strong>：<code>ln -s &lt;linked&gt; &lt;link&gt;</code></p>
<p>s: symbolic 符号，表示创建软链接（符号链接）</p>
<p>如 ln b.txt a.txt：创建 a 对 b 的硬链接。</p>
<p><strong>注意：</strong>硬链接不能指向目录，因为目录只是一个层级，不是文件，无法让你修改。</p>
<h3 id="vi编辑器"><a href="#vi编辑器" class="headerlink" title="vi编辑器"></a>vi编辑器</h3><p>打开方式：<code>vi &lt;file&gt;</code> </p>
<p>如果文件不存在则会创建新文件。</p>
<p>vim编辑器中分为三种状态 </p>
<ol>
<li>命令模式，按下按键不会输入字符，而是执行命令。</li>
<li>输入模式，可以插入字符</li>
<li>底线命令模式，在界面最低端，输入命令执行相应操作</li>
</ol>
<p><strong>命令模式常用</strong></p>
<ol>
<li>i、a、o，分别是在光标当前、随后、下一行进入输入模式，可以输入字符</li>
<li>u，复原操作</li>
<li>dd，删除这一行</li>
<li><code>:</code>，切换到底线命令模式</li>
</ol>
<p><strong>输入模式常用</strong></p>
<ol>
<li>ctrl + u，撤回操作</li>
</ol>
<p><strong>底线命令模式</strong></p>
<ol>
<li>q 退出</li>
<li>q！强制退出，加一个！表示强制的意思</li>
<li>w 保存</li>
<li>wq 保存退出</li>
<li>！暂时离开进入terminal查看信息</li>
<li>set nu 显示行号</li>
<li>set nonu 取消显示行号</li>
</ol>
<h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><p>在集群部署的情况下，保证某个操作只能单线程执行。</p>
<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a><strong>实现方式</strong></h3><ol>
<li>MySQL 本身的互斥锁机制（还没学）</li>
<li>Redis setnx 互斥命令</li>
<li>zookeeper 唯一有序节点</li>
</ol>
<p><strong>定义 Lock 接口</strong></p>
<ul>
<li><p><code>boolean tryLock(long timeSec)</code> 尝试获取锁，并设置过期时间，防止服务宕机造成死锁</p>
<blockquote>
<p>MySQL 断连会自动释放，zookeeper 是临时节点</p>
</blockquote>
</li>
<li><p><code>void unlock()</code></p>
</li>
</ul>
<h3 id="防止误删"><a href="#防止误删" class="headerlink" title="防止误删"></a><strong>防止误删</strong></h3><p>如果某次操作执行非常慢或者被阻塞了，导致他获取的锁被过期释放了，此时其他线程获取到了新的锁，但由于锁的 key 都是一致的，最后这个被阻塞的操作完成后会误删了其他线程的锁。</p>
<p><strong>一、给锁加上标识</strong></p>
<p>为了误删其他线程的锁，需要再释放之前，判断这把锁是否是为当前线程的锁。</p>
<p>利用 UUID + 线程id 生成不同服务器不同的标识</p>
<blockquote>
<p>如果只用id的话，由于这个id是顺序生成的，不同服务器之间会冲突。</p>
</blockquote>
<p><strong>二、原子性</strong></p>
<p>既然出现了判断，就会有数据不一致的并发问题。</p>
<p>如果因为 JVM 的 GC 垃圾回收等机制造成了阻塞，导致在判断完之后锁又过期的情况下，又会误删其他线程的锁。</p>
<p>因此，需要保证 判断 和 释放 两个操作的原子性。</p>
<p>这里采用脱离 JVM，让 Redis 执行 lua 脚本的方法。</p>
<p>实现步骤：</p>
<ol>
<li>编写 lua 脚本</li>
<li>借助 StringRedisTemplate 的 execute 方法执行脚本</li>
</ol>
<blockquote>
<p>Redis 会不会产生数据不一致的问题，在查询到标识之后被其他线程改了？多线程？</p>
</blockquote>
<p>Redis 在 5 版本之前都是单线程的，而且事务保证了原子性。</p>
]]></content>
      <categories>
        <category>每日总结</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>分布式锁</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux；锁、并发</title>
    <url>/2024/03/28/240327/</url>
    <content><![CDATA[<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><h3 id="开关机"><a href="#开关机" class="headerlink" title="开关机"></a>开关机</h3><p><code>shutdown -h &lt;time&gt;</code> </p>
<p>h: halt 停止</p>
<p>这里的 time 可以是数字（分钟），也可以是时间（时:分），还可以是 now （等时间说明？）</p>
<p><code>shutdown -r &lt;time&gt;</code></p>
<p>r: reboot 重启</p>
<p>time 同上方命令</p>
<p><code>reboot</code> ：直接重启</p>
<p><code>halt</code>、<code>poweroff</code>：关闭系统，等同于 <code>shutdown -h now</code></p>
<p><code>sync</code> ：将内存数据同步到硬盘，关机重启前应执行此命令保证数据不被丢失。</p>
<h3 id="目录管理"><a href="#目录管理" class="headerlink" title="目录管理"></a>目录管理</h3><p><strong>目录操作</strong></p>
<p><code>mkdir -p &lt;file&gt;</code> </p>
<p>p: parent 父级</p>
<p>创建目录，可以选择添加 p 参数创建多级目录</p>
<p><code>rmdir -p &lt;file&gt;</code></p>
<p>删除目录，可以选择添加 p 参数删除多级目录（目录不为空无法删除）</p>
<p><code>rm -rfi &lt;file / path&gt;</code></p>
<p>r: recursive 递归</p>
<p>f: force 强制</p>
<p>i: interactive 交互（询问是否删除）</p>
<blockquote>
<p>linux 中命令参数可以合并在一起写，所以写成了 -rfi</p>
</blockquote>
<p>删除文件或目录</p>
<p><code>pwd</code>：print working directory 打印当前目录</p>
<p><strong>列出目录内容</strong></p>
<p><code>ls -al</code> 列举目录内容</p>
<p>a: all 全部</p>
<p>l: long 长格式（详细信息：权限、属主、分组、大小、创建时间、名称）</p>
<p><code>ll</code> 列出目录内详细，等同于 <code>ls -l</code></p>
<h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><p><strong>权限管理</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-rwxr-xr-x. 2 root root   24 3月   7 11:13 nacos.txt</span><br><span class="line">drwxr-xr-x. 3 root root   59 3月  18 13:44 nginx</span><br></pre></td></tr></table></figure>

<p><code>- rwx rwx rwx</code> 可以分为 4 组</p>
<p>第一组：文件类型，- 表示这是一个可执行文件，d 表示目录，l 表示链接（软 &#x2F; 硬）</p>
<p>第二、三、四组：当前用户、所属用户、分组用户可操作的文件权限</p>
<p>第一个root：创建用户</p>
<p>第二个root：分组</p>
<p>r：读，w：写，x：执行 execute</p>
<p><code>chgrp &lt;group&gt; &lt;file&gt;</code> 修改文件分组</p>
<p><code>chmod (rwx)(rwx)(rwx) &lt;file&gt;</code> 修改文件对应当前、属主、分组的可操作权限</p>
<p>这里的 rwx 分别用对应数字的累加来声明</p>
<p>r：4，w：2，x：1</p>
<blockquote>
<p>为什么 r 是 4 ？</p>
<p>因为如果是 3，会出现组合重复，r: 3 等同 wx: 3</p>
</blockquote>
<p>如 <code>chmod 775 file</code> </p>
<p>表示当前用户权限：r+w+x &#x3D; 7</p>
<p>表示创建用户权限：r+w+x &#x3D; 7</p>
<p>表示分组用户权限：r+w+0 &#x3D; 5</p>
<p><strong>文件查看</strong></p>
<p><code>cat</code> 从上往下打印文件内容，<code>tac</code> 倒序打印，cat反过来</p>
<p><code>less、more</code> 分页显示文件内容</p>
<p>less 区别于 more，less 可以上下翻页 “PageUp”，“PagesDown” 按键和上下单行移动 “ArrowUp”，“ArrowDown” 按键。</p>
<p>操作：</p>
<ul>
<li>空格翻页</li>
<li>回车显示下一行</li>
<li>输入 &#x2F;xxx，查询 xxx ，<strong>less 才能查</strong>，n 向上搜索，N 向下搜索</li>
<li>q 退出分页查看</li>
</ul>
<p><code>head / tail -n &lt;line&gt; &lt;file&gt;</code> 分别显示头尾 n 行</p>
<p><code>nl &lt;file&gt;</code> 输出文件内容，并标注行号</p>
<h2 id="对并发的理解"><a href="#对并发的理解" class="headerlink" title="对并发的理解"></a>对并发的理解</h2><p>什么时候需要考虑并发：</p>
<ol>
<li>涉及数据一致性</li>
<li>涉及数据库操作</li>
</ol>
<p>并发在哪里产生问题：</p>
<ol>
<li>“判断”：只要同时存在多个线程绕过这个限制，就会出现并发问题</li>
</ol>
<p>如何处理并发问题：“锁”</p>
<ol>
<li>悲观锁：全程阻塞，整个过程保证同时只有一个线程。</li>
<li>乐观锁：阻塞不符合条件的线程。</li>
<li>id锁：保证同时只有一个线程访问这个id。</li>
</ol>
<h2 id="订单超卖"><a href="#订单超卖" class="headerlink" title="订单超卖"></a>订单超卖</h2><p>场景描述：一共只有 100 份，却卖出了 110 份，这就是超卖。</p>
<p>造成原因：高并发，一份的空隙被 10 个用户绕了过去，同时进行了操作。</p>
<p>解决办法：</p>
<ol>
<li>全程加锁，限制同时只能有一份被一个用户操作，但是<strong>效率太低</strong>。</li>
<li>乐观锁，只要没有超出限制，就允许同时操作，保证了效率和业务正常。</li>
</ol>
]]></content>
      <categories>
        <category>每日总结</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>并发</tag>
        <tag>锁</tag>
        <tag>订单超卖</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux学习第一天</title>
    <url>/2024/03/27/Linux-1/</url>
    <content><![CDATA[<h2 id="开关机"><a href="#开关机" class="headerlink" title="开关机"></a>开关机</h2><p><code>shutdown -h &lt;time&gt;</code> </p>
<p>h: halt 停止</p>
<p>这里的 time 可以是数字（分钟），也可以是时间（时:分），还可以是 now （等时间说明？）</p>
<p><code>shutdown -r &lt;time&gt;</code></p>
<p>r: reboot 重启</p>
<p>time 同上方命令</p>
<p><code>reboot</code> ：直接重启</p>
<p><code>halt</code>、<code>poweroff</code>：关闭系统，等同于 <code>shutdown -h now</code></p>
<p><code>sync</code> ：将内存数据同步到硬盘，关机重启前应执行此命令保证数据不被丢失。</p>
<h2 id="目录管理"><a href="#目录管理" class="headerlink" title="目录管理"></a>目录管理</h2><h3 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a><strong>目录操作</strong></h3><p><code>mkdir -p &lt;file&gt;</code> </p>
<p>p: parent 父级</p>
<p>创建目录，可以选择添加 p 参数创建多级目录</p>
<p><code>rmdir -p &lt;file&gt;</code></p>
<p>删除目录，可以选择添加 p 参数删除多级目录（目录不为空无法删除）</p>
<p><code>rm -rfi &lt;file / path&gt;</code></p>
<p>r: recursive 递归</p>
<p>f: force 强制</p>
<p>i: interactive 交互（询问是否删除）</p>
<blockquote>
<p>linux 中命令参数可以合并在一起写，所以写成了 -rfi</p>
</blockquote>
<p>删除文件或目录</p>
<p><code>pwd</code>：print working directory 打印当前目录</p>
<h3 id="列出目录内容"><a href="#列出目录内容" class="headerlink" title="列出目录内容"></a><strong>列出目录内容</strong></h3><p><code>ls -al</code> 列举目录内容</p>
<p>a: all 全部</p>
<p>l: long 长格式（详细信息：权限、属主、分组、大小、创建时间、名称）</p>
<p><code>ll</code> 列出目录内详细，等同于 <code>ls -l</code></p>
<h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><h3 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a><strong>权限管理</strong></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-rwxr-xr-x. 2 root root   24 3月   7 11:13 nacos.txt</span><br><span class="line">drwxr-xr-x. 3 root root   59 3月  18 13:44 nginx</span><br></pre></td></tr></table></figure>

<p><code>- rwx rwx rwx</code> 可以分为 4 组</p>
<p>第一组：文件类型，- 表示这是一个可执行文件，d 表示目录，l 表示链接（软 &#x2F; 硬）</p>
<p>第二、三、四组：当前用户、所属用户、分组用户可操作的文件权限</p>
<p>第一个root：创建用户</p>
<p>第二个root：分组</p>
<p>r：读，w：写，x：执行 execute</p>
<p><code>chgrp &lt;group&gt; &lt;file&gt;</code> 修改文件分组</p>
<p><code>chmod (rwx)(rwx)(rwx) &lt;file&gt;</code> 修改文件对应当前、属主、分组的可操作权限</p>
<p>这里的 rwx 分别用对应数字的累加来声明</p>
<p>r：4，w：2，x：1</p>
<blockquote>
<p>为什么 r 是 4 ？</p>
<p>因为如果是 3，会出现组合重复，r: 3 等同 wx: 3</p>
</blockquote>
<p>如 <code>chmod 775 file</code> </p>
<p>表示当前用户权限：r+w+x &#x3D; 7</p>
<p>表示创建用户权限：r+w+x &#x3D; 7</p>
<p>表示分组用户权限：r+w+0 &#x3D; 5</p>
<h3 id="文件查看"><a href="#文件查看" class="headerlink" title="文件查看"></a><strong>文件查看</strong></h3><p><code>cat</code> 从上往下打印文件内容，<code>tac</code> 倒序打印，cat反过来</p>
<p><code>less、more</code> 分页显示文件内容</p>
<p>less 区别于 more，less 可以上下翻页 “PageUp”，“PagesDown” 按键和上下单行移动 “ArrowUp”，“ArrowDown” 按键。</p>
<p>操作：</p>
<ul>
<li>空格翻页</li>
<li>回车显示下一行</li>
<li>输入 &#x2F;xxx，查询 xxx ，<strong>less 才能查</strong>，n 向上搜索，N 向下搜索</li>
<li>q 退出分页查看</li>
</ul>
<p><code>head / tail -n &lt;line&gt; &lt;file&gt;</code> 分别显示头尾 n 行</p>
<p><code>nl &lt;file&gt;</code> 输出文件内容，并标注行号</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 文件状态梳理</title>
    <url>/2024/03/25/Git-1/</url>
    <content><![CDATA[<h2 id="文件状态"><a href="#文件状态" class="headerlink" title="文件状态"></a>文件状态</h2><p><img src="/assets/image-20240325104013093.png" alt="Git文件的四种状态"></p>
<p>下面以新增 README.md 文件为例</p>
<h3 id="Untracked"><a href="#Untracked" class="headerlink" title="Untracked"></a><strong>Untracked</strong></h3><p>未被 Git 跟踪的文件状态</p>
<ol>
<li>新创建</li>
<li>从其他地方移动过来（复制 &#x2F; 剪切等）</li>
</ol>
<p><img src="/assets/image-20240325104023093.png" alt="image-20240325104023093"></p>
<h3 id="Staged"><a href="#Staged" class="headerlink" title="Staged"></a><strong>Staged</strong></h3><p>使用 <code>git add &lt;file&gt;</code> 命令将文件加入暂存区，转化为 <code>Staged</code> 状态</p>
<p><img src="/assets/image-20240325104341887.png" alt="image-20240325104341887"></p>
<p>使用 <code>git rm --cached &lt;file&gt;</code> 可以将文件移出缓存区，重新变为 <code>Untracked</code> 状态</p>
<p><img src="/assets/image-20240325104726863.png" alt="image-20240325104726863"></p>
<p><strong>文件当前内容</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">123</span><br></pre></td></tr></table></figure>



<h3 id="Modified"><a href="#Modified" class="headerlink" title="Modified"></a><strong>Modified</strong></h3><p>对 <code>Staged</code> 已经存入暂存区的文件进行修改，转化为 <code>Modified</code> 状态</p>
<p><strong>文件修改后</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">123</span><br><span class="line">restore 丢弃的内容</span><br></pre></td></tr></table></figure>

<p><img src="/assets/image-20240325105331466.png" alt="image-20240325105331466"></p>
<p>可以看到和 <code>Untracked</code> 状态一样，被 Git 标红了</p>
<p>意味着此时暂存区内该文件的内容还是 <code>123</code>，需要重新使用 <code>git add &lt;file&gt;</code> 命令将本次修改保存到 Git 中（更新 Git 的 diff 内容）。</p>
<p><strong>后续命令</strong></p>
<ul>
<li><code>git restore &lt;file&gt;</code>，丢弃本次修改，恢复到当前暂存区存取的内容（最后一次被修改之前的状态）</li>
<li><code>git checkout &lt;file&gt;</code> 等价于 restore</li>
</ul>
<p><strong>文件 restore 后</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">123</span><br></pre></td></tr></table></figure>

<p><strong>应用场景</strong></p>
<p>操作涉及 工作区 和 暂存区 两个区域。</p>
<p>当工作到某个重要节点，你需要在这个节点上进行扩展，但是你又不确定这个扩展是否可行</p>
<p>这时候就可以 “stage” 这个节点，然后继续修改，如果不可行就通过 <code>git restore &lt;file&gt;</code> 回到这个节点，丢弃掉所有修改内容。</p>
<blockquote>
<p>当然如果这个节点是重要且确定的，你可以直接 <code>git add &lt;file&gt;</code> &#x3D;&gt; <code>git commit</code> 将其提交到本次仓库中</p>
</blockquote>
<p><strong>提问</strong></p>
<ol>
<li>如果我 “stage” 了这次新的修改，原先的节点还能找到吗 :x:</li>
</ol>
<h3 id="UnModified"><a href="#UnModified" class="headerlink" title="UnModified"></a>UnModified</h3><p>将 <code>Staged</code> 状态的文件（暂存区的文件）通过 <code>git commit</code> 提交到本次仓库中，转化为 <code>Unmodified</code> 状态。</p>
<p>为了后续追踪文件内容，添加了一行 commit 标志</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">123</span><br><span class="line"></span><br><span class="line">第一次commit</span><br></pre></td></tr></table></figure>

<p><img src="/assets/image-20240325114403701.png" alt="image-20240325114403701"></p>
<p>commit 提交后，该文件就加入本地仓库了，并输出了本次 commit 的 branch（master）和 refs（9db5ee9）。</p>
<p>接下来继续对文件进行修改（工作区）、保存（暂存区）、提交（本地仓库），完成一整个流程。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">123</span><br><span class="line"></span><br><span class="line">第一次commit</span><br><span class="line"></span><br><span class="line">修改内容</span><br></pre></td></tr></table></figure>

<p><img src="/assets/image-20240325115211160.png" alt="image-20240325115211160"></p>
<h3 id="状态流程"><a href="#状态流程" class="headerlink" title="状态流程"></a><strong>状态流程</strong></h3><p><strong>新加入的文件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 首次加入</span><br><span class="line">Untracked =(add)=&gt; Staged =(self update)=&gt; Modified =(commit)=&gt; UnModified</span><br><span class="line">// 追踪更改</span><br><span class="line">=(self update)=&gt; Modified =(add)=&gt; Staged =(commit)=&gt; UnModified</span><br></pre></td></tr></table></figure>

<p><strong>已追踪的文件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 追踪更改</span><br><span class="line">=(self update)=&gt; Modified =(add)=&gt; Staged =(commit)=&gt; UnModified</span><br></pre></td></tr></table></figure>

<p>注意：未被追踪的文件，无论怎么修改都不会被 Git 管理为 Modified 文件</p>
<p><img src="/assets/image-20240326000827982.png" alt="image-20240326000827982"></p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
</search>

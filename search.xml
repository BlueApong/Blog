<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ThreadLocal解析</title>
    <url>/2024/06/30/ThreadLocal%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="ThreadLocal-——-线程变量"><a href="#ThreadLocal-——-线程变量" class="headerlink" title="ThreadLocal —— 线程变量"></a>ThreadLocal —— 线程变量</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>创建一个在不同线程之间读写相互隔离的变量。</p>
<p>大白话：同一个变量，在不同线程的环境下，访问和修改它的值都互不影响，不同线程允许拥有不同的值。</p>
<span id="more"></span>

<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>声明为一个静态的类属性。</p>
<p>以存储 User 信息为例：</p>
<p>提供方法</p>
<ul>
<li>saveUser 设置 User 信息</li>
<li>getUser 获取 User 信息</li>
<li>removeUser 移除 User 信息</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserHolder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;UserDTO&gt; tl = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">saveUser</span><span class="params">(UserDTO user)</span>&#123;</span><br><span class="line">        tl.set(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UserDTO <span class="title function_">getUser</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tl.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">removeUser</span><span class="params">()</span>&#123;</span><br><span class="line">        tl.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>ThreadLocal 对象内部的数据是由 ThreadLocalMap <strong>维护</strong>的，</p>
<p>而每个 Thread 又有各自的 ThreadLocalMap。</p>
<p>因此“表面上”线程共享的类属性变量，实际上在每个 Thread 中读写的对象并不是同一个。</p>
<p>假设这有两个线程 A，B 操作一个线程变量 tl。</p>
<p>在 A 线程中 tl 的值是 1。</p>
<p>如果 B 线程想要修改它的值，就需要先找到<strong>当前 Thread</strong> 的 ThreadLocalMap，然后修改 map 中 tl 这个 key 所匹配的 value。</p>
<h3 id="什么叫做维护呢？"><a href="#什么叫做维护呢？" class="headerlink" title="什么叫做维护呢？"></a>什么叫做维护呢？</h3><p>这里以上述的 tl 表示 ThreadLocal 实例，并贴出该类的源码。</p>
<h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p>当 tl 进行 set 操作时，以自身实例作为 key，存储对象作为 value，存入了 ThreadLocalMap 中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><p>同理进行 get 操作时，以自身实例作为 key，索引 ThreadLocalMap 中的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h4><p>remove 操作也是如此，以自身实例为 key，移除这一对键值对。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">m</span> <span class="operator">=</span> getMap(Thread.currentThread());</span><br><span class="line">    <span class="keyword">if</span> (m != <span class="literal">null</span>) &#123;</span><br><span class="line">        m.remove(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h3><p>并不是 ThreadLocal 为每个线程提供了不同的变量副本，而是其借助不同线程中的 ThreadLocalMap 存储了当前线程的变量副本。</p>
<h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p><strong>内存泄漏：</strong>指程序中已分配的内存未能成功释放，导致可用内存逐渐减少的现象。</p>
<p>为什么线程变量通常声明为一个静态类属性，而不是局部变量呢？</p>
<p>因为 <strong>垃圾回收</strong> 机制。</p>
<p>如果将 ThreadLocal 实例声明为一个局部变量，在作用域结束时，会回收掉这个变量引用，导致 ThreadLocalMap 中存储了一个 key 为 null 的键值对，无法进行访问，也不能主动销毁。</p>
<p>从而发生内存泄漏。</p>
<p><strong>疑问:question:</strong></p>
<p>虽然引用被回收了，但是内存空间不会被释放吧，key 不至于为 null 吧？因为 map 的 key 保存了这个实例？</p>
<p><strong>答：</strong></p>
<p> Map 的 keys 保留了这个实例对象，所以这个 key 并不是 null；</p>
<p>只不过丢失了对这个 key 的引用，无法主动的查询对应的值，但是可以通过 map 的 keys，一一返回 value。</p>
<p>所以上述解释 <em>“导致 ThreadLocalMap 中存储了一个 key 为 null 的键值对”</em> 改为：<em>“导致 ThreadLocalMap 中存储了一个“消失的” key 的键值对”</em></p>
<p><strong>上述解释仍存疑:question:</strong></p>
<p>弱引用？和垃圾回收的关系？</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL(三) 分组函数</title>
    <url>/2024/07/15/MySQL-%E4%B8%89-%E5%88%86%E7%BB%84%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>区别于“数据处理函数”：</p>
<p><strong>分组函数是多行函数</strong>，多行数据产生一个结果 (如果没有 group by)</p>
<blockquote>
<p>没加 group by 即一整张表就是一组。</p>
</blockquote>
<p><strong>数据处理函数是单行函数</strong>，一行数据一个结果。</p>
<span id="more"></span>

<h2 id="分组函数"><a href="#分组函数" class="headerlink" title="分组函数"></a>分组函数</h2><p>分组函数共有：max, min, avg, count, sum。</p>
<p><strong>常见问题</strong></p>
<p>Q: <strong><code>count(*)</code> 和<code>count(字段)</code> 的区别？&#96;</strong></p>
<p>A: 前者是统计所有字段不全为 NULL 的数量，即整张表的行数；后者是统计该字段不为空的个数。</p>
<p>Q: <strong>分组函数不能使用在 where 条件中</strong></p>
<p>A: 因为分组函数是根据查询结果计算的，如果加在 where 中就会不断改变，无法计算。</p>
<p><strong>注：</strong>多行函数是自动忽略 NULL 的，因为是从所有行中统计出结果。</p>
<h3 id="group-by"><a href="#group-by" class="headerlink" title="group by"></a>group by</h3><p>将查询结果按照某个字段分组，或者多个字段联合分组，在 where 后执行。</p>
<p><strong>经过分组后 sql 语句，只能 select 分组函数和分组字段</strong></p>
<p>因为分组后，其他数据“糅合”在一起了，无法正常显示。</p>
<h3 id="having"><a href="#having" class="headerlink" title="having"></a>having</h3><p>在分组后，对分组数据进行筛选。</p>
<blockquote>
<p>分组数据：分组函数产生的数据，或分组字段。</p>
<p>建议只有涉及到分组数据的筛选采用 having，其他用 where 提前过滤掉，保证查询效率。</p>
</blockquote>
<p><strong>区别举例：</strong>查询部门为 job 的平均薪资数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 低效用法</span><br><span class="line"><span class="keyword">select</span> job,<span class="built_in">avg</span>(sal) <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> job <span class="keyword">having</span> job<span class="operator">=</span><span class="string">&#x27;SALESMAN&#x27;</span>;</span><br><span class="line"># 高效用法</span><br><span class="line"><span class="keyword">select</span> job,<span class="built_in">avg</span>(sal) <span class="keyword">from</span> emp <span class="keyword">where</span> job<span class="operator">=</span><span class="string">&#x27;SALESMAN&#x27;</span> <span class="keyword">group</span> <span class="keyword">by</span> job;</span><br></pre></td></tr></table></figure>

<h3 id="组内排序"><a href="#组内排序" class="headerlink" title="组内排序"></a>组内排序</h3><h4 id="substring-index"><a href="#substring-index" class="headerlink" title="substring_index"></a>substring_index</h4><p>按分隔符分割。</p>
<p><strong>语法格式：</strong></p>
<p><code>substring_index(字符串, 分隔符, 子串数量)</code></p>
<h4 id="group-concat"><a href="#group-concat" class="headerlink" title="group_concat"></a>group_concat</h4><p>将分组后的同组数据进行拼接。</p>
<p><strong>语法格式：</strong></p>
<p><code>group_concat(字段 [order by ...])</code> 可选是否排序</p>
<p><strong>注意：</strong>和 group by 后的 select 语句相反，这里不应该出现分组函数和分组字段，因为同组的数据结果相同。</p>
<blockquote>
<p>但是 MySQL 是允许的。</p>
</blockquote>
<p><strong>联合使用举例：</strong>找出每个工作岗位的工资排名在前两名的员工姓名。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 先按工资对组内数据排序拼接，再按“，”分割出前两位</span><br><span class="line"><span class="keyword">select</span> job,</span><br><span class="line">substring_index(</span><br><span class="line">    group_concat(job <span class="keyword">order</span> <span class="keyword">by</span> sal), </span><br><span class="line">    &quot;,&quot;,<span class="number">2</span>) <span class="keyword">as</span> top2 </span><br><span class="line"><span class="keyword">from</span> emp </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> job;</span><br></pre></td></tr></table></figure>

<p><img src="/../assets/image-20240715225035606.png" alt="image-20240715225035606"></p>
<h2 id="语句执行顺序"><a href="#语句执行顺序" class="headerlink" title="语句执行顺序"></a>语句执行顺序</h2><p>一个相对完整的 sql 语句的执行顺序如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> ... 		# <span class="number">5</span></span><br><span class="line"><span class="keyword">from</span> ...		# <span class="number">1</span></span><br><span class="line"><span class="keyword">where</span> ...		# <span class="number">2</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> ...	# <span class="number">3</span></span><br><span class="line"><span class="keyword">having</span> ...		# <span class="number">4</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> ...	# <span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>可以参考这个顺序对 sql 语句进行优化。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>每日杂记 day3</title>
    <url>/2024/07/15/2024-7-15/</url>
    <content><![CDATA[<h2 id="八股"><a href="#八股" class="headerlink" title="八股"></a>八股</h2><h3 id="为什么-JDK-要同时提供-equals-和-hashcode-两个方法？"><a href="#为什么-JDK-要同时提供-equals-和-hashcode-两个方法？" class="headerlink" title="为什么 JDK 要同时提供 equals 和 hashcode 两个方法？"></a>为什么 JDK 要同时提供 equals 和 hashcode 两个方法？</h3><p>hashmap, hashset 的插入流程。</p>
<p>hashcode 可能会冲突，equals 检查是否一致。</p>
<h3 id="String、StringBuffer、StringBuilder-的区别"><a href="#String、StringBuffer、StringBuilder-的区别" class="headerlink" title="String、StringBuffer、StringBuilder 的区别"></a>String、StringBuffer、StringBuilder 的区别</h3><p>String 不可变，每次操作生成新对象。</p>
<p>StringBuffer、StringBuilder 每次都是对对象本身进行操作；区别是前者是线程安全的，后者不安全仅提升 10% - 15% 的性能。</p>
<h3 id="String-不可变的原因"><a href="#String-不可变的原因" class="headerlink" title="String 不可变的原因"></a>String 不可变的原因</h3><p>内部是由字符数组维护的。</p>
<ol>
<li>被 final 和 private 修饰不可指向其他对象，也不能被外部访问，String 类也没有提供修改这个字符串的方法。</li>
<li>String 类被 final 修饰，不可被继承避免了子类破坏结构。</li>
</ol>
<h3 id="字符串拼接用-“-”-还是-StringBuilder？"><a href="#字符串拼接用-“-”-还是-StringBuilder？" class="headerlink" title="字符串拼接用 “+” 还是 StringBuilder？"></a>字符串拼接用 “+” 还是 StringBuilder？</h3><p>直接使用 “+” 的方式，其实底层创建了  StringBuilder 进行优化。</p>
<p>但是如果循环进行拼接应显式创建一个 StringBuilder 来复用，否则会造成多次创建。</p>
<h3 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h3><p>是 JVM 为了提升性能和减少内存消耗针对字符串专门开辟的一块区域。</p>
<p>当创建一个字符串对象时，会先检查常量池内是否存在，如果没有就创建 2 个字符串对象，一个给当前引用，另一个的引用保存到字符串常量池中。</p>
<p><code>String.valueOf</code> 会先从常量池中找，没有再 <code>new String()</code></p>
<p>而 <code>new String()</code> 是直接创建 1 个新的，只有常量池中没有才会给常量池也创建一个。</p>
<p>所以这个常量池是专门为字符串常量建立的缓存。</p>
<h3 id="String-intern"><a href="#String-intern" class="headerlink" title="String#intern"></a>String#intern</h3><p>类似 <code>new String()</code> 会创建 1 &#x2F; 2 个对象，其中一个保存到常量池，并且返回常量池的引用，<strong>确保这个引用是唯一的</strong></p>
<h3 id="String-类型的变量和常量做-“-”-运算时发生了什么。"><a href="#String-类型的变量和常量做-“-”-运算时发生了什么。" class="headerlink" title="String 类型的变量和常量做 “+” 运算时发生了什么。"></a>String 类型的变量和常量做 “+” 运算时发生了什么。</h3><p><strong>“常量折叠”</strong>：对于在编译时期就可以确定的值，会提前进行计算。</p>
<p>而引用的值是无法直接确定的，因此会创建一个新的对象，后续进行计算。</p>
<p><strong>发生常量折叠的情况：</strong></p>
<ul>
<li>基本数据类型( <code>byte</code>、<code>boolean</code>、<code>short</code>、<code>char</code>、<code>int</code>、<code>float</code>、<code>long</code>、<code>double</code>)、字符串的<strong>常量</strong></li>
</ul>
<blockquote>
<p>无法测试区分常量相加和变量相加创建的变量地址是否一致，因为无法直接比较基本类型的地址。</p>
</blockquote>
<ul>
<li>final 修饰的基本数据类型和字符串的<strong>变量</strong>。</li>
<li>字符串通过 “+”拼接得到的字符串、基本数据类型之间算数运算（加减乘除）、基本数据类型的位运算（&lt;&lt;、&gt;&gt;、&gt;&gt;&gt; ）</li>
</ul>
<p>简言之，通过 final 修饰或者其他确定的直接运算，就会被折叠。</p>
<h3 id="Exception-和-Error-有什么区别"><a href="#Exception-和-Error-有什么区别" class="headerlink" title="Exception 和 Error 有什么区别"></a>Exception 和 Error 有什么区别</h3><p>Exception 表示程序本身能处理的异常，可以捕获。</p>
<p>Error 程序无法处理，JVM 一般会选择直接终止。</p>
<p>如：虚拟机错误（Virtual MachineError）</p>
<h3 id="finally-和-try-中同时存在-return-会怎么样？"><a href="#finally-和-try-中同时存在-return-会怎么样？" class="headerlink" title="finally 和 try 中同时存在 return 会怎么样？"></a>finally 和 try 中同时存在 return 会怎么样？</h3><p>最后 return 的值会变成 finally 的。</p>
<p>因为执行到 try 的 return 时会将返回值暂存到一个本地变量，如果 finally 也有 return 会覆盖掉之前的值。</p>
<h3 id="try-with-resources-Java7"><a href="#try-with-resources-Java7" class="headerlink" title="try-with-resources Java7"></a>try-with-resources Java7</h3><p>用于实现了 <code>AutoCloseable</code> 或者 <code>Closeable</code> 的对象。</p>
<p>在作用域结束后会自动关闭声明的资源。</p>
<blockquote>
<p>通过 ；可以声明多个资源</p>
</blockquote>
<h3 id="异常使用有哪些需要注意的地方？"><a href="#异常使用有哪些需要注意的地方？" class="headerlink" title="异常使用有哪些需要注意的地方？"></a>异常使用有哪些需要注意的地方？</h3><p>不要把异常定义为静态变量，因为这样会导致异常栈信息错乱。每次手动抛出异常，我们都需要手动 new 一个异常对象抛出。</p>
<h2 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h2><h3 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a><strong>两数之和</strong></h3><p>从一个数组中找到和为 target 的两个数的位置，时间 O(n)。</p>
<p><strong>普通思路：</strong>两两遍历 O(n^2^)</p>
<p><strong>优化：</strong>如果第一层遍历确定了一个数，那么第二层仅是为了找 target - x 是否存在，因此可以借助哈希表优化索引时间为 O(1)，key：元素值，value：索引位置。</p>
<p><strong>数组内存在重复值问题：</strong>一边遍历一边建立哈希表，即使当前元素的值重复了也不会匹配同一个元素；</p>
<blockquote>
<p>如果提前建立哈希表，数组内重复的值无法作为唯一 key，当 target 需要由类似 3+3&#x3D;6 组成时，就会找不到索引。</p>
</blockquote>
<h3 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a><strong>接雨水</strong></h3><p>给出一个数组 height，其中 n 个元素代表 n 个高度为 height[n]，底部为 1 的柱子，试求出所有柱子构成的“容器”能够储存的雨水量总和。</p>
<p>类似 “盛最多水的容器” 一题，能够承载雨水量由最短高度决定。</p>
<p><strong>解法：</strong>一个柱子能够装的水等于两条“边”的最短边 - 本身高度，遍历每根柱子，依次求出左右两边的最长边，求出所有柱子的储水量相加即为结果。</p>
<blockquote>
<p>求 左右 最长边时包括自身，确保不会比自身还短，导致“漏掉”。</p>
</blockquote>
<p><strong>普通思路：</strong>遍历数组，求每个柱子的左右 max 然后计算，统计所有柱子储水量之和 O(n^2^)。</p>
<p><strong>优化（动态规划）：</strong> 和哈希表类似，可以提前算出每个点的左右 max，这样就避免了每次计算的重复寻找 max，使得计算过程为 O(1)，最终时间 O(n)，空间 O(n)。</p>
<p><strong>再优化（双指针）：</strong>从左右边界开始，由于每个柱子都可能作为边界，只要 height[l] &lt; height[r] 那么就一定有 left_max &lt; right_max 的情况发生，所以此时直接用 left_max - 自身高度 得到此刻的储水量，将空间缩减为了 O(1)。</p>
<blockquote>
<p>相当于抽象了整体，选出只需要“处理”一个方向的情况进行计算，不需要管另一边了。</p>
<p>当动态规划中的数据只需要用到 1 次时，可以考虑转化为双指针。</p>
</blockquote>
<h3 id="什么是动态规划？"><a href="#什么是动态规划？" class="headerlink" title="什么是动态规划？"></a>什么是动态规划？</h3><p>在动态中规划逻辑路线，根据状态变化能够做出新的决策；</p>
<h2 id="MySQL-分组"><a href="#MySQL-分组" class="headerlink" title="MySQL 分组"></a>MySQL 分组</h2><p>一个完整的分组流程。</p>
<p>选择表 emp；</p>
<p>分组 job；</p>
<p>筛选 having avg(sal) &gt; 2000；</p>
<p>展示 job,avg(sal)</p>
]]></content>
      <categories>
        <category>每日总结</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>算法</tag>
        <tag>八股</tag>
      </tags>
  </entry>
  <entry>
    <title>每日总结 day2</title>
    <url>/2024/07/14/2024-7-14/</url>
    <content><![CDATA[<h2 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h2><p>经过三道题，近乎两小时的洗礼。</p>
<p>我似乎明白了双指针的精髓。</p>
<p>双指针，双指针，双：一定会出现两者的相互关系。</p>
<p>而借助两者关系就能让两者相互“运动”，从而可以尽量把 O(n^2^) 的时间缩短至 O(n)。</p>
<h3 id="盛最多水的容器"><a href="#盛最多水的容器" class="headerlink" title="盛最多水的容器"></a>盛最多水的容器</h3><p>给定一个 heights 数组，索引代表 x 轴上的点，每一个值代表这个点的高度（y）。</p>
<p>尝试找到两个点之间构成的容器（矩形），能形成的最大面积。</p>
<p><strong>关键点：木桶效应，容量是由最短的边决定的。</strong></p>
<p><strong>解题思路：</strong></p>
<ol>
<li>面积由 x, y 两者决定，因此首先定义双指针指向左右边界，使得 x 最大。</li>
<li>其次就到了遍历求解过程了：如何让 x 缩减的同时，y 能尽量增大。<ol>
<li>假设选定了两条边分为位于 a, b 点，距离为 t，且 a &lt; b；</li>
<li>如果移动 b，最大面积绝对不会超过 a * t，所以关键在于最短边；</li>
<li>只要每次移动短的那一边，就能尽可能让结果增大，以此减少遍历次数。</li>
</ol>
</li>
<li>同时由于容器两边肯定要不能重合或反着计算对称的结果，应确保 a &lt; b；</li>
</ol>
<p><strong>再优化</strong></p>
<p>再遍历次数无法减少的情况下，可以对计算次数进行简化。</p>
<p>记录最短边，只要移动过后的值还 &lt;&#x3D; 最短边，就一直移动无需计算。</p>
<h3 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a><strong>三数之和</strong></h3><p>给定一个 nums 数组，要求找出位置互不相同的三个数，使其满足 i + j + k &#x3D; 0。</p>
<p><strong>解题思路：</strong> </p>
<p>首先为了避免三个在三三遍历时出现一个尾，一个头重复使用的情况，应对数组进行排序，然后有序遍历。</p>
<p>找出两者关系，三个数，两者关系？？？</p>
<p><strong>i + j + k &#x3D; 0 可以转化为 j + k &#x3D; -i</strong></p>
<p>将 i, j, k 分别看做三个数，普通思路是直接三层遍历 O(n^3^)，</p>
<p>但是当第一层遍历时，i 的值在某一个刻是<strong>确定的</strong>。</p>
<p>因此第 2 和 3 层遍历是有关系的。</p>
<p>要想保证 i 不变，需要一层增加，一层减少。</p>
<p>由于数组时有序且递增的，</p>
<p>只需要在第二层递增遍历时，同时让第三层递减遍历即可，这样就减少了一层时间复杂度。</p>
<h2 id="Java-八股"><a href="#Java-八股" class="headerlink" title="Java 八股"></a>Java 八股</h2><h3 id="Java的特点"><a href="#Java的特点" class="headerlink" title="Java的特点"></a>Java的特点</h3><p>面向对象、平台无关、多线程、可靠性、安全、高效。</p>
<h3 id="Java：“编译与解释并存”"><a href="#Java：“编译与解释并存”" class="headerlink" title="Java：“编译与解释并存”"></a>Java：“编译与解释并存”</h3><p>java代码 -&gt; 字节码 -&gt; 机器码</p>
<h3 id="基本类型和包装类型的区别"><a href="#基本类型和包装类型的区别" class="headerlink" title="基本类型和包装类型的区别"></a>基本类型和包装类型的区别</h3><ol>
<li>用途</li>
<li>存储方式</li>
<li>占用空间</li>
<li>默认值</li>
<li>比较方式</li>
</ol>
<h3 id="包装类型的缓存机制"><a href="#包装类型的缓存机制" class="headerlink" title="包装类型的缓存机制"></a>包装类型的缓存机制</h3><p>new 和 自动装箱</p>
<h3 id="包装类的装箱和拆箱的本质"><a href="#包装类的装箱和拆箱的本质" class="headerlink" title="包装类的装箱和拆箱的本质"></a>包装类的装箱和拆箱的本质</h3><p>valueOf  intValue</p>
<h3 id="如何解决浮点数运算精度丢失问题"><a href="#如何解决浮点数运算精度丢失问题" class="headerlink" title="如何解决浮点数运算精度丢失问题"></a>如何解决浮点数运算精度丢失问题</h3><p>BigDecimal 字符数组</p>
<h3 id="超过-long-长度的整型该如何表示"><a href="#超过-long-长度的整型该如何表示" class="headerlink" title="超过 long 长度的整型该如何表示"></a>超过 long 长度的整型该如何表示</h3><p>BigInteger</p>
<h3 id="成员变量和局部变量的区别"><a href="#成员变量和局部变量的区别" class="headerlink" title="成员变量和局部变量的区别"></a>成员变量和局部变量的区别</h3><p>语法形式：访问修饰符，static</p>
<p>存储方式：堆，栈</p>
<p>生存时间：实例创建，局部作用域</p>
<p>默认值</p>
<blockquote>
<p>为什么成员变量有默认值</p>
</blockquote>
<h3 id="字符型常量和字符串常量的区别？"><a href="#字符型常量和字符串常量的区别？" class="headerlink" title="字符型常量和字符串常量的区别？"></a>字符型常量和字符串常量的区别？</h3><p>表示形式：</p>
<p>含义：</p>
<p>内存大小：</p>
<h3 id="重写父类方法的要求"><a href="#重写父类方法的要求" class="headerlink" title="重写父类方法的要求"></a>重写父类方法的要求</h3><p>返回值类型，抛出异常，访问修饰符（向上转型）</p>
<h3 id="可变长参数-Java5"><a href="#可变长参数-Java5" class="headerlink" title="可变长参数 Java5"></a>可变长参数 Java5</h3><p>声明位置？</p>
<p>遇上方法重载？优先级低</p>
<h3 id="面向过程性能比面向对象高？"><a href="#面向过程性能比面向对象高？" class="headerlink" title="面向过程性能比面向对象高？"></a>面向过程性能比面向对象高？</h3><p>c &#x2F; C++, Java?</p>
<h3 id="面向对象三大特征"><a href="#面向对象三大特征" class="headerlink" title="面向对象三大特征"></a>面向对象三大特征</h3><p>封装</p>
<p>集成</p>
<p>多态</p>
<h3 id="浅拷贝、深拷贝、引用拷贝"><a href="#浅拷贝、深拷贝、引用拷贝" class="headerlink" title="浅拷贝、深拷贝、引用拷贝"></a>浅拷贝、深拷贝、引用拷贝</h3><p>一层</p>
<p>完全</p>
<p>地址</p>
<h3 id="与equals方法的区别"><a href="#与equals方法的区别" class="headerlink" title="&#x3D;&#x3D;与equals方法的区别"></a>&#x3D;&#x3D;与equals方法的区别</h3><p>Object默认的equals</p>
<h3 id="为什么重写equals必须重写hashcode方法？"><a href="#为什么重写equals必须重写hashcode方法？" class="headerlink" title="为什么重写equals必须重写hashcode方法？"></a>为什么重写equals必须重写hashcode方法？</h3><p>因为相等的对象hashcode必须一致，否则hashmap会出现相同的key值的情况</p>
]]></content>
      <categories>
        <category>每日总结</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>算法</tag>
        <tag>八股</tag>
      </tags>
  </entry>
  <entry>
    <title>每日总结 day1</title>
    <url>/2024/07/13/2024-7-13/</url>
    <content><![CDATA[<p>在此立个 Flag：遵循我的每日安排！并且坚持 21 天！</p>
<blockquote>
<p>期间中断不能超过 1 天，避免意外情况。</p>
</blockquote>
<p>失败惩罚：一个星期不许进行任何娱乐活动！</p>
<hr>
<h2 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h2><p>:happy: 今天悟出来的做题经验：</p>
<ol>
<li>先根据题意，写出最简单的、最能想得到的思路。</li>
<li>然后把思路转变为代码，并且额外留意区间的临界点。</li>
</ol>
<blockquote>
<p>临界点：除一般情况外，代码逻辑并不能正确执行的某个状态。</p>
</blockquote>
<ol start="3">
<li>再根据题目标签（涉及的数据结构）和题目要求，一步一步的优化代码。</li>
</ol>
<h3 id="链表指定区间反转"><a href="#链表指定区间反转" class="headerlink" title="链表指定区间反转"></a><strong>链表指定区间反转</strong></h3><p>给出一个区间的起始位置和结束位置，要求反转这个区间的节点，然后重新和整个链表连接上。</p>
<p><strong>解题思路：</strong>找到这个区间的前置节点（起始位置的前一个）和后置节点（同理），然后遍历反转这段区间的节点，再分别用前置和后置节点连上。</p>
<p><strong>临界点：</strong>链表为空、区间长度为1。</p>
<p><strong>难点：</strong>起始点可能在头部，需要一个假的头节点作为前置节点来连接整个链表。</p>
<blockquote>
<p>也可以把这个作为一个“临界点”处理。if m &#x3D;&#x3D; 1</p>
</blockquote>
<h3 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a><strong>合并两个有序链表</strong></h3><p>输入两个递增的链表，单个链表的长度为n，合并这两个链表并使新链表中的节点仍然是递增排序的。</p>
<p><strong>解题思路：</strong>创建一个新的头节点用来构建新链表，分别<strong>同时</strong>遍历两个链表，循环取出值更小的那一个，直到其中一个链表为空，尾部直接全部接上另一个链表。</p>
<p><strong>临界点</strong>：任意一个链表为空。</p>
<p><strong>难点：</strong>代码条件关系的判断。</p>
<h3 id="字母异位词分组"><a href="#字母异位词分组" class="headerlink" title="字母异位词分组"></a><strong>字母异位词分组</strong></h3><p>给一个字符串数组，要求将属于同一类<strong>字母异位词</strong>的字符串组成一个新的数组。</p>
<blockquote>
<p>字母异位词：如果将一个字符串中的所有字母任意排列可以得到另一个字符串，即互为字母异位词。</p>
</blockquote>
<p><strong>解题思路：</strong>既然每个异位词包含的所有字母都是相同的，那么将字母重新按照字典序排序得到的结果就一定是一样的。此时只需要创建一个以字典序为 key，异位词数组为 value 的哈希表，遍历完整个数组就能得到按异位词分组的数组了。</p>
<blockquote>
<p>“bat”, “bta”, “atb” &#x3D;&gt; “abt”</p>
</blockquote>
<p><strong>难点：</strong>发现一组字母异位词（题干）的共同点（分组依据）。</p>
<h3 id="最长连续序列"><a href="#最长连续序列" class="headerlink" title="最长连续序列"></a>最长连续序列</h3><p>给定一个未排序的整数数组 <code>nums</code> ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p>
<p><strong>解题思路：</strong>遍历数组，以元素 x 为起始值，尝试匹配 x+1, x+2, … , x+y 符合连续序列的值是否存在，记录最大的连续长度。</p>
<p><strong>难点：</strong>降低时间复杂度</p>
<ul>
<li>暴力匹配：第一层遍历元素 x，第二层匹配 1-y 连续值，第三层再次遍历是否存在，总时间 O(n^3^)</li>
<li>哈希索引：先遍历一遍构建哈希索引，将第三层的判断缩减为 O(n)，总时间 O(n^2^)</li>
<li>剔除子区间：在尝试匹配连续序列前，应先检验 x-1 是否存在，如果存在那么从 x-1 开始的序列长度一定大于本元素起始的序列，所以直接跳过匹配，综合计算总时间 O(n)。</li>
</ul>
<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><p>思路：</p>
<ol>
<li>先找到提问关注点，针对性回答。</li>
</ol>
<blockquote>
<p> 类似举例的问题可以相对粗略的回答，指明是原理就应该详细回答。</p>
</blockquote>
<ol start="2">
<li>不应该直接扯到深层知识，可以留给面试官提问的空间。</li>
</ol>
]]></content>
      <categories>
        <category>每日总结</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>刷题</tag>
        <tag>哈希表</tag>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL(二) 数据处理函数</title>
    <url>/2024/07/12/MySQL-%E4%BA%8C-%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>在数据库操作中，除了需要查询数据，</p>
<p>有时候还需要对数据进行一些简单的处理，</p>
<p>用于优化数据显示效果等。</p>
<span id="more"></span>

<p><strong>select的其他用法</strong></p>
<p>select 除了可以选择列名外，还可以选择常量。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="number">3</span>; # <span class="number">3</span></span><br><span class="line"><span class="keyword">select</span> <span class="string">&#x27;hello world&#x27;</span>; # hello world</span><br></pre></td></tr></table></figure>

<h1 id="upper、lower"><a href="#upper、lower" class="headerlink" title="upper、lower"></a>upper、lower</h1><p>分别用于将字符串转为大写和小写</p>
<blockquote>
<p>ucase, lcase 分别也可以转大小写。</p>
</blockquote>
<p><strong>应用</strong></p>
<p>当不知道查询内容的大小写时，可以统一转为大写&#x2F;小写来匹配查询。</p>
<p>在 Oracle 数据库中区分大小写，Linux 的 MySQL 也区分</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> <span class="built_in">upper</span>(ename)<span class="operator">=</span><span class="string">&#x27;smith&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h1 id="substr"><a href="#substr" class="headerlink" title="substr"></a>substr</h1><p>用于截取字符串</p>
<p><strong>用法</strong></p>
<ol>
<li>substr(‘被截取的字符串’, 起始下标, 截取长度)</li>
<li>substr(‘被截取的字符串’, 起始下标)</li>
</ol>
<blockquote>
<p>如果不写截取长度，就直接截取到尾部。</p>
</blockquote>
<p><strong>截取规则：</strong></p>
<ol>
<li><p>下标从 1 开始，-1 表示右侧第一个。</p>
</li>
<li><p>截取的方向永远往右边截取。</p>
</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> substr(<span class="string">&#x27;abcd&#x27;</span>, <span class="number">-1</span>, <span class="number">2</span>); # d</span><br></pre></td></tr></table></figure>

<p>上述 sql 只能得到 ‘d’，而不是 ‘cd’</p>
<p><strong>应用</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> substr(ename, <span class="number">2</span>, <span class="number">1</span>) <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>选择 ename 第二个字符是 A 的行。</p>
<h1 id="length、char-length"><a href="#length、char-length" class="headerlink" title="length、char_length"></a>length、char_length</h1><p>length 用于统计字符串的字节数</p>
<p>char_length 用于统计字符数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> length(<span class="string">&#x27;你好&#x27;</span>); # <span class="number">6</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">char_length</span>(<span class="string">&#x27;你好&#x27;</span>); # <span class="number">2</span></span><br></pre></td></tr></table></figure>

<h1 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h1><p>用于拼接字符串，可以传入任意个参数。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> concat(<span class="string">&#x27;hello &#x27;</span>, <span class="string">&#x27;world&#x27;</span>); # hello world</span><br></pre></td></tr></table></figure>

<blockquote>
<p>mysql8之前可以采用 || 进行拼接。</p>
<p>‘hello ‘ || ‘world’ &#x3D;&gt; ‘hello world’</p>
</blockquote>
<h1 id="trim"><a href="#trim" class="headerlink" title="trim"></a>trim</h1><p>去除字符串前后空白字符。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">trim</span>(<span class="string">&#x27;  a  b  c  &#x27;</span>);</span><br><span class="line"># a  b  c</span><br></pre></td></tr></table></figure>

<p><strong>扩展</strong></p>
<p>leading</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">trim</span>(<span class="keyword">leading</span> <span class="string">&#x27;0&#x27;</span> <span class="keyword">from</span> <span class="string">&#x27;000111&#x27;</span>);</span><br><span class="line"># <span class="number">111</span></span><br></pre></td></tr></table></figure>

<p>去除前面的 0 字符。</p>
<p>trailing</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">trim</span>(<span class="keyword">trailing</span> <span class="string">&#x27;0&#x27;</span> <span class="keyword">from</span> <span class="string">&#x27;111000&#x27;</span>);</span><br><span class="line"># <span class="number">111</span></span><br></pre></td></tr></table></figure>

<p>去除后面的 0 字符</p>
<p>both</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">trim</span>(<span class="keyword">both</span> <span class="string">&#x27;x&#x27;</span> <span class="keyword">from</span> <span class="string">&#x27;xx111xx&#x27;</span>);</span><br><span class="line"># <span class="number">111</span></span><br></pre></td></tr></table></figure>

<p>去除前后的 x 字符</p>
<h1 id="rand"><a href="#rand" class="headerlink" title="rand()"></a>rand()</h1><p>生成 0 到 1 之间的随机浮点数。</p>
<p>还有一种写法：rand(x)</p>
<p>通过传入一个值，保留本次随机数的值。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> rand(<span class="number">1</span>); # <span class="number">0.918204912</span></span><br><span class="line"><span class="keyword">select</span> rand(<span class="number">1</span>); # <span class="number">0.918204912</span></span><br></pre></td></tr></table></figure>

<p>这个 x 就相当于一个 key，每次获取同样的 x，得到的值都是一样的。</p>
<blockquote>
<p>这个 x 应该是“种子”吧，如果种子相同得到的结果自然是一样的。</p>
</blockquote>
<h1 id="round-x"><a href="#round-x" class="headerlink" title="round(x)"></a>round(x)</h1><p>四舍五入</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> round(<span class="number">3.5</span>); # <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p><strong>指定保留的小数位</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> round(<span class="number">3.63</span>, <span class="number">1</span>); #<span class="number">3.6</span></span><br></pre></td></tr></table></figure>

<h1 id="truncate-x-y"><a href="#truncate-x-y" class="headerlink" title="truncate(x, y)"></a>truncate(x, y)</h1><p>只保留 y 个小数，剩下小数位舍弃</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">truncate</span>(<span class="number">3.6666</span>, <span class="number">1</span>); # <span class="number">3.6</span></span><br></pre></td></tr></table></figure>

<h1 id="ceil-x-、floor-x"><a href="#ceil-x-、floor-x" class="headerlink" title="ceil(x)、floor(x)"></a>ceil(x)、floor(x)</h1><p>ceil：向上取整</p>
<p>floor：向下取整</p>
<blockquote>
<p>忽略四舍五入</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">ceil</span>(<span class="number">4.7</span>); # <span class="number">5</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">floor</span>(<span class="number">4.7</span>); # <span class="number">4</span></span><br></pre></td></tr></table></figure>

<h1 id="空处理"><a href="#空处理" class="headerlink" title="空处理"></a>空处理</h1><p>在 MySQL 和 Oracle 中，任何和 NULL 运算的结果都是 NULL；</p>
<p><strong><code>ifnull(x, y)</code></strong></p>
<p>如果 x 为 NULL，就用 y 代替</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> ename, sal, ((sal <span class="operator">+</span> ifnull(comm, <span class="number">0</span>)) <span class="operator">*</span> <span class="number">12</span>) <span class="keyword">as</span> year_sal <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure>

<p>当 comm 为空时（员工没有津贴时），统一用 0 代替，避免运算结果为 NULL。</p>
<h1 id="获取当前-datetime"><a href="#获取当前-datetime" class="headerlink" title="获取当前 datetime"></a>获取当前 datetime</h1><p><code>now()</code></p>
<p>获取当前时间（select 执行的时间）</p>
<p><img src="/assets/image-20240712221917658.png" alt="image-20240712221917658"></p>
<p><code>sysdate()</code></p>
<p>获取该函数执行的时间</p>
<p><img src="/assets/image-20240712222000512.png" alt="image-20240712222000512"></p>
<blockquote>
<p>底层应该是 now 直接被转化为当前时间，而 sysdate 按照程序执行顺序获取时间。</p>
</blockquote>
<h1 id="获取当前-date-time"><a href="#获取当前-date-time" class="headerlink" title="获取当前 date&#x2F;time"></a>获取当前 date&#x2F;time</h1><p><code>current_date()</code> 获取当前日期</p>
<p><code>current_time()</code> 获取当前时间</p>
<blockquote>
<p>可以省略括号()</p>
</blockquote>
<h1 id="获取单独的年月日时分秒"><a href="#获取单独的年月日时分秒" class="headerlink" title="获取单独的年月日时分秒"></a>获取单独的年月日时分秒</h1><p><code>year(时间)</code></p>
<p><code>month(时间)</code></p>
<p><code>day(时间)</code></p>
<p><code>hour(时间)</code></p>
<p><code>minute(时间)</code></p>
<p><code>second(时间)</code></p>
<p>这里的时间可以是 now()，或者符合日期格式的字符串。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">year</span>(<span class="string">&#x27;2024-07-12 22:26:31&#x27;</span>);</span><br><span class="line"># <span class="number">2024</span></span><br></pre></td></tr></table></figure>

<h1 id="date-add"><a href="#date-add" class="headerlink" title="date_add"></a>date_add</h1><p>用于日期时间的运算</p>
<p>语法格式：</p>
<p><code>date_add(日期，interval expr 单位)</code></p>
<p>例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> date_add(<span class="string">&#x27;2020-10-14&#x27;</span>, <span class="type">interval</span> <span class="number">3</span> <span class="keyword">day</span>);</span><br><span class="line"># <span class="number">2020</span><span class="number">-10</span><span class="number">-17</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>只提供“日期”，可以用“时分秒”等次级单位来增减间隔。</p>
<p>但是如果只提供“时分秒”，就无法用上一级的单位“年月日”来增减间隔了。</p>
<p>运算向下兼容。</p>
</blockquote>
<p><strong>参数介绍</strong></p>
<p>日期：一个日期类型的数据或字符串</p>
<p>interval：固定写法，关键字</p>
<p>expr：指定一个具体的间隔量</p>
<blockquote>
<p>可以为负数，效果和 date_sub 一致，表示往后退。</p>
</blockquote>
<p>单位：</p>
<ul>
<li>年月日</li>
<li>时分秒</li>
<li>microsecond 微妙</li>
<li>week 周</li>
<li>quarter 一个季度（3个月）</li>
</ul>
<p><strong>复合单位</strong></p>
<p>两个单位通过下划线组合在一起。</p>
<p>例如：</p>
<ul>
<li>year_month</li>
<li>day_hour</li>
<li>day_minute</li>
<li>day_second</li>
</ul>
<blockquote>
<p>没有 month_day，不知道为什么。。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> date_add(<span class="string">&#x27;2020-10-14&#x27;</span>, <span class="type">interval</span> <span class="string">&#x27;1,1&#x27;</span> year_month);</span><br><span class="line"># <span class="number">2021</span><span class="number">-11</span><span class="number">-14</span></span><br></pre></td></tr></table></figure>

<p>注意：expr 需用引号包裹，表示一个表达式。</p>
<h2 id="date-format"><a href="#date-format" class="headerlink" title="date_format"></a>date_format</h2><p>用于日期格式化</p>
<p><strong>语法格式：</strong></p>
<p><code>date_format(日期, 格式字符串)</code></p>
<p>举例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> date_format(now(), <span class="string">&#x27;%y-%m-%d %H:%i:%s&#x27;</span>);</span><br><span class="line"># <span class="number">24</span><span class="number">-07</span><span class="number">-14</span> <span class="number">23</span>:<span class="number">28</span>:<span class="number">11</span></span><br></pre></td></tr></table></figure>

<p><strong>参数介绍</strong></p>
<p>日期：可以是日期类型数据或字符串</p>
<p>格式字符串：由“%”+代表年月日时间的字符，和其他分隔字符组成。</p>
<p><strong>日期字符：</strong></p>
<ul>
<li>Y &#x2F; y：Y：四位完整的年份，y：完整年份的后两位数。</li>
<li>m：月份</li>
<li>d：日</li>
<li>H：小时</li>
<li>i：分钟</li>
<li>s：秒</li>
</ul>
<h2 id="str-to-date"><a href="#str-to-date" class="headerlink" title="str_to_date"></a>str_to_date</h2><p>将字符串转为日期</p>
<p><strong>语法格式：</strong></p>
<p><code>str_to_date(日期, 格式字符串)</code></p>
<p>格式字符串与 <code>date_format</code> 一致。</p>
<p><strong>例如：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_student(name, birth) <span class="keyword">values</span>(<span class="string">&#x27;lisi&#x27;</span>, str_to_date(<span class="string">&#x27;10/01/1999&#x27;</span>, <span class="string">&#x27;%m/%d/%Y&#x27;</span>));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>或者直接输入遵循默认日期格式的字符串（%y-%m-%d %H:%i:%s）。</p>
</blockquote>
<h2 id="dayofweek-dayofmonth-dayofyear"><a href="#dayofweek-dayofmonth-dayofyear" class="headerlink" title="dayofweek, dayofmonth, dayofyear"></a>dayofweek, dayofmonth, dayofyear</h2><p>分别给出<strong>目标日期</strong>对应一个星期，一个月，一年中的<strong>哪一天</strong></p>
<p><strong>语法格式：</strong></p>
<p><code>dayofweek(日期)</code></p>
<p>同，可以是日期类型数据或者字符串。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> dayofweek(now());</span><br><span class="line"><span class="keyword">select</span> dayofmonth(now());</span><br><span class="line"><span class="keyword">select</span> dayofyear(now());</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：<strong>周日</strong>是一周的第一天</p>
</blockquote>
<h2 id="last-day"><a href="#last-day" class="headerlink" title="last_day"></a>last_day</h2><p>给出当前月份的最后一天的日期。</p>
<p><strong>语法格式：</strong></p>
<p><code>last_day(日期)</code></p>
<p>同，可以是日期类型数据或者字符串。</p>
<h2 id="datediff-timediff"><a href="#datediff-timediff" class="headerlink" title="datediff, timediff"></a>datediff, timediff</h2><p><strong>datediff：</strong>显示两个日期相差的天数。</p>
<p><strong>timediff：</strong>求出两个日期相差的小时数，以时:分:秒的形式显示。</p>
<p><strong>语法格式：</strong></p>
<p><code>datediff(日期1, 日期2)</code></p>
<p><code>timediff(日期1, 日期2)</code></p>
<p><strong>例如：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> datediff(<span class="string">&#x27;2000-10-10 10:10:10&#x27;</span>, <span class="string">&#x27;2000-10-9 10:10:10&#x27;</span>);</span><br><span class="line"># <span class="number">1</span></span><br><span class="line"><span class="keyword">select</span> timediff(<span class="string">&#x27;2000-10-10 10:10:10&#x27;</span>, <span class="string">&#x27;2000-10-9 10:10:10&#x27;</span>);</span><br><span class="line"># <span class="number">24</span>:<span class="number">00</span>:<span class="number">00</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>结果是以日期1比日期2晚 xx 时间计算的，前者时间晚于后者，结果为正数，反之为负数。</p>
</blockquote>
<h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><p>类似 Java 中的三目运算符。</p>
<p><strong>语法格式：</strong></p>
<p><code>if(条件, x, y)</code></p>
<p>条件符合返回 x，反之返回 y。</p>
<p><strong>例如：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> if(<span class="number">1</span><span class="operator">&lt;</span><span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>); # <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>支持嵌套运算</strong></p>
<p>当 job 为 SALESMAN 时薪水乘以 1.1 倍，为 MANAGER 时薪水乘以 2 倍，请给出结果。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> sal, job, if(job<span class="operator">=</span><span class="string">&#x27;SALESMAN&#x27;</span>, sal<span class="operator">*</span><span class="number">1.1</span>, if(job<span class="operator">=</span><span class="string">&#x27;MANAGER&#x27;</span>, sal<span class="operator">*</span><span class="number">2</span>, sal)) <span class="keyword">as</span> new_sal <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure>

<p><img src="/assets/image-20240714234512305.png" alt="image-20240714234512305"></p>
<h2 id="case…when…then…else…end"><a href="#case…when…then…else…end" class="headerlink" title="case…when…then…else…end"></a><strong>case…when…then…else…end</strong></h2><p>类似 Java 中的 switch</p>
<p><strong>语法格式：</strong></p>
<p><code>case 变量 when 匹配值 then 结果 else 结果 end</code></p>
<p><strong>例如：</strong>（修改 if 嵌套）</p>
<p>:x:错误写法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select sal, job, (case job</span><br><span class="line">when job=&#x27;SALESMAN&#x27; then sal*1.1</span><br><span class="line">when job=&#x27;MANAGER&#x27; then sal*2</span><br><span class="line">else sal end) as new_sal</span><br><span class="line">from emp;</span><br></pre></td></tr></table></figure>

<p>:question: 为什么写成 job&#x3D;’xxx’ 反而是 manager 的薪水乘以 1.1，salesman 的薪水乘以 2 了。</p>
<p>正确写法</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> sal, job, (<span class="keyword">case</span> job</span><br><span class="line"><span class="keyword">when</span> <span class="string">&#x27;SALESMAN&#x27;</span> <span class="keyword">then</span> sal<span class="operator">*</span><span class="number">1.1</span></span><br><span class="line"><span class="keyword">when</span> <span class="string">&#x27;MANAGER&#x27;</span> <span class="keyword">then</span> sal<span class="operator">*</span><span class="number">2</span></span><br><span class="line"><span class="keyword">else</span> sal <span class="keyword">end</span>) <span class="keyword">as</span> new_sal</span><br><span class="line"><span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure>

<p><img src="/assets/image-20240714235253338.png" alt="image-20240714235253338"></p>
<p>结果和 if 嵌套写法一致。</p>
<blockquote>
<p>建议先写好模板，然后一个一个条件填入</p>
</blockquote>
<h2 id="cast"><a href="#cast" class="headerlink" title="cast"></a>cast</h2><p>用于类型转换</p>
<p><strong>语法格式：</strong></p>
<p><code>cast(值 as 数据类型)</code></p>
<p><strong>数据类型：</strong></p>
<ul>
<li>date：日期</li>
<li>time：时间</li>
<li>datetime：日期时间</li>
<li>signed：有符号的 int 类型</li>
<li>char：char(字符长度)，字符。</li>
<li>decimal：decimal(有效数字位，保留小数位)，浮点数。</li>
</ul>
<blockquote>
<p>有效数字位包括小数位。</p>
<p>转化为 decimal 时如果指定的实际值超过了有效数字位，</p>
<p>会返回要求有效数字位的最大值。</p>
<p>如：将 ‘123.456’ 转为 decimal(3, 1) &#x3D;&gt; 99.9</p>
</blockquote>
<p><strong>例如：</strong>将字符串转为浮点数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">cast</span>(<span class="string">&#x27;000123.456&#x27;</span> <span class="keyword">as</span> <span class="type">decimal</span>(<span class="number">4</span>,<span class="number">1</span>));</span><br><span class="line"># <span class="number">123.5</span> 四舍五入</span><br></pre></td></tr></table></figure>

<h2 id="md5"><a href="#md5" class="headerlink" title="md5"></a>md5</h2><p>单向加密算法，结果是一个固定长度 32 位的字符串。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>JMeter 测试教程</title>
    <url>/2024/07/09/JMeter%E6%B5%8B%E8%AF%95%E5%A4%9A%E4%BA%BA%E5%B9%B6%E5%8F%91%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>一个好的项目不仅需要完整的业务功能，</p>
<p>更应该保证处理响应的效率！</p>
<p>在业务中经常需要检验并发的可靠性，特别是多人同时操作对业务的影响。</p>
<p>这时候就可以借助 JMeter 进行测试。</p>
<p>本文提供两种方式：串行测试、全局属性</p>
<span id="more"></span>

<h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><p>首先介绍下 JMeter 的基本使用。</p>
<p>一个完整的测试分为创建线程组，创建取样器（请求），定义响应结果断言。</p>
<p><strong>创建线程组</strong>目的是设置并发量。</p>
<h2 id="创建线程组"><a href="#创建线程组" class="headerlink" title="创建线程组"></a>创建线程组</h2><p><img src="https://gcore.jsdelivr.net/gh/BlueApong/images@main/img/202407112345944.png" alt="image-20240709130805462"></p>
<p><strong>线程组大致分为三类：</strong></p>
<ol>
<li>启动线程组，最开始执行的线程</li>
<li>销毁线程组，最后才执行的线程</li>
<li>普通线程组，除启动和销毁外被放在中间执行的线程</li>
</ol>
<p>（以上待考证，因为是我猜的）</p>
<p>一般来说随便选一个线程组都可以，如果同时只需要用到一个线程组的话</p>
<p><strong>参数介绍</strong></p>
<p><img src="https://gcore.jsdelivr.net/gh/BlueApong/images@main/img/202407112346988.png" alt="image-20240711234655935"></p>
<p>Name：线程组的名称</p>
<p>Action to be token after…：当某个线程失败后的执行策略</p>
<p>Number of Threads：总线程数</p>
<p>Ramp-up period：执行完全部线程的时间（秒）</p>
<p>Loop Count：该线程组的循环次数</p>
<p>Same user on…：每个线程是否采用同一个数据（当你读取文件时有用）</p>
<p>常用的就是设置线程数和总时间，比如设置 threads: 1000 period: 10，就是 10 秒内跑完 1000 个线程，平均每秒 100 个并发。</p>
<p><strong>注意：</strong>实际情况下线程数是不断递增的，因为启动需要时间。 </p>
<h2 id="创建取样器"><a href="#创建取样器" class="headerlink" title="创建取样器"></a>创建取样器</h2><p>以创建 HTTP 请求为例</p>
<p>右键线程组弹出菜单，点击 Add -&gt; Sampler -&gt; HTTP Request</p>
<p><img src="https://gcore.jsdelivr.net/gh/BlueApong/images@main/img/202407112355332.png" alt="image-20240709134542130"></p>
<p><strong>参数介绍</strong></p>
<p><img src="https://gcore.jsdelivr.net/gh/BlueApong/images@main/img/202407112357005.png" alt="image-20240711235738958"></p>
<p>分别通过 protocal, server name(domain), port, path 设置请求的 URL 路径。</p>
<p>再通过 HTTP Request 选择请求的方式，下面的 Parameters, Body Data … 可携带请求参数&#x2F;请求体。</p>
<h2 id="定义响应结果断言"><a href="#定义响应结果断言" class="headerlink" title="定义响应结果断言"></a>定义响应结果断言</h2><p>以 JSON 断言为例，</p>
<p>在此之前需声明响应头信息的 Content-Type 为 JSON</p>
<h3 id="添加响应头配置"><a href="#添加响应头配置" class="headerlink" title="添加响应头配置"></a>添加响应头配置</h3><p>右键取样器，点击 Add -&gt; Config Element -&gt; HTTP Header Manager</p>
<p><img src="https://gcore.jsdelivr.net/gh/BlueApong/images@main/img/202407121103271.png" alt="image-20240712110317215"></p>
<p>然后就是根据 Name-Value 的规则添加信息头了。</p>
<p>再右键取样器创建断言，点击 Add -&gt; Assertions -&gt; JSON Assertion</p>
<p><img src="https://gcore.jsdelivr.net/gh/BlueApong/images@main/img/202407120002114.png" alt="image-20240712000225048"></p>
<p><strong>参数介绍</strong></p>
<p><img src="https://gcore.jsdelivr.net/gh/BlueApong/images@main/img/202407120004509.png" alt="image-20240712000427473"></p>
<p>Assert JSON Path exists：表示响应结果 JSON 对象中包含 xx 属性。</p>
<p>Additionally assert value：同时断言这个属性的值。</p>
<p>Match as regular expression：以正则表达式的语法匹配。</p>
<p>Expected Value：期望的属性值。</p>
<h2 id="添加结果分析报告"><a href="#添加结果分析报告" class="headerlink" title="添加结果分析报告"></a>添加结果分析报告</h2><p><img src="https://gcore.jsdelivr.net/gh/BlueApong/images@main/img/202407121122750.png" alt="image-20240712112237695"></p>
<p>根据上述定义的断言，可以确定结果是否正确，并能够通过 Listener 监听器显示测试的结果。</p>
<h3 id="聚合报告"><a href="#聚合报告" class="headerlink" title="聚合报告"></a>聚合报告</h3><p>将所有的结果进行分析。</p>
<p>包含样本数，平均响应时间，中位数、90%以下、95%以下、99%以下、最小、最大响应时间，错误率，吞吐量等数据。</p>
<p><img src="https://gcore.jsdelivr.net/gh/BlueApong/images@main/img/202407121125863.png" alt="image-20240712112552811"></p>
<h3 id="结果树"><a href="#结果树" class="headerlink" title="结果树"></a>结果树</h3><p>展示每一条请求的具体内容</p>
<p>包括请求头，请求体，响应内容等。</p>
<p><img src="https://gcore.jsdelivr.net/gh/BlueApong/images@main/img/202407121127209.png" alt="image-20240712112700165"></p>
<h2 id="开启测试"><a href="#开启测试" class="headerlink" title="开启测试"></a>开启测试</h2><p>右键线程组，点击 Start 即可开始测试。</p>
<p><img src="https://gcore.jsdelivr.net/gh/BlueApong/images@main/img/202407121129403.png" alt="image-20240712112938357"></p>
<blockquote>
<p>如果点击界面上方的开始按钮，会开始全部的线程组。</p>
</blockquote>
<h1 id="业务测试"><a href="#业务测试" class="headerlink" title="业务测试"></a>业务测试</h1><p>下文以实际多种测试为例，讲解如何进行常用的业务的测试。</p>
<h2 id="登录测试"><a href="#登录测试" class="headerlink" title="登录测试"></a>登录测试</h2><h3 id="创建线程组-1"><a href="#创建线程组-1" class="headerlink" title="创建线程组"></a>创建线程组</h3><p><img src="https://gcore.jsdelivr.net/gh/BlueApong/images@main/img/202407121109288.png" alt="image-20240712110917225"></p>
<p>图中的 Same User… 需要取消勾选，确保每个线程都取不同行的数据</p>
<h3 id="添加-CSV-数据配置"><a href="#添加-CSV-数据配置" class="headerlink" title="添加 CSV 数据配置"></a>添加 CSV 数据配置</h3><p>通过配置数据文件，可以在线程组内通过变量的方式读取文件内的数据。</p>
<p>比如用于 token，session，用户登录账号密码信息 的输入。</p>
<p><img src="https://gcore.jsdelivr.net/gh/BlueApong/images@main/img/202407121112827.png" alt="image-20240712111226038"></p>
<p><strong>参数介绍</strong></p>
<p>Filename：文件路径，也可以是其他文件，只要正确指定分隔符就行。</p>
<p>Variable Names：在 CSV 文件中，通过“,”分隔的列名。</p>
<blockquote>
<p>也可以没有列名，这个变量名只是用来指定根据“分隔符”划分的每一列的名称。</p>
</blockquote>
<p>Ignore first line…：是否忽略文件的第一行</p>
<p>Delimiter：数据之间的分隔符</p>
<p>Recycle on EOF：是否循环读取文件数据</p>
<p>Sharing mode：数据共享模式</p>
<p><strong>注意：</strong>只有取消勾选 Same User… 才会应用这些变量的时候选取不同行的数据</p>
<p><strong>应用变量</strong></p>
<p>通过 ${variables} 的方式，可以在线程组的任意一处应用</p>
<h3 id="创建取样器-1"><a href="#创建取样器-1" class="headerlink" title="创建取样器"></a>创建取样器</h3><p><img src="https://gcore.jsdelivr.net/gh/BlueApong/images@main/img/202407121118584.png" alt="image-20240712111802527"></p>
<p>以上是错误示范：并不满足 JSON 格式。</p>
<p><img src="https://gcore.jsdelivr.net/gh/BlueApong/images@main/img/202407121137971.png"></p>
<p>属性和值必须用双引号包裹</p>
<blockquote>
<p>变量即使为双引号包括，也会正常解析，解析结果其实就相当于一个字面量，</p>
<p>如果和其他字符在一起如：123_${userAccount}</p>
<p>结果会拼接在一起：123_xxxxxxx</p>
</blockquote>
<p>填写好测试的 api 地址，和请求体内容。</p>
<h3 id="定义响应头信息，结果断言。"><a href="#定义响应头信息，结果断言。" class="headerlink" title="定义响应头信息，结果断言。"></a>定义响应头信息，结果断言。</h3><p><img src="https://gcore.jsdelivr.net/gh/BlueApong/images@main/img/202407121120755.png" alt="image-20240712112031704"></p>
<p>保证响应结果能以 JSON 形式解析。</p>
<p><img src="https://gcore.jsdelivr.net/gh/BlueApong/images@main/img/202407121127637.png" alt="image-20240712112755591"></p>
<p>定义结果内容断言：必须要有 code 属性，且值为 0。</p>
<p>添加监听报告省略…</p>
<p>右键线程组点击 Start，即可开始测试。</p>
<p><img src="https://gcore.jsdelivr.net/gh/BlueApong/images@main/img/202407121135198.png" alt="image-20240712113544130"></p>
<h2 id="多人并发测试"><a href="#多人并发测试" class="headerlink" title="多人并发测试"></a>多人并发测试</h2><p>由于多人并发测试，需要用到用户信息，测试并不好办。</p>
<p>所以需要先登录拿到用户信息，再进行接下来的测试。</p>
<h3 id="串行测试（推荐）"><a href="#串行测试（推荐）" class="headerlink" title="串行测试（推荐）"></a>串行测试（推荐）</h3><p>在一个线程组内，创建两个取样器，并勾选 keep-alive 保证 cookie 不会丢失。</p>
<p>第二个取样器就可以基于第一个的用户信息发出请求了</p>
<p><img src="https://gcore.jsdelivr.net/gh/BlueApong/images@main/img/202407121606444.png" alt="image-20240712160616341"></p>
<p>此处就利用登录的 session 信息，进行个人信息的再一步请求。</p>
<h3 id="全局属性"><a href="#全局属性" class="headerlink" title="全局属性"></a>全局属性</h3><p>也可以分开两个线程组，先通过“登录”的取样器发出请求，并添加一系列处理程序来将 session 存储到全局属性中，</p>
<p>再需要用户信息的测试中，再通过获取全局属性的方式来获取到 session，进行请求。</p>
<p>以 Session 为例，</p>
<p>由于 session 的设置包含在响应头里，就需要通过先提取响应头。</p>
<p><strong>添加 正则后置处理器，提取 session 变量</strong></p>
<p><img src="https://gcore.jsdelivr.net/gh/BlueApong/images@main/img/202407121611146.png" alt="image-20240712161134096"></p>
<p>“session” 表示提取出来的变量的名称。</p>
<p><strong>注意：</strong>捕获组从 1 开始，Match No. 表示捕获匹配的哪一句。</p>
<p><strong>添加 BeanShell 处理程序，设置全局属性</strong></p>
<p><img src="https://gcore.jsdelivr.net/gh/BlueApong/images@main/img/202407121613845.png" alt="image-20240712161346797"></p>
<p>Parameters 表示从 CSV 数据配置传来的变量名，</p>
<blockquote>
<p> 大概因为 session 同处于后置处理器环节，所以直接写就可以了。</p>
</blockquote>
<p>通过 <code>$&#123;__setProperty()&#125;</code> 设置全局属性。</p>
<p>将 session 和 userAccount 绑定，存储所有用户的 session 值。</p>
<p><strong>添加 HTTP Cookie 管理器</strong></p>
<p><img src="https://gcore.jsdelivr.net/gh/BlueApong/images@main/img/202407121617412.png" alt="image-20240712161709362"></p>
<p>通过 <code>$(__property(variable_name))</code> 获取全局属性值。</p>
<p>接下来就可以进行测试了，请求会自动携带 cookie 中的 sessionID</p>
]]></content>
      <categories>
        <category>测试</category>
        <category>JMeter</category>
      </categories>
      <tags>
        <tag>JMeter</tag>
        <tag>测试</tag>
        <tag>多人并发</tag>
      </tags>
  </entry>
  <entry>
    <title>240506</title>
    <url>/2024/05/06/240506/</url>
    <content><![CDATA[<h2 id="not选择器"><a href="#not选择器" class="headerlink" title=":not选择器"></a>:not选择器</h2><p>用于选择非xx的元素，如 <code>.btn:not(:nth-child(1))</code> ，在btn类中选择非第一个子元素的其他元素。</p>
<h2 id="Object-fromEntries"><a href="#Object-fromEntries" class="headerlink" title="Object.fromEntries"></a>Object.fromEntries</h2><p>通过传入以 <code>[key, value]</code> 结构为元素的数组，构造出一个整合该数组所有key-value的对象字面量</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> entries = [[<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>], [<span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>]]</span><br><span class="line"><span class="keyword">let</span> obj = <span class="title class_">Object</span>.<span class="title function_">fromEntries</span>(entries)</span><br><span class="line"><span class="comment">// obj: &#123;a:1, b:2&#125;</span></span><br></pre></td></tr></table></figure>



<h2 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys"></a>Object.keys</h2><p>传入一个对象，以数组的形式返回其所有的key</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>:<span class="number">1</span>, <span class="attr">b</span>:<span class="number">2</span>&#125;</span><br><span class="line"><span class="keyword">let</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj)</span><br><span class="line"><span class="comment">// keys: [a, b]</span></span><br></pre></td></tr></table></figure>



<h2 id="vue中click事件函数不传值"><a href="#vue中click事件函数不传值" class="headerlink" title="vue中click事件函数不传值"></a>vue中click事件函数不传值</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;button @click=&quot;handleClick&quot;&gt;&lt;/button&gt;</span><br><span class="line">	&lt;button @click=&quot;handleClick(123)&quot;&gt;&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    methods: &#123;</span><br><span class="line">        handleClick(param) &#123;</span><br><span class="line">            console.log(param)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>相比于react直接传参会立即执行，vue允许声明处理函数时携带参数，因此 <code>handleClick(123)</code> 会输出123</p>
<p>但是，对于这类原生事件<strong>click</strong>，即使声明时没有携带参数，也会默认传入一个事件参数event。</p>
<p>所以 <code>handleClick</code> 这个事件点击后会输出event，而不是undefined。</p>
<h2 id="ApacheEcharts的init方法（在vue中）"><a href="#ApacheEcharts的init方法（在vue中）" class="headerlink" title="ApacheEcharts的init方法（在vue中）"></a>ApacheEcharts的init方法（在vue中）</h2><p>设想：由于图形渲染需要事件，可不可以在created时期，各个属性都创建完成的时候，执行 init 方法呢？</p>
<p>答案：不可以！</p>
<p>原因：因为 init 方法是通过获取dom树上的节点进行再处理的，而created时期并没有渲染完真实dom。</p>
<h2 id="el-form-item单个绑定rules属性"><a href="#el-form-item单个绑定rules属性" class="headerlink" title="el-form-item单个绑定rules属性"></a>el-form-item单个绑定rules属性</h2><p>直接绑定 rules 属性会显示红色<code>*</code>表示这个数据项需要通过验证，但是并不会真实生效。</p>
<p>需要额外指定 prop 属性，因为 rules 本身是通过 el-form 中声明的 model 数据然后找到对应 prop 属性来对这个值进行校验的。</p>
<p>如果不指定 prop，无法捕捉到这个数据项的值，当然无法进行数据验证。</p>
<h2 id="如何将module数据绑定到vue模板"><a href="#如何将module数据绑定到vue模板" class="headerlink" title="如何将module数据绑定到vue模板"></a>如何将module数据绑定到vue模板</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">import * as productStatus from &#x27;@/constants/product&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  computed: &#123;</span><br><span class="line">    productStatus() &#123;</span><br><span class="line">      return productStatus</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>最好绑定只读数据，如果让其可修改，会造成数据干扰。</p>
<h2 id="如何将函数绑定到vue模板中"><a href="#如何将函数绑定到vue模板中" class="headerlink" title="如何将函数绑定到vue模板中"></a>如何将函数绑定到vue模板中</h2><p>在methods体内再声明就可以了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; getFormatTime &#125; from &#x27;@/utils/timeFormatter&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    getFormatTime,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h2 id="如何使用lodash"><a href="#如何使用lodash" class="headerlink" title="如何使用lodash"></a>如何使用lodash</h2><ol>
<li>安装依赖</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install lodash</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>引入lodash</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">&quot;lodash&quot;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">_.<span class="title function_">sort</span>([<span class="number">1</span>,<span class="number">2</span>], <span class="number">3</span>) <span class="comment">// [1,2,3]</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot集成沙箱支付——不墨迹版</title>
    <url>/2024/04/19/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%B2%99%E7%AE%B1%E6%94%AF%E4%BB%98/</url>
    <content><![CDATA[<h1 id="SpringBoot集成沙箱支付——不墨迹版"><a href="#SpringBoot集成沙箱支付——不墨迹版" class="headerlink" title="SpringBoot集成沙箱支付——不墨迹版"></a>SpringBoot集成沙箱支付——不墨迹版</h1><h3 id="一、获取沙箱配置信息"><a href="#一、获取沙箱配置信息" class="headerlink" title="一、获取沙箱配置信息"></a>一、获取沙箱配置信息</h3><p>先进入支付宝的个人沙箱应用页面 <a href="https://openhome.alipay.com/develop/sandbox/app">https://openhome.alipay.com/develop/sandbox/app</a></p>
<p><img src="/assets/1685079849346-0bb2ef6b-3ea3-48ed-bc39-81aa22bd7f1b.png" alt="image.png"></p>
<p><img src="/assets/image-20240419143841824.png" alt="image-20240419143841824"></p>
<p>图中 <strong>黑色框框</strong> 圈出来的我们需要的四个配置信息。</p>
<blockquote>
<p>以下步骤省略创建 Spring Boot 项目过程。</p>
<p>教程采用版本：</p>
<ul>
<li>spring boot 2.6.13</li>
<li>java 8</li>
</ul>
</blockquote>
<h3 id="二、在-pom-xml-中引入支付宝SDK依赖"><a href="#二、在-pom-xml-中引入支付宝SDK依赖" class="headerlink" title="二、在 pom.xml 中引入支付宝SDK依赖"></a>二、在 pom.xml 中引入支付宝SDK依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- alipay --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alipay.sdk<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>alipay-sdk-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.34.0.ALL<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>经监测，开源的Java开发组件Fastjson存在远程代码执行漏洞，攻击者可利用上述漏洞远程执行任意代码。Java SDK（alipay-sdk-java）在4.34.0版本之前使用了存在漏洞的Fastjson版本（详情可查看 <a href="https://opendocs.alipay.com/rules/03f7dr">关于Fastjson漏洞预警的公告</a>）。</p>
<p>建议将上述SDK升级至 4.34.0 及以上版本</p>
<p>——摘自<a href="https://opendocs.alipay.com/common/02kkv2?pathHash=358ff034">官方文档</a></p>
</blockquote>
<h3 id="三、往-application-yml-中写入第一步获取到的配置信息"><a href="#三、往-application-yml-中写入第一步获取到的配置信息" class="headerlink" title="三、往 application.yml 中写入第一步获取到的配置信息"></a>三、往 application.yml 中写入第一步获取到的配置信息</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 支付宝沙箱</span></span><br><span class="line"><span class="attr">myalipay:</span></span><br><span class="line">    <span class="attr">gateway:</span> 			<span class="comment"># 支付宝网关地址</span></span><br><span class="line">    <span class="attr">appId:</span> 				<span class="comment"># 填入APPID</span></span><br><span class="line">    <span class="attr">appPrivateKey:</span>  	<span class="comment"># 填入Java应用私钥</span></span><br><span class="line">    <span class="attr">alipayPublicKey:</span>   	<span class="comment"># 填入应用公钥</span></span><br></pre></td></tr></table></figure>



<h3 id="四、编写-AlipayConfig-沙箱支付配置类"><a href="#四、编写-AlipayConfig-沙箱支付配置类" class="headerlink" title="四、编写 AlipayConfig 沙箱支付配置类"></a>四、编写 AlipayConfig 沙箱支付配置类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.alipaysandboxdemo.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alipay.api.DefaultAlipayClient;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 沙箱支付配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(&quot;myalipay&quot;)</span>	<span class="comment">// 第三步中yml配置的前缀</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AlipayConfig</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 沙箱支付网关</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String gateway;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 应用Id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String appId;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 应用私钥</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String appPrivateKey;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 支付宝公钥</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String alipayPublicKey;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 参数返回格式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">FORMAT</span> <span class="operator">=</span> <span class="string">&quot;JSON&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编码方式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CHARSET</span> <span class="operator">=</span> <span class="string">&quot;UTF-8&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 签名方式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SIGN_TYPE</span> <span class="operator">=</span> <span class="string">&quot;RSA2&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DefaultAlipayClient <span class="title function_">defaultAlipayClient</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultAlipayClient</span>(</span><br><span class="line">                gateway,</span><br><span class="line">                appId,</span><br><span class="line">                appPrivateKey,</span><br><span class="line">                FORMAT,</span><br><span class="line">                CHARSET,</span><br><span class="line">                alipayPublicKey,</span><br><span class="line">                SIGN_TYPE</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上述代码可见，向 AlipayConfig 类注入了第三步中写入的配置信息，并创建了一个 DefaultAlipayClient 的 Bean，后续沙箱支付的操作基本都使用 DefaultAlipayClient 完成。</p>
<h3 id="五、编写沙箱支付相关接口"><a href="#五、编写沙箱支付相关接口" class="headerlink" title="五、编写沙箱支付相关接口"></a>五、编写沙箱支付相关接口</h3><p>在编写接口请求之前，需要知道一件事：</p>
<p><strong>在服务器通过沙箱支付成功后，支付宝会发出一个携带本次支付相关信息参数的请求，通知该服务器</strong></p>
<p>服务器：这里指本地的 Springboot 后端程序</p>
<p>既然是请求，就需要给它提供一个接口访问，让它能够把本次支付信息传过来。</p>
<p><strong>问题是：</strong>支付宝发出的请求只能访问外网的地址，而在本地的 tomcat 服务器属于内网。</p>
<p>因此需要通过使用 <strong>内网穿透</strong> 工具获取一个临时的公网域名，让支付宝能够正常访问到。</p>
<h4 id="内网穿透"><a href="#内网穿透" class="headerlink" title="内网穿透"></a>内网穿透</h4><p><strong>这里使用 <a href="https://natapp.cn/">netapp</a> 搭建</strong></p>
<p><img src="/assets/image-20240419154343084.png" alt="image-20240419154343084"></p>
<p><strong>netapp 官方教程：</strong><a href="https://natapp.cn/article/natapp_newbie">https://natapp.cn/article/natapp_newbie</a></p>
<p><strong>&#x3D;&#x3D;注意：隧道对应的本地端口应改为自己的 Spring Boot 项目启动端口&#x3D;&#x3D;</strong></p>
<p><img src="/assets/image-20240419154814353.png" alt="image-20240419154814353"></p>
<p>如果忘记改了，也可以自己在 “我的隧道” 那里配置刚才创建的隧道</p>
<p>运行成功后，得到如下界面：</p>
<p><img src="/assets/image-20240419160102998.png" alt="image-20240419160102998"></p>
<p>&#x3D;&#x3D;注意：圈出来的是临时域名，每次重新运行都会更改，应该保证代码里写的是最新的域名&#x3D;&#x3D;</p>
<h4 id="编写-AlipayController-类"><a href="#编写-AlipayController-类" class="headerlink" title="编写 AlipayController 类"></a>编写 AlipayController 类</h4><p>为了省事，业务逻辑全部写在 Controller 中了，读者可自行分层封装，降低代码耦合。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.alipaysandboxdemo.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSONObject;</span><br><span class="line"><span class="keyword">import</span> com.alipay.api.AlipayApiException;</span><br><span class="line"><span class="keyword">import</span> com.alipay.api.DefaultAlipayClient;</span><br><span class="line"><span class="keyword">import</span> com.alipay.api.internal.util.AlipaySignature;</span><br><span class="line"><span class="keyword">import</span> com.alipay.api.request.AlipayTradePagePayRequest;</span><br><span class="line"><span class="keyword">import</span> com.alipay.api.request.AlipayTradeRefundRequest;</span><br><span class="line"><span class="keyword">import</span> com.alipay.api.response.AlipayTradeRefundResponse;</span><br><span class="line"><span class="keyword">import</span> com.example.alipaysandboxdemo.config.AlipayConfig;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/alipay&quot;)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AlipayController</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 沙箱支付配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> AlipayConfig alipayConfig;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 沙箱支付代理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> DefaultAlipayClient defaultAlipayClient;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 支付成功通知地址</span></span><br><span class="line"><span class="comment">     * todo: 确保更改为最新域名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NOTIFY_PATH</span> <span class="operator">=</span> <span class="string">&quot;http://eiabc3.natappfree.cc&quot;</span> + <span class="string">&quot;/alipay/notify&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 支付</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tradeNo   交易单号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> amount    商品名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/pay&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">alipay</span><span class="params">(String tradeNo, Double amount)</span> &#123;</span><br><span class="line">        <span class="comment">// 封装支付请求体</span></span><br><span class="line">        <span class="type">AlipayTradePagePayRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AlipayTradePagePayRequest</span>();</span><br><span class="line">        <span class="comment">// json请求体</span></span><br><span class="line">        <span class="type">JSONObject</span> <span class="variable">bizContent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>();</span><br><span class="line">        <span class="comment">// 交易单号</span></span><br><span class="line">        bizContent.put(<span class="string">&quot;out_trade_no&quot;</span>, tradeNo);</span><br><span class="line">        <span class="comment">// 商品名称</span></span><br><span class="line">        bizContent.put(<span class="string">&quot;subject&quot;</span>, <span class="string">&quot;遥遥领先 华为meta60&quot;</span>);</span><br><span class="line">        <span class="comment">// 交易金额</span></span><br><span class="line">        bizContent.put(<span class="string">&quot;total_amount&quot;</span>, amount);</span><br><span class="line">        <span class="comment">// 沙箱支付环境唯一配置</span></span><br><span class="line">        bizContent.put(<span class="string">&quot;product_code&quot;</span>, <span class="string">&quot;FAST_INSTANT_TRADE_PAY&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置支付宝通知地址</span></span><br><span class="line">        request.setNotifyUrl(NOTIFY_PATH);</span><br><span class="line">        request.setBizContent(bizContent.toString());</span><br><span class="line">        <span class="comment">// 支付</span></span><br><span class="line">        String formPage;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            formPage = defaultAlipayClient.pageExecute(request).getBody();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AlipayApiException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;订单支付异常：&quot;</span> + tradeNo, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 渲染页面</span></span><br><span class="line">        <span class="keyword">return</span> formPage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 支付成功通知接口</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/notify&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> AlipayApiException &#123;</span><br><span class="line">        <span class="comment">// 除了以下三个参数外，还有其他参数，可自行debug查看</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">tradeStatus</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;trade_status&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">tradeNo</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;out_trade_no&quot;</span>);</span><br><span class="line">        <span class="type">Double</span> <span class="variable">amount</span> <span class="operator">=</span> Double.valueOf(request.getParameter(<span class="string">&quot;total_amount&quot;</span>));</span><br><span class="line">        <span class="keyword">if</span> (!<span class="string">&quot;TRADE_SUCCESS&quot;</span>.equals(tradeStatus)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;订单支付失败：&quot;</span> + tradeNo);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 验签</span></span><br><span class="line">        Map&lt;String, String&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String name : request.getParameterMap().keySet()) &#123;</span><br><span class="line">            params.put(name, request.getParameter(name));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> AlipaySignature.getSignCheckContentV1(params);</span><br><span class="line">        <span class="type">String</span> <span class="variable">alipayPublicKey</span> <span class="operator">=</span> alipayConfig.getAlipayPublicKey();</span><br><span class="line">        <span class="type">String</span> <span class="variable">sign</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;sign&quot;</span>);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">check</span> <span class="operator">=</span> AlipaySignature.rsa256CheckContent(content, sign, alipayPublicKey, AlipayConfig.CHARSET);</span><br><span class="line">        <span class="keyword">if</span> (!check) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;订单验签异常：&quot;</span> + tradeNo);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 验签成功后，保存订单...</span></span><br><span class="line">        System.out.println(<span class="string">&quot;订单支付成功：&quot;</span> + tradeNo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 退款</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tradeNo   交易单号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> amount    商品名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/refund&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refund</span><span class="params">(String tradeNo, Double amount)</span> <span class="keyword">throws</span> AlipayApiException &#123;</span><br><span class="line">        <span class="comment">// 封装退款请求体</span></span><br><span class="line">        <span class="type">AlipayTradeRefundRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AlipayTradeRefundRequest</span>();</span><br><span class="line">        <span class="type">JSONObject</span> <span class="variable">bizContent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>();</span><br><span class="line">        bizContent.put(<span class="string">&quot;out_trade_no&quot;</span>, tradeNo);</span><br><span class="line">        bizContent.put(<span class="string">&quot;refund_amount&quot;</span>, amount);</span><br><span class="line">        request.setBizContent(bizContent.toString());</span><br><span class="line">        <span class="comment">// 退款</span></span><br><span class="line">        <span class="type">AlipayTradeRefundResponse</span> <span class="variable">response</span> <span class="operator">=</span> defaultAlipayClient.execute(request);;</span><br><span class="line">        <span class="keyword">if</span> (!response.isSuccess()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;订单退款失败：&quot;</span> + tradeNo);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 保存退款信息...</span></span><br><span class="line">        System.out.println(<span class="string">&quot;订单退款成功：&quot;</span> + tradeNo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>前后端分离</strong></p>
<p> &#x2F;alipay&#x2F;pay 支付接口返回的 formPage 实际上是一个 <strong>HTML片段</strong>，支付宝将我们发出的支付请求参数封装成了一个 <strong>form表单</strong> 并通过 <strong>script脚本</strong> 立即执行，用于跳转支付宝支付页面（需要联网）。</p>
<p>这里由于标注了 <code>@RestController</code> 注解，所以直接访问该接口直接渲染成一个页面。</p>
<p>如果你的项目是前后端分离，可以采用如下操作：</p>
<ol>
<li><p>将返回的 formPage 字符串数据插入到页面中，并切割掉 script脚本 手动执行。</p>
<blockquote>
<p><code>&lt;script&gt;form[0].submit()&lt;/script&gt;</code></p>
<p>因为 script脚本 默认执行页面中的第一个表单。</p>
</blockquote>
</li>
<li><p>搭建 iframe 容器，插入 formPage。</p>
</li>
</ol>
<h3 id="六、测试"><a href="#六、测试" class="headerlink" title="六、测试"></a>六、测试</h3><h4 id="测试支付接口"><a href="#测试支付接口" class="headerlink" title="测试支付接口"></a>测试支付接口</h4><p>这里的账号和密码是沙箱环境中的 <a href="https://openhome.alipay.com/develop/sandbox/account">沙箱账号</a></p>
<blockquote>
<p> <a href="http://localhost:8101/alipay/pay?tradeNo=1772919741251236385&amount=888">http://localhost:8101/alipay/pay?tradeNo=1772919741251236385&amp;amount=888</a></p>
</blockquote>
<p><img src="/assets/image-20240419163200727.png" alt="image-20240419163200727"></p>
<p><img src="/assets/image-20240419164512715.png" alt="image-20240419164512715"></p>
<p>支付完成后，支付宝发出通知到指定地址：</p>
<p><img src="/assets/image-20240419164607599.png" alt="image-20240419164607599"></p>
<h4 id="测试退款接口"><a href="#测试退款接口" class="headerlink" title="测试退款接口"></a>测试退款接口</h4><p>将刚刚支付的订单退款：</p>
<blockquote>
<p><a href="http://localhost:8101/alipay/refund?tradeNo=1772919741251236385&amount=888">http://localhost:8101/alipay/refund?tradeNo=1772919741251236385&amp;amount=888</a></p>
</blockquote>
<p><img src="/assets/image-20240419164750328.png" alt="image-20240419164750328"></p>
]]></content>
      <categories>
        <category>沙箱支付</category>
        <category>教程</category>
      </categories>
      <tags>
        <tag>沙箱支付</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Java多线程、SortedSet</title>
    <url>/2024/04/12/240412/</url>
    <content><![CDATA[<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p><strong>线程协调</strong></p>
<p>有时候因为业务逻辑的关系，代码之间是相互制约的，如果随意加锁就会导致死锁or逻辑死锁。</p>
<p>因此就需要借助 wait 和 notify 来完成一些配合操作。</p>
<p><strong>死锁</strong></p>
<p>多个服务需要同时获取多把锁，如果不同服务获取的锁出现交叉问题，就会造成死锁。</p>
<p>如：</p>
<ol>
<li>阻塞读 —— 写，自身交叉，没写就读不到，造成逻辑死锁</li>
<li>业务交叉，A 获取 A 锁，B 获取 B 锁，此时如果 A 需要获取 B 锁，B 又需要获取 A 锁，就会顺序交叉，同样造成物理死锁。</li>
</ol>
<p><strong>限流</strong></p>
<p>通过 Semaphore 信号量限制 acquire 的线程数。</p>
<p><strong>线程池</strong></p>
<p>因为创建新的线程，需要额外的开销。</p>
<p>如果一个线程执行完后让其释放，而后执行另一个任务又另起线程，这一创建和释放就会白耗很多性能。</p>
<p>因此就需要借助线程池，对执行完的线程进行回收，需要用到时再从线程池内取，减少了创建新线程的开销。</p>
<p><strong>CompletableFuture</strong></p>
<p>对 Future 异步执行返回结果的操作进行优化，可以在 complete 和 exception 时传入回调操作自动执行。</p>
<p>同时还支持多线程下的串行执行（单个 then），并行执行（any -&gt; 多个then），以及综合起来执行（any -&gt; 多个then）。</p>
<h1 id="点赞功能"><a href="#点赞功能" class="headerlink" title="点赞功能"></a>点赞功能</h1><p><strong>用户对同一篇笔记点赞和取消点赞</strong></p>
<p>实现：</p>
<ol>
<li><p>先判断该用户是否已点赞</p>
<p>从 Redis 的 SortedSet中调用score查询，如果没有分数，则表示该用户未点赞</p>
</li>
<li><p>未点赞</p>
<ol>
<li>MySQL 自增 liked 字段</li>
<li>加入 SortedSet 中，并将 score 设置为当前时间戳</li>
</ol>
</li>
<li><p>已点赞</p>
<ol>
<li>MySQL 自减 liked 字段</li>
<li>从 SortedSet 中移除</li>
</ol>
</li>
</ol>
<p>存在问题：</p>
<ol>
<li>并发，同时多个线程绕过点赞判断，出现一个用户对同一篇笔记多次点赞</li>
</ol>
<p><strong>显示点赞效果</strong></p>
<p>实现：</p>
<ol>
<li>给实体类添加 isLike 属性</li>
<li>从 redis 中查询 score</li>
</ol>
<p><strong>点赞显示的对象按时间先后排列</strong></p>
<p>实现：</p>
<ol>
<li>从 Redis 中按 ZRANGE 查询（升序：时间先后）</li>
<li>查询 MySQL 用户信息</li>
<li>限制 MySQL 返回结果排列 ORDER BY FIELD(“id”, id1, id2)</li>
<li>返回脱敏用户信息</li>
</ol>
]]></content>
      <categories>
        <category>Redis</category>
        <category>Java</category>
        <category>多线程</category>
        <category>锁</category>
      </categories>
      <tags>
        <tag>锁</tag>
        <tag>Java</tag>
        <tag>线程池</tag>
        <tag>CompletableFuture</tag>
        <tag>信号量</tag>
      </tags>
  </entry>
  <entry>
    <title>Transactional注解、Java工作路径、Paths类</title>
    <url>/2024/04/11/240411/</url>
    <content><![CDATA[<h1 id="Transactional-事务代理失效问题"><a href="#Transactional-事务代理失效问题" class="headerlink" title="@Transactional 事务代理失效问题"></a>@Transactional 事务代理失效问题</h1><p>在Spring中是通过aop增强对@Transactional注解标注的方法进行事务代理的。</p>
<p>但是如果通过 this 调用该方法，那么这个注解就会失效，也就是事务代理失效。</p>
<p><strong>原因：</strong> </p>
<p>aop的实现原理是在管理的bean中匹配切入点，然后对bean执行的方法进行增强。</p>
<p>而通过 this 调用，这个 this 是不被 Spring 管理的，如何找到它并且匹配切入点呢？？</p>
<p>简而言之，只有当该方法是被 Spring 的代理对象执行时，aop增强才会生效。</p>
<p><strong>事务加入问题</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Class Test &#123;</span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">proxyFunc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dbOperation1();</span><br><span class="line">        <span class="built_in">this</span>.dbOperation2();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 数据库操作1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dbOperation1</span><span class="params">()</span> &#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 数据库操作2</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dbOperation2</span><span class="params">()</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中存在一个被代理对象调用并标注 <code>@Transactional</code> 注解的 <code>proxyFunc</code> 方法，其内部通过 this 指针调用了两个数据库操作。</p>
<p><strong>这里的两个数据库操作会加入 proxyFunc 的事务吗？</strong></p>
<p>答案：会。</p>
<p>原因：因为 proxyFunc 已经被 @Transactional 增强了，开启了事务，那么其内部所有的数据库操作都会加入这个事务。</p>
<p><strong>事务冒泡问题</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Class Test &#123;</span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">proxyFunc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dbOperation1();</span><br><span class="line">        <span class="built_in">this</span>.dbOperation2();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 数据库操作1</span></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.NOT_SUPPORTED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dbOperation1</span><span class="params">()</span> &#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 数据库操作2</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dbOperation2</span><span class="params">()</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还是一样的代码，不过这次给数据库操作1标注了 <code>@Transactional(propagation = Propagation.NOT_SUPPORTED)</code> 不支持事务的注解，也表示不会加入其他事务。</p>
<p><strong>那么这个注解会生效吗？</strong></p>
<p>答案：不会</p>
<p>原因：因为数据库操作1是通过 this 调用的，而不是 proxy 代理对象，不会被aop“增强”，也就是注解失效！</p>
<p>不是最外层是 proxy 代理的，内部就都是它代理，可以回想一下 aop 增强的实现代码，本质是在目标方法的外层再包装一层逻辑，所以这个 proxy 只会包装最外层的注解增强代码，无法处理内部。</p>
<p><strong>那事务冒泡配置注解什么时候使用呢？</strong></p>
<p>可以在其他 service 的代码中使用，通过注入其代理对象，然后使用目标方法，这时候由于是 proxy 代理的，注解就会正常生效。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Class OtherService &#123;</span><br><span class="line">    <span class="comment">// 数据库操作1</span></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.NOT_SUPPORTED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dbOperation1</span><span class="params">()</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Class Test &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> OtherService otherService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">proxyFunc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 不支持事务注解正常生效</span></span><br><span class="line">        otherService.dbOperation1();</span><br><span class="line">        <span class="built_in">this</span>.dbOperation2();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 数据库操作2</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dbOperation2</span><span class="params">()</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如果需要分离方法体单独封装，又不能通过 this 调用，该如何保证目标方法事务生效呢</strong></p>
<p>答案：手动获取代理对象，然后通过代理对象调用目标方法；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Class TestService &#123;</span><br><span class="line">    <span class="comment">// 调用入口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">calledFunc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 需要引入 aspectjweaver aop依赖，并且开启 exposeProxy </span></span><br><span class="line">        (TestService) proxy = (TestService) AopContext.currentProxy();</span><br><span class="line">        proxy.sealedDBOperation();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 封装数据库操作</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sealedDBOperation</span><span class="params">()</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="获取工作目录根路径"><a href="#获取工作目录根路径" class="headerlink" title="获取工作目录根路径"></a>获取工作目录根路径</h1><p>通过 System 方法获取环境属性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">rootWorkPath</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;user.dir&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>拼接其他路径</strong></p>
<p>使用 <code>java.nio.file</code> 下的 <code>Paths</code> 工具类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(rootWorkPath, <span class="string">&quot;path1&quot;</span>, <span class="string">&quot;path2 ...&quot;</span>)</span><br></pre></td></tr></table></figure>



<h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><p>不可变对象也是线程安全的。</p>
<p>如 List、String 等。</p>
<p>但是引用提升至 List 的 ArrayList 实例同样是线程不安全的。</p>
<p>异步下，对 ArrayList 的插入操作，会导致 length 和 列表元素 出现错乱。</p>
<p><strong>为什么大部分类都是线程不安全的？</strong></p>
<p>因为线程安全会影响性能，应交由开发者自由控制。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>事务</tag>
        <tag>this调用失效</tag>
        <tag>工作路径</tag>
        <tag>Paths</tag>
        <tag>线程安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis的Stream消息队列应用</title>
    <url>/2024/04/07/240407/</url>
    <content><![CDATA[<h1 id="熟悉Stream"><a href="#熟悉Stream" class="headerlink" title="熟悉Stream"></a>熟悉Stream</h1><h2 id="独立消费者"><a href="#独立消费者" class="headerlink" title="独立消费者"></a>独立消费者</h2><p><strong>发布消息</strong></p>
<p><code>XADD KEY [NOMKSTREAM] *|ID field value [field value ...] </code></p>
<p>添加一条消息到 key 的队列中去，如果不存在则创建队列</p>
<p>*：自动生成id</p>
<p>ID：自定义id，需遵循时间戳-序号的格式</p>
<p>field，value：消息键值对，允许一条消息有多个键值对，类似hash</p>
<p>NOMKSTREAM：如果队列不存在，不会创建</p>
<p><strong>订阅消息</strong></p>
<p><code>XREAD COUNT count BLOCK milliseconds STREAMS key [key ...] ID [ID ...]</code></p>
<p>可以从多个stream中读取从ID往后的count条消息，如果暂时没有则等待xx毫秒</p>
<p>COUNT：读取数量</p>
<p>BLOCK：等待时间</p>
<p>ID：消息起始ID，可以传特殊值 0：第一个，$：最新消息。</p>
<blockquote>
<p>$：是最新消息，返回开启了阻塞等待后的第一条消息，存在漏读的问题，往后的二三条都读不到，如果COUNT为1。</p>
</blockquote>
<p><strong>特点</strong></p>
<ol>
<li>消息可以追溯，不是读完就消失了</li>
<li>一条消息可以被多个消费者读取</li>
<li>可以阻塞读取</li>
<li>有消息漏读的风险</li>
</ol>
<h2 id="消费者组"><a href="#消费者组" class="headerlink" title="消费者组"></a><strong>消费者组</strong></h2><p>将消息和消费者分组，每一组的消息由组内的消费者消费</p>
<p>特点：</p>
<ol>
<li>消息分流，同组的信息由多个消费者同时处理</li>
<li>消息标识，消费者组会维护一个标识，记录着最后一个被处理的消息，确保每次读取未处理的</li>
<li>消息确认，如果被读取的消息没有确认完成，会存在每个消费者的pending-list，供每个消费者继续消费。</li>
</ol>
<h3 id="创建消费者组"><a href="#创建消费者组" class="headerlink" title="创建消费者组"></a>创建消费者组</h3><p><code>XGROUP CREATE key groupName MKSTREAM</code></p>
<p>给stream创建一个消费者组，如果Stream不存在则自动创建</p>
<p>key：队列的key</p>
<p>groupName：消费者组名</p>
<p>MKSTREAM：自动创建队列</p>
<h3 id="消费者组读取消息"><a href="#消费者组读取消息" class="headerlink" title="消费者组读取消息"></a>消费者组读取消息</h3><p><code>XREADGROUP GROUP group consumer COUNT count BLOCK mills STREAMS key ID</code></p>
<p>先写命令 <code>XREADGROUP GROUP</code>，再写 <code>group consumer</code> 组名和消费者名，再写读取数量和等待时间，最后写队列key和起始消息ID</p>
<p>ID有两类特殊值：</p>
<ol>
<li>“&gt;”，从下一个未消费的消息开始</li>
<li>其他：从各自消费者的pending-list中取，例如0，表示list中的第一个消息。</li>
</ol>
<h3 id="确认消息"><a href="#确认消息" class="headerlink" title="确认消息"></a>确认消息</h3><p>xack </p>
<h1 id="异步秒杀应用Stream消息队列"><a href="#异步秒杀应用Stream消息队列" class="headerlink" title="异步秒杀应用Stream消息队列"></a>异步秒杀应用Stream消息队列</h1><p>准备工作：</p>
<ol>
<li>创建消费者组，自动创建队列</li>
</ol>
<p>书写lua代码：</p>
<ol>
<li>判断是否有秒杀资格</li>
<li>如果有则加入消息队列</li>
</ol>
<p>书写Java代码：</p>
<ol>
<li>持续监听下单消息</li>
<li>取出下单消息 xreadgroup</li>
<li>如果不存在，则继续监听</li>
<li>如果处理失败，就转入pending-list处理</li>
<li>取出待处理消息 xreadgroup</li>
<li>如果处理失败，继续取出处理，直到处理完毕</li>
<li>最后确认消息 xack streamKey groupName messageId</li>
</ol>
]]></content>
      <categories>
        <category>Redis</category>
        <category>Stream</category>
      </categories>
      <tags>
        <tag>Redis Stream</tag>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础</title>
    <url>/2024/04/03/Java-Common/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>Java是基于jvm虚拟机运行的跨平台语言</li>
<li>内置垃圾收集，不用考虑内存管理</li>
</ul>
<h3 id="JRE-和-JDK-介绍"><a href="#JRE-和-JDK-介绍" class="headerlink" title="JRE 和 JDK 介绍"></a>JRE 和 JDK 介绍</h3><p><strong>JRE：</strong> 用于运行 被编译为字节码class 的 Java 代码</p>
<p><strong>JDK：</strong>提供编译器，调试器等用于编写 Java 代码工具</p>
<blockquote>
<p>JRE: Java Runtime Environment</p>
<p>JDK: Java Development Kit</p>
</blockquote>
<p><strong>命令行常用命令</strong></p>
<ul>
<li>Java: 启动jvm虚拟机，运行编译为class字节码的代码。</li>
<li>Javac: 编译Java代码</li>
<li>Javadoc: 注释文档</li>
<li>jdb: 调试器</li>
</ul>
<p><strong>JDK与JRE的关系</strong></p>
<p>JDK &#x3D; JRE + 开发工具（Javac.exe等）</p>
<p>JRE &#x3D; JVM + Java API</p>
<blockquote>
<p>开发程序，需要用到JDk，因为要用Javac编译.Java文件</p>
<p>运行程序，只需要用到JRE，包含了Java API</p>
</blockquote>
<h3 id="名词介绍"><a href="#名词介绍" class="headerlink" title="名词介绍"></a>名词介绍</h3><ol>
<li>JSR规范: Java Specification Request</li>
<li>JCP组织: Java Community Process</li>
</ol>
<blockquote>
<p> JSR规范用于保证 Java 语言的规范性。</p>
<p> 凡是想给 Java 平台添加一个功能，比如说访问数据库的功能，需要先创建一个 JSR规范，定义好接口。</p>
<p> 各个数据库平台必须按照规范实现该接口，开发者就用同样的API访问各个数据库平台。</p>
</blockquote>
<ol start="5">
<li>RI: Reference Implementation</li>
<li>TCK: Technology Compability Kit</li>
<li>IDE: Integrated Development Environment</li>
</ol>
<h2 id="语法规则"><a href="#语法规则" class="headerlink" title="语法规则"></a>语法规则</h2><h3 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h3><ul>
<li>变量、类名 必须以英文字母开头，后接字母，数字和下划线的组合</li>
<li>**类名 **习惯首字母大写</li>
<li>如果单个源文件中有多个类，那么只能有一个类是public类，表示该文件的主入口</li>
</ul>
<blockquote>
<p>在java编程思想（第四版）一书中有这样3段话（6.4 类的访问权限）：</p>
<p>每个编译单元（文件）都只能有一个public类，使得每个编译单元都有单一的公共接口，用public类来表现。该接口可以按要求包含众多的 支持包访问权限 的类。</p>
<p>如果在某个编译单元内有一个以上的public类，就不知道使用哪个类导致无法编译。</p>
<p>同时允许编译单元内完全不带public类，这时候可能会并入其他编译单元编译，并且启动该文件时需手动指定数据来源（文件内存在的多个class）</p>
</blockquote>
<ul>
<li>源文件的名字必须与 public 类的类名相同</li>
<li>如果源文件中没有 public 类，则文件名可以是任意的</li>
</ul>
<h3 id="Hello-world分析"><a href="#Hello-world分析" class="headerlink" title="Hello world分析"></a>Hello world分析</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>main方法必须声明为静态方法，作为程序执行入口</li>
<li>在书写完Java文件后，使用Javac命令编译源文件</li>
</ul>
<blockquote>
<p>  javac -encoding&#x3D;utf-8 Hello.java</p>
<p>  如果文件编码非utf-8需使用encoding选项指定编码格式</p>
</blockquote>
<ul>
<li>运行代码</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java Hello <span class="comment"># 不需要带.class扩展名</span></span><br></pre></td></tr></table></figure>



<h3 id="主类"><a href="#主类" class="headerlink" title="主类"></a>主类</h3><p>Java程序的执行入口是main方法，&#x3D;&#x3D;包含有main方法的类称为主类&#x3D;&#x3D;</p>
<ul>
<li>一个Java源文件中可以有零个或多个主类。</li>
</ul>
<blockquote>
<p>  假如一个Java文件中有3个类，则在编译后会生成3个class文件</p>
<p>  只有包含main方法的主类才能使用Java命令运行</p>
</blockquote>
<ul>
<li>如果程序中包含主类，则称为Java应用程序。没有就叫做Java库程序，通常被用来让其他Java程序调用.</li>
</ul>
<h3 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h3><blockquote>
<p>从源代码到可执行代码，称为编译，也称为正向工程。</p>
<p>从可执行代码到源代码，称为反编译，也称为逆向工程。</p>
</blockquote>
<p>可用 javap命令实现反编译。</p>
<blockquote>
<p> 但并没有实现完全的反编译，只反编译到<strong>方法声明</strong>这一层，<u>无法反编译方法内的代码。</u></p>
</blockquote>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><ol>
<li>&#x2F;&#x2F;…          单行注释</li>
<li>&#x2F;* … *&#x2F;   多行注释</li>
<li>&#x2F;** … *&#x2F; 文档注释</li>
</ol>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ol>
<li>整数类型：byte，short，int，long</li>
<li>浮点数类型：float，double</li>
<li>字符类型：char</li>
<li>布尔类型： boolean</li>
</ol>
<blockquote>
<p>只有 true 和 false 两个值。</p>
<p>Java语言对布尔类型的存储并没有做规定。</p>
<p>理论上存储布尔类型只需要1 bit，但是通常 JVM 内部会把boolean表示为4字节整数&#x3D;&#x3D;。</p>
</blockquote>
<ol start="5">
<li><u>引用类型</u>，类似如C语言的指针。</li>
</ol>
<blockquote>
<p>在Java中，对象的实例化变量常为引用类型</p>
</blockquote>
<ol start="6">
<li><p>常量，使用final关键字声明。</p>
</li>
<li><p>var关键字</p>
<p>当类型名太长可以用var来进行声明，编译器会根据赋值语句来自动推断出该变量的类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>特殊规则</strong></p>
<ul>
<li>Java只定义了带符号的整型，即最高位为符号位。如，<u>int 最大值为 2^31-1</u></li>
<li>支持使用 _ 来连接数字，结果和原数一致。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">2_000</span>;</span><br><span class="line">System.out.println(x);</span><br><span class="line"><span class="comment">// 输出: 2000</span></span><br></pre></td></tr></table></figure>

<ul>
<li>0前缀表示八进制</li>
<li>0x前缀表示十六进制</li>
<li>0b前缀表示二进制</li>
<li>long类型需在数字后加上字母大小写 “L”</li>
<li><strong>定义float类型变量时末尾一定要加上字母大小写”F”，因为默认浮点数为双精度（double）类型</strong></li>
</ul>
<h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ol>
<li><p><code>/</code> 除法运算符</p>
</li>
<li><p><code>%</code> 求余运算符</p>
</li>
<li><p><code>&gt;&gt;</code> 右移运算符，无法移动符号位，即负数右移后还是负数</p>
</li>
<li><p><code>&gt;&gt;&gt;</code> 可以移动符号位的右移运算符</p>
</li>
<li><p><code>&lt;&lt;</code> 左移运算符同理，不存在向左移动符号位的运算符。</p>
<blockquote>
<p>对<code>byte</code>和<code>short</code>类型进行移位时，会首先转换为<code>int</code>再进行位移。</p>
</blockquote>
</li>
<li><p><code>++</code>，<code>--</code> 自增自减运算符只能用于 整型 和 浮点型 变量。</p>
</li>
<li><p><code>instanceof</code> 运算符，判断前者是否为后者的实例化对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">a <span class="keyword">instanceof</span> Integer; <span class="comment">//得到true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>位运算：<code>&amp;</code>，<code>|</code>，<code>~</code>，<code>^</code> 分别是与，或，非，异或运算。</p>
</li>
<li><p>逻辑运算符：<code>&amp;&amp;</code>，<code>||</code>，<code>！</code> 的操作元必须是boolean型数据。</p>
</li>
</ol>
<h3 id="整数运算"><a href="#整数运算" class="headerlink" title="整数运算"></a>整数运算</h3><ol>
<li>两个整数相除只能得到结果的整数部分（即舍弃余数得到整数）</li>
<li>整数的除法对于除数为0时运行时将报错，但编译不会报错。</li>
</ol>
<p><strong>溢出：</strong></p>
<p>整数由于存在范围限制，如果计算结果超出了范围，就会产生溢出，而溢出<em>不会出错</em>，却会得到一个奇怪的结果。（占据符号位，成为负数）</p>
<h3 id="浮点数运算"><a href="#浮点数运算" class="headerlink" title="浮点数运算"></a>浮点数运算</h3><p><strong>浮点数比较正确做法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">r</span> <span class="operator">=</span> Math.abs(x - y); <span class="comment">// 取绝对值</span></span><br><span class="line"><span class="comment">// 精度范围</span></span><br><span class="line"><span class="keyword">if</span> (r &lt; <span class="number">0.00001</span>) &#123;</span><br><span class="line">    <span class="comment">// 认为相等</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 不相等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<p>在一个复杂的四则运算中，两个整数的运算不会出现自动提升的情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">1.2</span> + <span class="number">24</span> / <span class="number">5</span>; <span class="comment">// d = 1.2 + 4</span></span><br></pre></td></tr></table></figure>

<p>原因：类型提升指的是最后赋值的时候，而算式中 24 &#x2F; 5 依然遵循整数运算规则。</p>
<p><strong>溢出：</strong></p>
<p>整数运算在除数为<code>0</code>时会报错，而浮点数运算在除数为<code>0</code>时，不会报错，但会返回几个特殊值：</p>
<ul>
<li><code>NaN</code>表示Not a Number</li>
<li><code>Infinity</code>表示无穷大</li>
<li><code>-Infinity</code>表示负无穷大</li>
</ul>
<h3 id="布尔运算"><a href="#布尔运算" class="headerlink" title="布尔运算"></a>布尔运算</h3><p><strong>短路运算：</strong>如果一个布尔运算的表达式能提前确定结果，则后续的计算不再执行，直接返回结果。</p>
<h3 id="运算精度"><a href="#运算精度" class="headerlink" title="运算精度"></a><strong>运算精度</strong></h3><ul>
<li>如果表达式中最高精度低于Int型整数，则按int精度计算</li>
</ul>
<blockquote>
<p>如 ‘a’ + ‘b’ &#x3D; int型数字</p>
<p>byte x&#x3D;7; 则执行表达式 ‘B’+x; 的结果是int型。</p>
</blockquote>
<ul>
<li>char型数据和整型数据运算结果的精度是int精度</li>
<li>Java允许把不超出取值范围的算术表达式赋值给对应类型，<strong>但是当算术表达式中含有变量的时候，只会检查变量的类型</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">z</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">2</span> + z; <span class="comment">// 将int转化为byte类型，报错</span></span><br></pre></td></tr></table></figure>

<p>类型遵循自动&#x3D;&#x3D;小转大&#x3D;&#x3D;，不支持&#x3D;&#x3D;大转小&#x3D;&#x3D;（可以强制转型）</p>
<p><strong>强制转型：</strong>超出范围的强制转型会得到错误的结果</p>
<p>如 int -&gt; short：<code>int</code>的两个高位字节直接被扔掉，仅保留了低位的两个字节</p>
<ul>
<li>较小类型和较大类型运算，结果会自动转化为较大类型。</li>
</ul>
<h2 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h2><p>Java 在内存中总是使用 Unicode 表示字符。</p>
<p>所以 char 类型占用两个字节。</p>
<p>可以用转义字符 <code>\u</code> + Unicode编码（十六进制）表示一个字符</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意是十六进制:</span></span><br><span class="line"><span class="type">char</span> <span class="variable">c3</span> <span class="operator">=</span> <span class="string">&#x27;\u0041&#x27;</span>; <span class="comment">// &#x27;A&#x27;，因为十六进制0041</span></span><br></pre></td></tr></table></figure>





<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><ul>
<li><code>\&quot;</code> 表示字符<code>&quot;</code></li>
<li><code>\&#39;</code> 表示字符<code>&#39;</code></li>
<li><code>\\</code> 表示字符<code>\</code></li>
<li><code>\n</code> 表示换行符</li>
<li><code>\r</code> 表示回车符</li>
<li><code>\t</code> 表示Tab</li>
<li><code>\u####</code> 表示一个Unicode编码的字符</li>
</ul>
<h3 id="不可变特性"><a href="#不可变特性" class="headerlink" title="不可变特性"></a>不可变特性</h3><p>字符串的内容是常量，不可改变，<strong>无法通过索引元素改变其值</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串变了吗？</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">s1 = <span class="string">&quot;world&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>字符串变量为引用类型</p>
<p>对其再次赋值，仅仅改变其指向的内存，原内容依旧存在。</p>
<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a><strong>功能</strong></h3><ol>
<li><p>可以使用 “+” 连接字符串</p>
<p>也可以用 “+” 连接字符串和其他数据类型，结果为字符串类型，被拼接的其他数据类型自身不会改变。</p>
</li>
<li><p>‘’’ … ‘’’ 三引号用于表示多行字符串，<strong>Java 13 以后</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">...........SELECT * FROM</span></span><br><span class="line"><span class="string">...........  users</span></span><br><span class="line"><span class="string">...........WHERE id &gt; 100</span></span><br><span class="line"><span class="string">...........ORDER BY name DESC</span></span><br><span class="line"><span class="string">...........&quot;&quot;&quot;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong>字符串s占据&#x3D;&#x3D;5行&#x3D;&#x3D;，因为在desc后面还有一个’\n’，如果不想要5行，可以直接把三引号写在结尾</p>
<p><strong>排版：</strong>最后会根据每行字符的相对位置来显示，共同的空格会被忽略，不规则排版则是以最短的空格为基准。</p>
</li>
<li><p>null 与 “” 的区别</p>
<p>null：一个引用空值。</p>
<p>“”：一个空的字符串，并不是空值。</p>
</li>
</ol>
<h3 id="在引用的使用"><a href="#在引用的使用" class="headerlink" title="== 在引用的使用"></a><code>==</code> 在引用的使用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;HELLO&quot;</span>.toLowerCase();</span><br><span class="line">System.out.println(a == b); <span class="comment">// false</span></span><br><span class="line"><span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> a;</span><br><span class="line">System.out.println(a == c); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>原因是：<code>==</code> 用于判断两者是否为同一个引用，而不是判断内容是否一致。</p>
<p>判断字符串内容相等可以使用String类型的equals方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a.equals(b)</span><br></pre></td></tr></table></figure>



<p><strong>低内存的特殊</strong></p>
<p>对于数值占用内存较少的情况，JVM 为了节省内存空间，在创建不同变量的时候指向的内存地址都是一样的。</p>
<p>如在128以内（不包括128）的数字</p>
<p>当有多个引用指向它们时，地址是一样的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">System.out.println(a == b); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>



<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>Java 中为了保存 C 语言开发的习惯，保留了<code>int arr[]</code> 和 <code>int[] arr</code> 声明数组类型的形式。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ol>
<li><p>new关键字</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>可以把 <code>int[]</code> 看做一整个数组类，new 出一个 int[] 的对象。</p>
</li>
<li><p>数组常量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>数组常量只能用于初始化，不能声明再赋值。</p>
</li>
</ol>
<h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ol>
<li><p>int[] 括号内不需要指定数字，在初始化的时候会自动推断。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &#123;&#125;内指定了数组元素，这里的3可以省略</span></span><br><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>

<p>如果没有指定，也没有指定数字（数组长度），那这个数组长度只有就是0。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明一个长度为 10 的数组，默认值为 0</span></span><br><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化后，数组的长度将不可改变，超出长度的索引会报异常。</p>
</li>
<li><p>创建的数组元素，如果没有赋予初值，会被赋予默认值</p>
<ul>
<li><p>数值型基本数据类型的默认值是 0</p>
</li>
<li><p>char 类型的默认值为 ‘\u0000’ </p>
</li>
<li><p>boolean 类型默认值为 false。</p>
</li>
</ul>
</li>
<li><p>通过访问 length 属性可以获得数组的长度。</p>
</li>
</ol>
<p><strong>注意：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    String[] names = &#123;<span class="string">&quot;ABC&quot;</span>, <span class="string">&quot;XYZ&quot;</span>, <span class="string">&quot;zoo&quot;</span>&#125;;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> names[<span class="number">1</span>];</span><br><span class="line">    names[<span class="number">1</span>] = <span class="string">&quot;cat&quot;</span>;</span><br><span class="line">    System.out.println(s);	<span class="comment">// s是被赋值为XYZ了，而不是names[1]的引用</span></span><br><span class="line">    System.out.println(Arrays.toString(names)); <span class="comment">// [ABC, cat, Zoo]</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>names[1] 是一个元素，不是引用。</p>
<h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><p><strong>初始化</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[][] ns = &#123;</span><br><span class="line">    &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;,</span><br><span class="line">    &#123; <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span> &#125;,</span><br><span class="line">    &#123; <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// new</span></span><br><span class="line"><span class="type">int</span>[][] ns = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;</span><br><span class="line">    &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;,</span><br><span class="line">    &#123; <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span> &#125;,</span><br><span class="line">    &#123; <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>打印多维数组</strong></p>
<p>打印多维数组可以使用<code>Arrays.deepToString()</code>；</p>
<h3 id="排序数组"><a href="#排序数组" class="headerlink" title="排序数组"></a>排序数组</h3><p>使用 Arrays 类的成员函数sort，可对数组进行排序</p>
<p><strong>默认小到大排列</strong>: Arrays.sort(arr);</p>
<p><strong>逆序</strong>: Arrays.sort(arr，Collections.reverseOrder())</p>
<p>sort 不能直接用于排列多维数组，&#x3D;&#x3D;使用什么可以排序多维数组呢&#x3D;&#x3D;</p>
<p>多维数组不需要排序，本质是处理每个一维数组。</p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ol>
<li>使用 Scanner 类初始化数组</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> n: arr)&#123;</span><br><span class="line">    n = scanner.nextInt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>随机打乱</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[index];</span><br><span class="line">    arr[index] = arr[arr.length - <span class="number">1</span>];</span><br><span class="line">    arr[arr.length - <span class="number">1</span>] = temp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line"> 		<span class="comment">// 随机位置与数组的最后一个元素交换</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (<span class="type">int</span>)(Math.random() * arr.length);</span><br><span class="line">        swap(arr, index);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Arrays.toString(arr));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：使用传递&#x3D;&#x3D;数组引用&#x3D;&#x3D;的方式才能在 不同作用域 交换数组内的值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Swap</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr，<span class="type">int</span> i，<span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String args[ ])</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>，<span class="number">2</span>&#125;;</span><br><span class="line">        Swap.swap(arr，<span class="number">0</span>，<span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr)); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>复制数组</p>
<ol>
<li><p>使用Java.util.Arrays的静态方法copyOf复制数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">newArr = Arrays.copyOf(oldArr，neededLength);</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用System类中的静态方法arraycopy</p>
</li>
<li><p>使用clone方法复制数组</p>
</li>
</ol>
</li>
<li><p>for each循环</p>
<p>对于可迭代对象，使用for循环的”for each”形式会显得更加简洁</p>
<p>形式: for( varName :  arrayName) {…}</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span>，<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> n: arr)&#123;</span><br><span class="line">            System.out.println(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>这里的n，代表数组中的每个元素，而不是索引值</p>
</li>
<li><p>使用该方法遍历数组，无法控制访问顺序</p>
</li>
<li><p>for each循环还可用于List，Map等数据结构</p>
</li>
</ul>
</li>
<li><p>转 Stream 流</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.stream(arr)</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h2><blockquote>
<p>在使用 java 命令执行 java 文件的时候</p>
</blockquote>
<p>可以传入 …String 类型的参数，由 public 类的入口函数 main 的 args 参数获取</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java Main &quot;123&quot; &quot;456&quot;</span><br><span class="line">// args: [&quot;123&quot;, &quot;456&quot;]</span><br></pre></td></tr></table></figure>





<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><blockquote>
<p> 通常使用Scanner类的实例对象来接受用户输入</p>
</blockquote>
<p>Scanner 类包含在 <code>java.util</code> 包内，需要先引入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">myScan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);	<span class="comment">// 传入输入流</span></span><br><span class="line">        <span class="comment">// 使用nextInt()获取整型数据</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> myScan.nextInt();</span><br><span class="line">        <span class="comment">// 使用nextLine()获取一行字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> myScan.nextLine();</span><br><span class="line">        <span class="comment">// next...等等</span></span><br><span class="line">        <span class="comment">// 使用完毕后，关闭输入流</span></span><br><span class="line">        myScan.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong> </p>
<p>nextInt 表示获取用户的下一个输入并转化为 int 类型，不是从输入中获取下一个 int 类型</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用户输入</span></span><br><span class="line">a 123</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">nextInt 会接收 a</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">并抛出 java.util.InputMismatchException 异常</span></span><br></pre></td></tr></table></figure>



<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>使用System.out输出流向输出端输出数据</p>
<ul>
<li>System.out.println() 输出一行</li>
<li>System.out.print()    直接输出</li>
<li>System.out.printf()   格式化输出</li>
</ul>
<p><strong>格式字符：</strong></p>
<p>%d 输出整型数据</p>
<p>%c 输出字符型数据</p>
<p>%f 输出浮点型数据</p>
<p>使用如%m.nd形式，可以控制输出的排版。</p>
<p>m：数字所占位数</p>
<p>n：小数位数</p>
<p><strong>注意</strong>：因为 % 表示占位符，所以连续两个 %% 才表示一个 % 字符本身。</p>
<h3 id="if判断"><a href="#if判断" class="headerlink" title="if判断"></a>if判断</h3><p>if 中表达式必须是 &#x3D;&#x3D;boolean类型&#x3D;&#x3D;，不能使用 0，1，null 代替</p>
<h3 id="switch新用法"><a href="#switch新用法" class="headerlink" title="switch新用法"></a>switch新用法</h3><p>switch 中 case 的条件必须是常量，枚举也可以。</p>
<p><strong>Java 12</strong> 开始，使用 <code>-&gt;</code> 符号可以<strong>无需break</strong>，直接指定执行单一路径，而不会继续向下执行其他语句</p>
<p>switch 将返回被执行 case 条件的结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">fruit</span> <span class="operator">=</span> <span class="string">&quot;apple&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">opt</span> <span class="operator">=</span> <span class="keyword">switch</span> (fruit) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;apple&quot;</span> -&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;pear&quot;</span> -&gt; <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">default</span> -&gt; <span class="number">0</span>;</span><br><span class="line">        &#125;;	<span class="comment">// 赋值语句后以 ; 结束</span></span><br><span class="line">        System.out.println(opt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果需要使用复杂的语句，可以使用花括号{}包裹，再通过yield关键字返回值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&quot;mango&quot;</span> -&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">code</span> <span class="operator">=</span> fruit.hashCode();</span><br><span class="line">    <span class="keyword">yield</span> code;		<span class="comment">// code作为该分支的返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>从 Java 13 开始允许使用yield返回值</p>
</blockquote>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><h4 id="while"><a href="#while" class="headerlink" title="while"></a><strong>while</strong></h4><p>while循环中的判断条件必须是一个 boolean 值，如 3 &gt; 2 的结果，而不能直接放一个数字</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">      <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123; <span class="comment">// 在C语言中可以直接写为 n</span></span><br><span class="line">         res += n--;</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(res);</span><br><span class="line">   &#125; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>对于循环条件判断，以及自增变量的处理，要特别注意边界条件。思考一下下面的代码为何没有获得正确结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">            n ++;</span><br><span class="line">            sum = sum + n;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum); <span class="comment">// 5151</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>n的边界是 0 -&gt; 100，当 n &#x3D; 100 时，会再次进入循环，n 变成了 101。</p>
<p>导致结果多加了一个 101，原本为 5050</p>
<p>将这个操作改为 for 循环则不会有这个问题，因为 自增变量 始终作为后置条件在循环体内执行完之后。</p>
<h4 id="do-while"><a href="#do-while" class="headerlink" title="do while"></a>do while</h4><p>改写 while 循环的 1 到 100 求和</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            sum = sum + n;</span><br><span class="line">            n ++;</span><br><span class="line">        &#125; <span class="keyword">while</span> (n &lt;= <span class="number">100</span>);</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4><p>改写 1 到 100 求和</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">100</span>; i++) &#123;</span><br><span class="line">            sum = sum + i;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>计数器定义位置</strong></p>
<p>如果变量 <code>i</code> 定义在 <code>for</code> 循环外：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int[] ns = &#123; 1, 4, 9, 16, 25 &#125;;</span><br><span class="line">int i;</span><br><span class="line">for (i=0; i&lt;ns.length; i++) &#123;</span><br><span class="line">    System.out.println(ns[i]);</span><br><span class="line">&#125;</span><br><span class="line">// 仍然可以使用i</span><br><span class="line">int n = i;</span><br></pre></td></tr></table></figure>

<p>破坏了<strong>变量应该把访问范围缩到最小</strong>的原则。</p>
<h4 id="for-each"><a href="#for-each" class="headerlink" title="for each"></a>for each</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] ns = &#123; <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span> &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> n : ns) &#123;</span><br><span class="line">            System.out.println(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和<code>for</code>循环相比，<code>for each</code>循环的变量n不再是计数器，而是直接对应到数组的每个元素。</p>
<p>除了数组外，<code>for each</code>循环能够遍历所有“可迭代”的数据类型，包括后面会介绍的<code>List</code>、<code>Map</code>等。</p>
<h4 id="break-和-continue"><a href="#break-和-continue" class="headerlink" title="break 和 continue"></a>break 和 continue</h4><p>break：跳出最近一层循环，多层循环只能跳出一层</p>
<p>continue：跳出本次循环，执行下一个符合条件的循环</p>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h5 id="0-特点"><a href="#0-特点" class="headerlink" title="0. 特点"></a>0. 特点</h5><ul>
<li>封装性</li>
<li>继承</li>
<li>多态</li>
</ul>
<h5 id="1-字段"><a href="#1-字段" class="headerlink" title="1. 字段"></a>1. 字段</h5><blockquote>
<p>字段即成员变量</p>
</blockquote>
<p>​	没有初始化的引用字段，默认为null值; 其他类型的也是默认值，如Int类型是0，boolean是false;</p>
<h6 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h6><ul>
<li>静态方法可以通过对应类的空对象访问</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="literal">null</span>;	<span class="comment">// 定义Test类空对象</span></span><br><span class="line">        test.f1();			<span class="comment">// 使用空对象访问静态方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>:</p>
<ul>
<li>在&#x3D;&#x3D;成员函数内部&#x3D;&#x3D;声明的局部变量不会自动初始化，需要初始化后才可引用</li>
<li>无论成员变量，和成员函数声明定义的顺序如何，&#x3D;&#x3D;成员变量是先与成员函数生成的&#x3D;&#x3D;，所以可以出现以下这种情况</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> m; <span class="comment">// m被定义为成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>不能在成员函数中定义<strong>与参数重名</strong>的变量</li>
<li>可以在成员函数中定义与成员变量同名的变量，定义的局部变量会覆盖成员变量。</li>
</ul>
<h5 id="2-构造函数"><a href="#2-构造函数" class="headerlink" title="2. 构造函数"></a>2. 构造函数</h5><blockquote>
<p>构造函数支持重载(Overload)</p>
</blockquote>
<p>​	Java中可以通过<strong>this引用</strong>可以在一个构造函数中调用其他构造函数，<u>但是C++不行</u>，因为可以有默认参数， 所以就没有构造函数的相互调用了，但是C++可以调用父类的构造函数</p>
<h5 id="3-this关键字"><a href="#3-this关键字" class="headerlink" title="3. this关键字"></a>3. this关键字</h5><ul>
<li>this是Java的一个关键字，表示某个对象<ul>
<li>在构造方法中，代表该构造方法所创建的对象。</li>
<li>实例方法中，代表正在调用该方法的当前对象。</li>
</ul>
</li>
<li>this不能用于类成员变量和类方法。</li>
<li>可用this调用被隐藏的成员变量</li>
</ul>
<blockquote>
<p>如：当局部变量和成员变量重名时，可以使用this.成员变量访问到它</p>
</blockquote>
<h5 id="4-包"><a href="#4-包" class="headerlink" title="4. 包"></a>4. 包</h5><p>包是一种用来管理类的机制，可以有效地区分名字相同的类</p>
<p><strong>使用方法</strong>：</p>
<ul>
<li>用package 包名;语句声明该源文件所在的包</li>
</ul>
<p><strong>注意事项</strong>：</p>
<ul>
<li>该语句必须作为源文件的第一行语句。</li>
<li>建议用域名反写的方式建包（目前还没有看懂）。</li>
<li>包的名字，必须为源文件所在路径，不能随意起名。</li>
</ul>
<blockquote>
<p>如tom&#x2F;jiafei&#x2F;路径下有Test.Java文件，则该文件的包名可以为tom.jiafei</p>
</blockquote>
<p><strong>运行方式</strong>：</p>
<p>​	如果主类的包名是tom.jiafei，就<strong>必须到</strong>tom\jiafei的上一层（即tom的父目录）目录中去运行主类。</p>
<blockquote>
<p>假设tom\jiafei的上一层目录是1000，那么必须用如下格式来运行： C:\1000&gt; Java tom.jiafei.主类名</p>
</blockquote>
<p><strong>import语句</strong></p>
<p>既然有包的建立，那必然有引用包。</p>
<blockquote>
<p>系统会自动导入Java.lang包中所有的类。</p>
</blockquote>
<p>通过import语句，可以使该源文件能够调用其他包中的类。</p>
<p>&#x3D;&#x3D;父包和子包没有关系，包含的类也没有关系&#x3D;&#x3D;</p>
<h5 id="5-修饰符"><a href="#5-修饰符" class="headerlink" title="5. 修饰符"></a>5. 修饰符</h5><p>Java使用四种修饰符，来限制类中的成员变量和成员函数被访问的权限</p>
<ul>
<li>public类。 该类成员可以被所有类访问</li>
<li>protected类。 该类成员只能被同一文件，同一包内的类或子类访问。</li>
<li>没有修饰符的称为default类。 只能被同一文件，和同一包内的类访问。</li>
</ul>
<blockquote>
<p>子类不能访问指：其他包通过引用该包，然后继承该包中的某一个类，该子类无法访问父类的成员。</p>
</blockquote>
<p>&#x3D;&#x3D;事实证明即使是default类，只要其子类在同一个文件或包，依旧能够访问父类成员。&#x3D;&#x3D;</p>
<ul>
<li>private类。 该类成员只能被自己访问。</li>
</ul>
<h5 id="6-包装类"><a href="#6-包装类" class="headerlink" title="6. 包装类"></a>6. 包装类</h5><p>为了方便基本数据类型的使用，Java提供了基本数据类型的相关类，实现了对其的封装。</p>
<p>如：Integer,Character,Byte等类。</p>
<p>构造方法如：Integer a &#x3D; new Integer(2);</p>
<p>返回类中包含的值：a.value();</p>
<h5 id="7-上转型对象"><a href="#7-上转型对象" class="headerlink" title="7. 上转型对象"></a>7. 上转型对象</h5><p>将子类的对象传递给父类引用，称为上转型对象。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Father</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line"><span class="comment">// 第二种情况</span></span><br><span class="line">Father f;</span><br><span class="line"><span class="type">Son</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">f = s;</span><br></pre></td></tr></table></figure>

<p><strong>使用</strong>：</p>
<ul>
<li>不可以使用子类新增的成员（变量、函数）</li>
<li>可以使用子类继承和重写的方法</li>
<li>可以使用子类隐藏的成员变量</li>
</ul>
<blockquote>
<p>如：父类有int a变量，而子类定义了同名变量double a，而上转型对象调用的是父类的a变量。</p>
</blockquote>
<p>&#x3D;&#x3D;不支持向下转型，会报出ClassCastException&#x3D;&#x3D;</p>
<p><strong>多态</strong></p>
<p>多态就是指父类的某个方法被子类重写后产生自己的功能行为，各个子类都不同。</p>
<h5 id="8-抽象类"><a href="#8-抽象类" class="headerlink" title="8. 抽象类"></a>8. 抽象类</h5><p>用于定义共有的属性（变量、方法），合理地使用抽象类，可以写出易维护、易扩展的程序。</p>
<p>&#x3D;&#x3D;抽象类可以没有abstract方法&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;不可以使用static修饰抽象类&#x3D;&#x3D;，因为抽象类没有实例吧。</p>
<p><strong>使用</strong>：</p>
<ul>
<li>具备一般类的基本能力，可以有字段、构造方法；<strong>但不能实例化abstract类对象</strong></li>
<li>不能用final修饰抽象类，因为定义抽象类就是要用来继承的。</li>
<li>抽象类的非抽象子类必须实现抽象父类的所有抽象方法。</li>
</ul>
<p><strong>缺点</strong>：&#x3D;&#x3D;Java中只能继承一个类，所以抽象类并不完善&#x3D;&#x3D;</p>
<h5 id="9-接口"><a href="#9-接口" class="headerlink" title="9. 接口"></a>9. 接口</h5><p>为了弥补只能继承一个类的缺陷，Java定义了接口概念。</p>
<p>接口和抽象类差不多，但是比抽象类更加标准化。接口还有一个优势：&#x3D;&#x3D;允许非同一父类的子类拥有相同名称的方法。&#x3D;&#x3D;</p>
<p><strong>使用</strong>：</p>
<p>通过interface 接口名{}，与定义一个类差不多的形式定义接口；</p>
<ul>
<li>接口中不存在变量。&#x3D;&#x3D;声明常量时必须初始化，不具有默认值&#x3D;&#x3D;</li>
</ul>
<p>类似int MAX &#x3D; 100;</p>
<p>等价于：(public static final) int MAX &#x3D; 100; 	括号内为缺省类型，即可以省略不写。</p>
<ul>
<li>接口中所有的方法默认都是抽象方法</li>
</ul>
<p>如void f(); &#x3D;&gt; 等价于 public abstract void f() {};</p>
<ul>
<li>可以用default关键字定义实例方法（JDK8后），必须是public方法，可省略不写。</li>
</ul>
<blockquote>
<p>default方法与普通类的实例方法一致，该接口的实现类可以选择是否重写，重写需去掉default关键字。</p>
</blockquote>
<ul>
<li>允许使用static关键字定义静态方法（JDK8后）</li>
<li>允许使用private关键字定义私有方法，接口的实现类无法访问private方法，目的是配合default方法使用实现一些算法的封装。（JDK9）</li>
</ul>
<p><strong>注意</strong>：</p>
<ul>
<li>接口没有构造函数</li>
<li>所有字段除了private， 其他的访问权限都是public</li>
</ul>
<p><strong>实现接口</strong></p>
<p>通过implements关键字可以实现一个或多个接口，接口之间用逗号隔开。</p>
<ul>
<li>非抽象类实现接口，必须重写所有抽象方法。</li>
<li>接口的实现了不拥有接口的<strong>静态</strong>和私有方法。</li>
<li>实现接口方法的访问权限必须是public， <strong>允许重载接口方法，并修改访问权限</strong></li>
</ul>
<blockquote>
<p>如接口有void cry(); 子类可以定义protected void cry(int m)方法。</p>
</blockquote>
<p><strong>接口回调</strong></p>
<p>将接口的实现类对象的引用赋值给接口变量，再通过接口变量调用实现类实现的方法，称为接口回调。</p>
<p>实际过程是：在接口变量调用方法时，根据地址通知对应的对象去调用对应的方法。</p>
<p><strong>接口与抽象类的比较</strong></p>
<ul>
<li>接口和abstract类的比较如下：<ul>
<li>abstract类和接口都可以有abstract方法。</li>
<li>接口中只可以有常量，不能有变量；而abstract类中即可以有常量也可以有变量。</li>
<li>abstract类中也可以有非abstract方法，接口不可以(JDK 7及以前的版本）。</li>
</ul>
</li>
</ul>
<h5 id="10-Lambada表达式（JDK8后）"><a href="#10-Lambada表达式（JDK8后）" class="headerlink" title="10. Lambada表达式（JDK8后）"></a>10. Lambada表达式（JDK8后）</h5><p>Lambada表达式，又称为匿名表达式；常用在单接口（只具有一个abstract方法的接口）的接口回调中。</p>
<p>形式：（参数列表） -&gt; {方法体}</p>
<p>Lambada表达式的值就是该方法的入口地址，可以将其赋给接口变量来实现单接口，用于接口回调。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        A obj;</span><br><span class="line">        obj = () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">        &#125;;			<span class="comment">// 分号不要忘记了</span></span><br><span class="line">        obj.f();	<span class="comment">// 输出 ok</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="11-内部类"><a href="#11-内部类" class="headerlink" title="11. 内部类"></a>11. 内部类</h5><p>在一个类中，再定义一个类，那么该类就叫做内部类。</p>
<blockquote>
<p>为了代码的易维护，和相关性，可以将需要用到的类写在另一个类中作为内部类。</p>
<p>对于拥有内部类的类，在编译后将生成多个class文件。</p>
</blockquote>
<p><strong>使用</strong>：</p>
<ul>
<li>外嵌类可以声明内部类对象</li>
<li>内部类不能定义静态成员。&#x3D;&#x3D;为什么内部类可以用static声明&#x3D;&#x3D;。</li>
</ul>
<h5 id="12-匿名类"><a href="#12-匿名类" class="headerlink" title="12. 匿名类"></a>12. 匿名类</h5><blockquote>
<p>有时候为了方便可以通过类体直接创建一个子类</p>
</blockquote>
<ul>
<li>可以是继承父类的子类</li>
<li>也可以是实现接口的子类</li>
<li>使用Lambada表达式做到的接口回调也是匿名类。</li>
</ul>
<p>形式：</p>
<p>new 父类构造方法 &#x2F; 接口名() {类体}</p>
<p>&#x3D;&#x3D;匿名类属于内部类&#x3D;&#x3D;</p>
<h5 id="13-异常类"><a href="#13-异常类" class="headerlink" title="13. 异常类"></a>13. 异常类</h5><p>用于提供程序运行出现错误的信息，及错误的捕捉</p>
<p>异常对象可以调用如下方法得到&#x2F;输出异常相关的信息</p>
<ul>
<li>public String getMessage();</li>
<li>public void printStackTrace();</li>
<li>public String toString();</li>
</ul>
<p><strong>捕捉异常</strong></p>
<p>Java使用try~catch~finally（可选）来捕捉处理异常，允许存在多条catch语句</p>
<p>&#x3D;&#x3D;多条catch语句可以分别处理异常，不是匹配一个就结束&#x3D;&#x3D;</p>
<p>注意：子类异常必须放在父类异常前面，因为父类异常包含子类。</p>
<p><strong>抛出异常</strong></p>
<p>在方法体内使用throw抛出异常对象: throw new Exception();</p>
<p>使用throws声明异常，声明该方法可能会出现的异常</p>
<h2 id="核心类"><a href="#核心类" class="headerlink" title="核心类"></a>核心类</h2><h5 id="1-String类"><a href="#1-String类" class="headerlink" title="1. String类"></a>1. String类</h5><p>String类不可继承。</p>
<p>String常量：用双引号括起来的字符序列。Java把String常量放在常量池内。</p>
<p>&#x3D;&#x3D;重点&#x3D;&#x3D;</p>
<ul>
<li>将一个String常量赋给变量时，如果内容相同的String常量在常量池里已经存在，则不会创建新的字符串常量，而是将已存在的字符串常量引用赋给该变量。</li>
</ul>
<blockquote>
<p>即：String a &#x3D; “hello”; String b &#x3D; “hello”;</p>
<p>a &#x3D;&#x3D; b &#x2F;&#x2F;输出true</p>
</blockquote>
<ul>
<li><p>而使用new关键字创建字符串对象，是在堆内申请一份新内存，因此内容相同但不是同一个引用。</p>
</li>
<li><p>String类对象在生成后，无法改变其中的值。</p>
</li>
</ul>
<blockquote>
<p>String a &#x3D; “hello”;</p>
<p>a[1] &#x3D; ‘a’;	&#x2F;&#x2F; 错误，并且只能通过charAt(index)方法访问。</p>
</blockquote>
<ul>
<li>通过+号可以使字符串进行并置运算。</li>
</ul>
<p>常量并置运算后依旧是常量，而一旦变量参与并置运算，就会重新在堆中创建新的String对象。</p>
<p><strong>与第一点共同思考</strong></p>
<blockquote>
<p>String str1 &#x3D; “helloJava”;</p>
<p>String str2 &#x3D; “hello” + “Java”;</p>
<p>str1 &#x3D;&#x3D; str2 	&#x2F;&#x2F; 得到true，运算后依旧是常量</p>
<p>String a &#x3D; “hello”，b &#x3D; “Java”；</p>
<p>String c &#x3D; a + b;</p>
<p>c &#x3D;&#x3D; str1; 		&#x2F;&#x2F; 得到false，因为a，b为String类变量，所以在并置运算后得到新的字符串对象。</p>
</blockquote>
<p><strong>与字符数组</strong></p>
<p>可以使用字符数组创建String类对象，也可限制范围；</p>
<ul>
<li>String(char a[],int startIndex,int count)；</li>
</ul>
<p>也可以String转字符数组</p>
<ul>
<li>public void getChars(int start,int end,char c[],int offset ) </li>
<li>public char[] toCharArray()</li>
</ul>
<p><strong>与字节数组</strong></p>
<p>String转字节数组</p>
<ul>
<li>public byte[] getBytes()。使用平台默认的字符编码。 </li>
<li>public byte[] getBytes(String charsetName)。指定字符编码</li>
</ul>
<p>&#x3D;&#x3D;GB2312编码中，一个汉字占两个字节。&#x3D;&#x3D;</p>
<h5 id="2-正则表达式"><a href="#2-正则表达式" class="headerlink" title="2. 正则表达式"></a>2. 正则表达式</h5><h5 id="3-Class类与反射"><a href="#3-Class类与反射" class="headerlink" title="3. Class类与反射"></a>3. Class类与反射</h5><blockquote>
<p>​	任何类默认有一个public的静态的(static)Class对象，该对象的名字是class（用关键字做了名字，属于Java系统特权），该对象封装当前类的有关信息（即类型的信息），如该类有哪些构造方法，哪些成员变量，哪些方法等。也可以让类的对象调用getClass()方法（从Java.lang.Object类继承的方法）返回这个Class对象：class。</p>
</blockquote>
<p>Class对象(class)调用方法可以获取当前类的有关信息，比如，类的名字、类中的方法名称、成员变量的名称等等，这一机制也称为Java反射。</p>
<p><strong>用Class类和反射机制创建新对象</strong>（有点问题）</p>
<ol>
<li>使用用Class类的类方法forName(String className)返回对应类的Class对象。</li>
<li>再让这个Class对象调用getDeclaredConstructor()方法得到 对应类 的 无参数的<strong>构造方法</strong>对象。</li>
<li>然后构造方法对象再调用newInstance()返回该类的对象</li>
</ol>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>通过代码块捕获 异常class类，来知道发生了什么错误，并进行下一步处理。</p>
<h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>类的继承关系如下：</p>
<p><img src="/assets/image-20240403211146797.png" alt="image-20240403211146797"></p>
<p><code>Error</code>表示严重的错误，程序对此一般无能为力</p>
<ul>
<li><code>OutOfMemoryError</code>：内存耗尽</li>
<li><code>NoClassDefFoundError</code>：无法加载某个Class</li>
<li><code>StackOverflowError</code>：栈溢出</li>
</ul>
<p>而<code>Exception</code>则是运行时的错误，它可以被捕获并处理。</p>
<p>某些异常是应用程序逻辑处理的一部分，应该捕获并处理。例如：</p>
<ul>
<li><code>NumberFormatException</code>：数值类型的格式错误</li>
<li><code>FileNotFoundException</code>：未找到文件</li>
<li><code>SocketException</code>：读取网络失败</li>
</ul>
<p><strong>Java规定（编辑器也会提示）：</strong></p>
<ol>
<li><p>必须捕获的异常（Checked Exception），包括<code>Exception</code>及其子类，但不包括<code>RuntimeException</code>及其子类。</p>
<p>Checked Exception：需要检查的异常</p>
<p>不包括在内的异常，可以由开发者自由选择是否捕获。</p>
<p>如 <code>NullPointerException</code> ，你可以自己选择是否捕获并处理该异常。</p>
<p>而 <code>IOException</code>，在 Java 环境中是必须要声明捕获的。 </p>
</li>
<li><p>不需要捕获的异常，包括<code>Error</code>及其子类，<code>RuntimeException</code>及其子类。</p>
</li>
</ol>
<p><strong>异常处理建议：</strong>异常不应该在产生的代码层级 <strong>空捕获不处理</strong>，即使真的什么也做不了，也应该把异常记录下来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">byte</span>[] toGBK(String s) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">        <span class="comment">// 先记下来再说:</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有异常都可以调用<code>printStackTrace()</code>方法打印异常栈（先进后出）。</p>
<p>因为是栈，所以异常栈最下面才是触发异常的源头。</p>
<h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><p><strong>catch 语句</strong></p>
<p>可以使用多个 <code>catch</code> 语句。</p>
<p>从上到下匹配对应异常类，但是只有一个能被执行。</p>
<p>因此顺序应保持：子类必须写在前面。</p>
<p>因为如果父类（范围大的异常）写在子类前面，就捕获不到子类了，等于没写。</p>
<p><strong>finally 语句</strong></p>
<p>无论异常是否发生，被捕获到，finally中的语句都会被执行。</p>
<p>特点：</p>
<ol>
<li>非必须</li>
<li>总是在 try ~ catch 之后，最后被执行</li>
</ol>
<p>finally 用于保证一些代码必须被执行，防止因为异常跳出了代码原本的运行逻辑。</p>
<p><strong>合并处理异常</strong></p>
<p>每个异常类应该是在不同 bit 位上，因此可以用 <code>|</code> 或运算符联合多个异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process1();</span><br><span class="line">        process2();</span><br><span class="line">        process3();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException | NumberFormatException e) &#123; <span class="comment">// IOException或NumberFormatException</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Bad input&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Unknown error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>完整示例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process1();</span><br><span class="line">        process2();</span><br><span class="line">        process3();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bad encoding&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;IO error&quot;</span>);</span><br><span class="line">    <span class="comment">// 常用于保证同步读写操作流的关闭</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;END&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h3><p><strong>异常传播</strong></p>
<p>当某个方法抛出异常后，如果当前方法没有捕获异常，异常就会被抛到上层调用方法，直到被捕获为止。</p>
<p><strong>抛出异常</strong></p>
<ol>
<li>创建某个 <code>Exception</code> 的实例</li>
<li>用 <code>throw</code> 语句抛出</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">process2</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">NullPointerException</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大部分情况下会合并写成一行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">process2</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="异常“转换”"><a href="#异常“转换”" class="headerlink" title="异常“转换”"></a><strong>异常“转换”</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">process1</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process2();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">process2</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>process1在捕获到process2的异常后，抛出了另一个异常 <code>IllegalArgumentException</code>。</p>
<p>那么原异常信息就会丢失，“转换”成了另一个异常暴露给外部</p>
<p>如果想要在抛出新的异常下，同时保留原始的异常信息，就需要把原始异常的实例作为新的异常构建参数传入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">process1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process2();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">        <span class="comment">// 传入原异常实例</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">process2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样在输出的异常栈信息中，就会包括原始的异常信息。</p>
<p><strong>捕获到异常并再次抛出时，一定要留住原始异常，否则很难定位第一案发现场！</strong></p>
<h3 id="异常屏蔽"><a href="#异常屏蔽" class="headerlink" title="异常屏蔽"></a>异常屏蔽</h3><p><strong>finally 与 catch 的执行顺序</strong></p>
<p>finally 语句的内容是一定会执行的，相比于 catch 语句的执行顺序呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Integer.parseInt(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;catched&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;finally&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">catched</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.RuntimeException: java.lang.NumberFormatException: For input string: <span class="string">&quot;abc&quot;</span></span><br><span class="line">    at Main.main(Main.java:<span class="number">8</span>)</span><br><span class="line">Caused by: java.lang.NumberFormatException: For input string: <span class="string">&quot;abc&quot;</span></span><br><span class="line">    at ...</span><br></pre></td></tr></table></figure>

<p>第一行打印了<code>catched</code>，第二行打印了<code>finally</code>。</p>
<p>说明先进入 catch 语句，再执行 finally 语句，并且 catch 中抛出的异常不会影响到 finally 执行</p>
<p><strong>异常屏蔽</strong></p>
<p>如果在执行 <code>finally</code> 语句时抛出异常，那么，<code>catch</code> 语句的异常还能否继续抛出？</p>
<p>答案：catch 中抛出的异常最终会被 finally 中抛出的异常“覆盖”。</p>
<p>本质猜测：</p>
<p>在 JVM 中有一个全局异常处理Handler，在执行目标类中的代码时，虽然 catch 先抛出了异常，但是要等 finally 执行完，handler 中的 catch 才对异常进行捕获，这时候 finally 中抛出的异常也会进入异常栈，覆盖原始异常，类似上述的异常“转换”，从而丢失原来的异常。</p>
<blockquote>
<p>catch 中只能抛出一个异常，没有被抛出的异常称为“被屏蔽”的异常（Suppressed Exception）。</p>
</blockquote>
<p><strong>如何获取所有的异常信息</strong></p>
<p>方法：先保存原始异常实例，然后调用 <code>Throwable.addSuppressed()</code>，把原始异常添加进来，最后在 <code>finally </code> 抛出。</p>
<p>为什么要在 finally 中抛出？</p>
<p>因为 catch 抛出一条异常就结束了，只能存好这一条异常，留在 finally 中添加了</p>
<h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>在项目开发中，为了方便处理不同业务的异常，会自定义异常，以便能精准的捕获。</p>
<p>自定义异常通常继承 <code>RuntimeException</code>。</p>
<p>这一类异常是 JVM 非强制捕获的异常，具有更好的扩展性，并且能自由的空值。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaseException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BaseException</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BaseException</span><span class="params">(String message, Throwable cause)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message, cause);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BaseException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BaseException</span><span class="params">(Throwable cause)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基本都是原样照抄<code>RuntimeException</code>。这样，抛出异常的时候，就可以选择合适的构造方法。通过IDE可以根据父类快速生成子类的构造方法。</p>
<p>真正的目的是区分不同的异常类。</p>
<h3 id="NPE异常"><a href="#NPE异常" class="headerlink" title="NPE异常"></a>NPE异常</h3><p>NPE 即 <code>NullPointerException</code> 空指针异常。</p>
<p>避免NPE的好习惯</p>
<ol>
<li><p>成员变量在定义时就初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>返回空字符串<code>&quot;&quot;</code>、空数组而不是<code>null</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] readLinesFromFile(String file) &#123;</span><br><span class="line">    <span class="keyword">if</span> (getFileSize(file) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 返回空数组而不是null:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Java 8</strong> 后，提供了 <code>Optional&lt;T&gt;</code> 工具类用于判断</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Optional&lt;String&gt; <span class="title function_">readFromFile</span><span class="params">(String file)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!fileExist(file)) &#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.empty();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过调用 Optional.isPresent() 可以判断结果</p>
</li>
</ol>
<p><strong>定位 NPE</strong></p>
<p>在执行类似如下代码时，Java 默认是不会指出哪个对象是null，只会暴露出目标文件所在行数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a.b.c.x()</span><br></pre></td></tr></table></figure>

<p>Java 14 以后，只要开启如下 JVM 参数就可以检测出具体的 null 对象。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -XX:+ShowCodeDetailsInExceptionMessages Main.java</span><br></pre></td></tr></table></figure>

<p>本质猜测：开启后，每一步对象的嵌套调用都会被记录，当出现错误的时候就显示当前层级，可能会降低性能。</p>
<h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><p>使用 <code>assert</code> 关键字来实现断言。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assert</span> x &gt;= <span class="number">0</span> : <span class="string">&quot;x must &gt;= 0&quot;</span>;</span><br></pre></td></tr></table></figure>

<p><code>:</code> 冒号后添加可选的断言消息。</p>
<p>如果断言判断失败，会抛出 <code>AssertionError</code> 异常结束程序，并带上断言消息。</p>
<p>断言常用于测试，只要错误就代表测试失败。</p>
<p>JVM 默认关闭断言指令，即遇到<code>assert</code>语句就自动忽略了，不执行。</p>
<p>需要开启 <code>-enableassertions</code> （可简写为<code>-ea</code>）参数启用断言。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -ea Main.java</span><br><span class="line">Exception <span class="keyword">in</span> thread <span class="string">&quot;main&quot;</span> java.lang.AssertionError</span><br><span class="line">	at Main.main(Main.java:5)</span><br></pre></td></tr></table></figure>

<p>还可以对特定的类启用断言<code> -ea:com.itranswarp.sample.Main</code></p>
<p>或者特定的包 <code>-ea:com.itranswarp.sample...</code>，用结尾的 … 表示这是一个包。</p>
<h3 id="日志输出"><a href="#日志输出" class="headerlink" title="日志输出"></a>日志输出</h3><p>对比 <code>System.out.println()</code> 有如下好处：</p>
<ol>
<li>可以设置输出样式，避免自己每次都写<code>&quot;ERROR: &quot; + var</code>；</li>
<li>可以设置输出级别，禁止某些级别输出。例如，只输出错误日志；</li>
<li>可以被重定向到文件，这样可以在程序运行结束后查看日志；</li>
<li>可以按包名控制日志级别，只输出某些包打的日志；</li>
<li>可以…… 等等</li>
</ol>
<p>Java 内置了 <code>java.util.logging</code>，可以直接使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.logging.Level;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.Logger;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> Logger.getGlobal();</span><br><span class="line">        logger.info(<span class="string">&quot;start process...&quot;</span>);</span><br><span class="line">        logger.warning(<span class="string">&quot;memory is running out...&quot;</span>);</span><br><span class="line">        logger.fine(<span class="string">&quot;ignored.&quot;</span>);</span><br><span class="line">        logger.severe(<span class="string">&quot;process will be terminated...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Mar 02, 2019 6:32:13 PM Hello main</span><br><span class="line">INFO: start process...</span><br><span class="line">Mar 02, 2019 6:32:13 PM Hello main</span><br><span class="line">WARNING: memory is running out...</span><br><span class="line">Mar 02, 2019 6:32:13 PM Hello main</span><br><span class="line">SEVERE: process will be terminated...</span><br></pre></td></tr></table></figure>

<p>可以看出 fine 的日志没有打印出来。</p>
<p>默认日志级别是 INFO，该级别以下的日志不会被打印出来。</p>
<p>JDK 的 Logging 定义了7个日志级别，从严重到普通：</p>
<ul>
<li>SEVERE</li>
<li>WARNING</li>
<li>INFO</li>
<li>CONFIG</li>
<li>FINE</li>
<li>FINER</li>
<li>FINEST</li>
</ul>
<p><strong>局限</strong></p>
<p>Logging 系统在 JVM 启动时读取配置文件并完成初始化，一旦开始运行<code>main()</code>方法，就无法修改配置；</p>
<p>配置不方便，需要在JVM启动时传递参数<code>-Djava.util.logging.config.file=&lt;config-file-name&gt;</code>。</p>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><p>除了 int 等基本类型外，Java 的其他类型全部都是 class，包括 interface。</p>
<blockquote>
<p>JVM也为 int 等基本类型创建了 Class 实例。</p>
</blockquote>
<p>而<code>class</code>是由JVM在执行过程中动态加载的。JVM在第一次读取到一种<code>class</code>类型时，将其加载进内存。</p>
<blockquote>
<p>没有加载到的class是无法通过Class.forName()找到的。</p>
</blockquote>
<p>每加载一种<code>class</code>，JVM就为其创建一个<code>Class</code>类型的实例，并关联起来。注意：这里的<code>Class</code>类型是一个名叫<code>Class</code>的<code>class</code>。它长这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Class</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Class</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以<code>String</code>类为例，当JVM加载<code>String</code>类时，它首先读取<code>String.class</code>文件到内存，然后，为<code>String</code>类创建一个<code>Class</code>实例并关联起来：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Class</span>(String);</span><br></pre></td></tr></table></figure>

<p><strong>每个类的Class实例是唯一的。</strong></p>
<p><strong>每个类的<code>Class</code>实例包含了该<code>class</code>的所有完整信息：</strong></p>
<p><img src="/../assets/image-20240417190242743.png" alt="image-20240417190242743"></p>
<p>所以可以通过某个类的 Class 实例获取这个类的所有信息，这种操作被称为反射。</p>
<p><strong>动态加载特性</strong></p>
<p>动态加载<code>class</code>的特性对于Java程序非常重要。</p>
<p>利用JVM动态加载<code>class</code>的特性，我们才能在运行期根据条件加载不同的实现类。</p>
<p>例如，Commons Logging总是优先使用Log4j，只有当Log4j不存在时，才使用JDK的logging。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Commons Logging优先使用Log4j:</span></span><br><span class="line"><span class="type">LogFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (isClassPresent(<span class="string">&quot;org.apache.logging.log4j.Logger&quot;</span>)) &#123;</span><br><span class="line">    factory = createLog4j();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    factory = createJdkLog();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isClassPresent</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class.forName(name);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a><strong>基本使用</strong></h3><h4 id="如何获取一个类的Class实例"><a href="#如何获取一个类的Class实例" class="headerlink" title="如何获取一个类的Class实例"></a><strong>如何获取一个类的Class实例</strong></h4><ol>
<li><p>通过类的静态变量class获取</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clz</span> <span class="operator">=</span> String.class;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过类的某个实例的 getClass() 方法获取</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">Class</span> <span class="variable">clz</span> <span class="operator">=</span> s.getClass();</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过 Class 的静态方法获取</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数为类的完整包路径</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="对比-instanceof"><a href="#对比-instanceof" class="headerlink" title="对比 instanceof"></a><strong>对比 instanceof</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> n <span class="keyword">instanceof</span> Integer; <span class="comment">// true，因为n是Integer类型</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b2</span> <span class="operator">=</span> n <span class="keyword">instanceof</span> Number; <span class="comment">// true，因为n是Number类型的子类</span></span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b3</span> <span class="operator">=</span> n.getClass() == Integer.class; <span class="comment">// true，因为n.getClass()返回Integer.class</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b4</span> <span class="operator">=</span> n.getClass() == Number.class; <span class="comment">// false，因为Integer.class!=Number.class</span></span><br></pre></td></tr></table></figure>

<p>instanceof 不但可以匹配相同类型，还可以匹配该类型的父类</p>
<p>而 Class 实例只能匹配其本身的类型，因为每个 class 都有唯一的 Class 实例。</p>
<h4 id="获取类的基本信息"><a href="#获取类的基本信息" class="headerlink" title="获取类的基本信息"></a><strong>获取类的基本信息</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        printClassInfo(<span class="string">&quot;&quot;</span>.getClass());</span><br><span class="line">        printClassInfo(Runnable.class);</span><br><span class="line">        printClassInfo(java.time.Month.class);</span><br><span class="line">        printClassInfo(String[].class);</span><br><span class="line">        printClassInfo(<span class="type">int</span>.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printClassInfo</span><span class="params">(Class cls)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Class name: &quot;</span> + cls.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;Simple name: &quot;</span> + cls.getSimpleName());</span><br><span class="line">        <span class="keyword">if</span> (cls.getPackage() != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Package name: &quot;</span> + cls.getPackage().getName());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;is interface: &quot;</span> + cls.isInterface());</span><br><span class="line">        System.out.println(<span class="string">&quot;is enum: &quot;</span> + cls.isEnum());</span><br><span class="line">        System.out.println(<span class="string">&quot;is array: &quot;</span> + cls.isArray());</span><br><span class="line">        System.out.println(<span class="string">&quot;is primitive: &quot;</span> + cls.isPrimitive());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数组（例如<code>String[]</code>）也是一种类，而且不同于<code>String.class</code>，它的类名是<code>[Ljava.lang.String;</code>。</p>
<h4 id="创建新实例"><a href="#创建新实例" class="headerlink" title="创建新实例"></a><strong>创建新实例</strong></h4><p>如果获取到了一个<code>Class</code>实例，我们就可以通过该<code>Class</code>实例来创建对应类型的实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取String的Class实例:</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> String.class;</span><br><span class="line"><span class="comment">// 创建一个String实例:</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> (String) cls.newInstance();</span><br></pre></td></tr></table></figure>



<h3 id="Field"><a href="#Field" class="headerlink" title="Field"></a>Field</h3><p>通过类的 Class 实例可以获取到该类的<strong>所有实例</strong>的字段信息。</p>
<h4 id="获取方法介绍："><a href="#获取方法介绍：" class="headerlink" title="获取方法介绍："></a><strong>获取方法介绍：</strong></h4><ul>
<li>Field getField(name)：根据字段名获取某个 public 的field（包括父类）</li>
<li>Field[] getFields()：获取所有 public 的field（包括父类）</li>
<li>Field getDeclaredField(name)：根据字段名获取当前类的某个field（不包括父类）</li>
<li>Field[] getDeclaredFields()：获取当前类的所有field（不包括父类）</li>
</ul>
<p>getDeclaredField 相比于 getField 更针对<strong>自身声明的所有字段（包括private）</strong></p>
<h4 id="Field对象属性介绍"><a href="#Field对象属性介绍" class="headerlink" title="Field对象属性介绍"></a><strong>Field对象属性介绍</strong></h4><ul>
<li><code>getName()</code>：返回字段名称，例如，<code>&quot;name&quot;</code>；</li>
<li><code>getType()</code>：返回字段类型，也是一个<code>Class</code>实例，例如，<code>String.class</code>；</li>
<li><code>getModifiers()</code>：返回字段的修饰符，它是一个<code>int</code>，不同的bit表示不同的含义。</li>
</ul>
<p>以<code>String</code>类的<code>value</code>字段为例，它的定义是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span>[] value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们用反射获取该字段的信息，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> String.class.getDeclaredField(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">f.getName(); <span class="comment">// &quot;value&quot;</span></span><br><span class="line">f.getType(); <span class="comment">// class [B 表示byte[]类型</span></span><br><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> f.getModifiers();</span><br><span class="line">Modifier.isFinal(m); <span class="comment">// true</span></span><br><span class="line">Modifier.isPublic(m); <span class="comment">// false</span></span><br><span class="line">Modifier.isProtected(m); <span class="comment">// false</span></span><br><span class="line">Modifier.isPrivate(m); <span class="comment">// true</span></span><br><span class="line">Modifier.isStatic(m); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h4 id="获取字段值"><a href="#获取字段值" class="headerlink" title="获取字段值"></a><strong>获取字段值</strong></h4><p><code>f.get(Object)</code> 获取该字段在指定实例的值。</p>
<p>因为每个类只有一个 Class，其中的每个字段只有一个 Field，而类的实例存在多个。</p>
<p>因此要想获取该字段的值，必须指定是哪个实例，所以才要传入实例。</p>
<p>但是不能直接访问非 public 字段，需要声明访问许可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">f.setAccessible(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p>不声明直接访问 private 字段会抛出 <code>IllegalAccessException</code> 非法访问异常。</p>
<p><code>setAccessible(true)</code>可能会失败。</p>
<p>如果JVM运行期存在<code>SecurityManager</code>，那么它会根据规则进行检查，有可能阻止<code>setAccessible(true)</code>。</p>
<p>例如，某个<code>SecurityManager</code>可能不允许对<code>java</code>和<code>javax</code>开头的<code>package</code>的类调用<code>setAccessible(true)</code>，这样可以保证JVM核心库的安全。</p>
<h4 id="设置字段值"><a href="#设置字段值" class="headerlink" title="设置字段值"></a><strong>设置字段值</strong></h4><p><code>f.set(Object1, Object2)</code> 设置指定实例 Object1 的 Field 字段值为 Object2。</p>
<p>同理，修改非 public 字段，需要声明访问许可。</p>
<h3 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h3><p>通过 Class 实例也可以获取该类的所有 method 方法信息。</p>
<h4 id="获取方法（类似Field）"><a href="#获取方法（类似Field）" class="headerlink" title="获取方法（类似Field）"></a><strong>获取方法（类似Field）</strong></h4><ul>
<li><code>Method getMethod(name, Class...)</code>：获取某个<code>public</code>的<code>Method</code>（包括父类）</li>
<li><code>Method[] getMethods()</code>：获取所有<code>public</code>的<code>Method</code>（包括父类）</li>
<li><code>Method getDeclaredMethod(name, Class...)</code>：获取当前类的某个<code>Method</code>（不包括父类）</li>
<li><code>Method[] getDeclaredMethods()</code>：获取当前类的所有<code>Method</code>（不包括父类）</li>
</ul>
<p>区别：因为方法允许重载，所以在获取 Method 实例时除了需要指定方法名外，还需要显式的按顺序指定参数类型。</p>
<h4 id="Method-实例属性介绍"><a href="#Method-实例属性介绍" class="headerlink" title="Method 实例属性介绍"></a><strong>Method 实例属性介绍</strong></h4><ul>
<li><code>getName()</code>：返回方法名称，例如：<code>&quot;getScore&quot;</code>；</li>
<li><code>getReturnType()</code>：返回方法返回值类型，也是一个Class实例，例如：<code>String.class</code>；</li>
<li><code>getParameterTypes()</code>：返回方法的参数类型，是一个Class数组，例如：<code>&#123;String.class, int.class&#125;</code>；</li>
<li><code>getModifiers()</code>：返回方法的修饰符，它是一个<code>int</code>，不同的bit表示不同的含义。</li>
</ul>
<h4 id="调用实例方法"><a href="#调用实例方法" class="headerlink" title="调用实例方法"></a><strong>调用实例方法</strong></h4><p><code>m.invoke(Object, ...params)</code> 调用指定实例的实例方法，类似 Field 的 get 用法。</p>
<p>当我们获取到一个<code>Method</code>对象时，就可以对它进行调用。我们以下面的代码为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello world&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">r</span> <span class="operator">=</span> s.substring(<span class="number">6</span>); <span class="comment">// &quot;world&quot;</span></span><br></pre></td></tr></table></figure>

<p>改写为反射来调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// String对象:</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello world&quot;</span>;</span><br><span class="line">        <span class="comment">// 获取String substring(int)方法，参数为int:</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> String.class.getMethod(<span class="string">&quot;substring&quot;</span>, <span class="type">int</span>.class);</span><br><span class="line">        <span class="comment">// 在s对象上调用该方法并获取结果:</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">r</span> <span class="operator">=</span> (String) m.invoke(s, <span class="number">6</span>);</span><br><span class="line">        <span class="comment">// 打印调用结果:</span></span><br><span class="line">        System.out.println(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="调用静态方法"><a href="#调用静态方法" class="headerlink" title="调用静态方法"></a><strong>调用静态方法</strong></h4><p><code>m.invoke(null, ...params)</code></p>
<p>由于静态方法是直接绑定到类实例上的，所以第一个参数永远是 null。</p>
<h4 id="调用非-public-方法"><a href="#调用非-public-方法" class="headerlink" title="调用非 public 方法"></a><strong>调用非 public 方法</strong></h4><p>也和 Field 类似，需要声明访问许可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">m.setAccessible(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a><strong>多态</strong></h4><p>一个<code>Person</code>类定义了<code>hello()</code>方法，并且它的子类<code>Student</code>也覆写了<code>hello()</code>方法</p>
<p>如果从Person类的 Class 获取Method实例，作用于 Student 实例时，调用的是谁的方法。</p>
<p>答案：会调用 Student 的，可能是因为每个 Method 是唯一的，作用于哪个实例，就是哪个实例的方法。</p>
<p>因此，使用反射调用方法时，仍然遵循多态原则：即总是调用实际类型的覆写方法（如果存在）。上述的反射代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> Person.class.getMethod(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">m.invoke(<span class="keyword">new</span> <span class="title class_">Student</span>());</span><br></pre></td></tr></table></figure>

<p>实际上相当于：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">p.hello();</span><br></pre></td></tr></table></figure>



<h3 id="Constructor"><a href="#Constructor" class="headerlink" title="Constructor"></a>Constructor</h3><p>通常使用<code>new</code>操作符创建新的实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br></pre></td></tr></table></figure>

<p>如果通过反射来创建新的实例，可以调用Class提供的newInstance()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> Person.class.newInstance();</span><br></pre></td></tr></table></figure>

<p>直接调用 <code>newInstance()</code> 方法只能调用该类的<strong>public无参数</strong>构造方法。</p>
<p>如果构造方法带有参数，或者不是public，就无法直接通过Class.newInstance()来调用。</p>
<p>因此，Java提供了这个类似Field、Method的Constructor类，包含了一个 Class 的所有构造方法信息。</p>
<h4 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a><strong>获取方法</strong></h4><ul>
<li><code>getConstructor(Class...)</code>：获取某个<code>public</code>的<code>Constructor</code>；</li>
<li><code>getConstructors()</code>：获取所有<code>public</code>的<code>Constructor</code>；</li>
<li><code>getDeclaredConstructor(Class...)</code>：获取某个<code>Constructor</code>；</li>
<li><code>getDeclaredConstructors()</code>：获取所有<code>Constructor</code>。</li>
</ul>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a><strong>使用</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取构造方法Integer(int):</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">cons1</span> <span class="operator">=</span> Integer.class.getConstructor(<span class="type">int</span>.class);</span><br><span class="line">        <span class="comment">// 调用构造方法:</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">n1</span> <span class="operator">=</span> (Integer) cons1.newInstance(<span class="number">123</span>);</span><br><span class="line">        System.out.println(n1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样，调用非<code>public</code>的<code>Constructor</code>时，必须首先通过<code>setAccessible(true)</code>设置允许访问。</p>
<h3 id="获取继承关系"><a href="#获取继承关系" class="headerlink" title="获取继承关系"></a>获取继承关系</h3><h4 id="获取父类的Class"><a href="#获取父类的Class" class="headerlink" title="获取父类的Class"></a><strong>获取父类的Class</strong></h4><p>有了<code>Class</code>实例，我们还可以获取它的父类的<code>Class</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">i</span> <span class="operator">=</span> Integer.class;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">n</span> <span class="operator">=</span> i.getSuperclass();</span><br><span class="line">        System.out.println(n);</span><br><span class="line">        <span class="type">Class</span> <span class="variable">o</span> <span class="operator">=</span> n.getSuperclass();</span><br><span class="line">        System.out.println(o);</span><br><span class="line">        System.out.println(o.getSuperclass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行上述代码可以看到，<code>Integer</code>的父类类型是<code>Number</code>，<code>Number</code>的父类是<code>Object</code>，<code>Object</code>的父类是<code>null</code>，因为所有的类都是继承于 <code>Objcet</code>。</p>
<p>除<code>Object</code>外，其他任何非<code>interface</code>的<code>Class</code>都必定存在一个父类类型。</p>
<h4 id="获取interface"><a href="#获取interface" class="headerlink" title="获取interface"></a><strong>获取interface</strong></h4><p>通过<code>clz.getInterfaces()</code> 方法可以查询到该类实现的接口类型。</p>
<p>例如，查询<code>Integer</code>实现的接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">s</span> <span class="operator">=</span> Integer.class;</span><br><span class="line">        Class[] is = s.getInterfaces();</span><br><span class="line">        <span class="keyword">for</span> (Class i : is) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行上述代码可知，<code>Integer</code>实现的接口有：</p>
<ul>
<li>java.lang.Comparable</li>
<li>java.lang.constant.Constable</li>
<li>java.lang.constant.ConstantDesc</li>
</ul>
<p>注意：</p>
<ol>
<li><code>getInterfaces()</code>只返回当前类直接实现的接口类型，<strong>并不包括其父类实现的接口类型</strong></li>
<li>如果一个类没有实现任何<code>interface</code>，那么<code>getInterfaces()</code>返回空数组。</li>
</ol>
<h4 id="继承关系判断"><a href="#继承关系判断" class="headerlink" title="继承关系判断"></a><strong>继承关系判断</strong></h4><p>要判断一个类是否可以赋值给另一个类（向上转型）可以调用<code>isAssignableFrom()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Number n = ?</span></span><br><span class="line">Number.class.isAssignableFrom(Integer.class); <span class="comment">// true，因为Integer可以赋值给Number</span></span><br><span class="line"><span class="comment">// Integer i = ?</span></span><br><span class="line">Integer.class.isAssignableFrom(Number.class); <span class="comment">// false，因为Number不能赋值给Integer</span></span><br></pre></td></tr></table></figure>



<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>Java 中，是不能直接实例化 interface 的。</p>
<p>所有<code>interface</code>类型的变量总是通过某个实例向上转型并赋值给接口类型变量的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">CharSequence</span> <span class="variable">cs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br></pre></td></tr></table></figure>

<p>但是 Java 标准库提供了一种动态代理（Dynamic Proxy）的机制：可以在运行期动态创建某个<code>interface</code>的实例。</p>
<p>就是不去实现，而是在代码运行中动态创建并使用。</p>
<p>通过JDK提供的一个<code>Proxy.newProxyInstance()</code>创建一个<code>Hello</code>接口对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                System.out.println(method);</span><br><span class="line">                <span class="comment">// 匹配对应方法，执行自定义内容</span></span><br><span class="line">                <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;morning&quot;</span>)) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Good morning, &quot;</span> + args[<span class="number">0</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Hello</span> <span class="variable">hello</span> <span class="operator">=</span> (Hello) Proxy.newProxyInstance(</span><br><span class="line">            Hello.class.getClassLoader(), <span class="comment">// 传入ClassLoader</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; Hello.class &#125;, <span class="comment">// 传入要实现的接口</span></span><br><span class="line">            handler); <span class="comment">// 传入处理调用方法的InvocationHandler</span></span><br><span class="line">        hello.morning(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">morning</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>动态创建 interface 实现类步骤</strong></p>
<ol>
<li>定义一个<code>InvocationHandler</code>实例，它负责实现接口的方法调用；</li>
<li>通过 Proxy.newProxyInstance() 创建 interface 实例，传入3个参数：<ol>
<li>使用的<code>ClassLoader</code>，通常就是接口类的<code>ClassLoader</code>；</li>
<li>需要实现的接口数组，至少需要传入一个接口进去（这里传入接口本身的 Class 实例）；</li>
<li>用来处理接口方法调用的<code>InvocationHandler</code>实例。</li>
</ol>
</li>
<li>将返回的<code>Object</code>强制转型为接口。</li>
</ol>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h3 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h3><p>注解是放在Java源码的类、方法、字段、参数前的一种特殊“注释”。</p>
<p><strong>区别于注释：</strong></p>
<p>注释会被编译器直接忽略，注解则可以被编译器打包进入class文件，可以把注解看做是一种用作标注的“元数据”。</p>
<p><strong>分类</strong></p>
<p>Java的注解可以分为三类：</p>
<p><strong>第一类</strong>是由<strong>编译器</strong>使用的注解，作用于编译阶段，例如：</p>
<ul>
<li><p><code>@Override</code>：让编译器检查该方法是否正确地实现了覆写；</p>
</li>
<li><p><code>@SuppressWarnings</code>：告诉编译器忽略此处代码产生的警告。</p>
</li>
</ul>
<p>这类注解不会被编译进入<code>.class</code>文件，它们在编译后就被编译器扔掉了。</p>
<p><strong>第二类</strong>是由<strong>底层工具</strong>处理<code>.class</code>文件使用的注解。</p>
<p>比如在加载class的时候对class做动态修改，实现一些特殊的功能（如Lombok加一些属性等）。</p>
<p>这类注解会被编译进入<code>.class</code>文件，但加载结束后并不会存在于内存中。</p>
<p><strong>第三类</strong>是在<strong>程序运行期</strong>能够读取的注解，它们在加载后一直存在于JVM中，程序在运行中可以随时捕捉和处理。</p>
<p>例如，一个配置了<code>@PostConstruct</code>的方法会在调用构造方法后自动被调用（这是Java代码读取该注解实现的功能，JVM并不会识别该注解）。</p>
<h3 id="定义注解"><a href="#定义注解" class="headerlink" title="定义注解"></a><strong>定义注解</strong></h3><h4 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a><strong>配置参数</strong></h4><p>定义一个注解时可以定义配置参数。配置参数必须是<strong>不可变类型</strong>，包括：</p>
<ul>
<li>所有基本类型；</li>
<li>String；</li>
<li>枚举类型；</li>
<li>基本类型、String、Class以及枚举的数组。</li>
</ul>
<p>还允许为配置参数指定默认值，缺少某个配置参数时将使用默认值。</p>
<p>大部分注解会有一个名为<code>value</code>的配置参数，对此参数赋值，可以只写常量省略value参数名称。</p>
<p>即配置注解时，如果配置的参数名称是<code>value</code>，且只有一个参数，那么可以省略参数名称。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="meta">@Check(min=0, max=100, value=55)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Check(value=99)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> p;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Check(99)</span> <span class="comment">// @Check(value=99)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Check</span>	   <span class="comment">// 全部配置参数使用默认值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="定义格式"><a href="#定义格式" class="headerlink" title="定义格式"></a><strong>定义格式</strong></h4><p>Java语言使用<code>@interface</code>语法来定义注解（<code>Annotation</code>），它的格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">type</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    String <span class="title function_">level</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;info&quot;</span>;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a><strong>元注解</strong></h4><p>有一些注解可以修饰其他注解，这些注解就称为元注解（meta annotation）。</p>
<p>Java标准库已经定义了一些元注解，我们只需要使用元注解，通常不需要自己去编写元注解。</p>
<h5 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h5><p>最常用的元注解是<code>@Target</code>。使用<code>@Target</code>可以定义<code>Annotation</code>能够被应用于源码的哪些位置：</p>
<ul>
<li>类或接口：<code>ElementType.TYPE</code>；</li>
<li>字段：<code>ElementType.FIELD</code>；</li>
<li>方法：<code>ElementType.METHOD</code>；</li>
<li>构造方法：<code>ElementType.CONSTRUCTOR</code>；</li>
<li>方法参数：<code>ElementType.PARAMETER</code>。</li>
</ul>
<p>例如，定义注解<code>@Report</code>可用在方法上，我们必须添加一个<code>@Target(ElementType.METHOD)</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">type</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    String <span class="title function_">level</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;info&quot;</span>;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义注解<code>@Report</code>可用在方法或字段上，可以把<code>@Target</code>注解参数变为数组<code>&#123; ElementType.METHOD, ElementType.FIELD &#125;</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;</span></span><br><span class="line"><span class="meta">    ElementType.METHOD,</span></span><br><span class="line"><span class="meta">    ElementType.FIELD</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上<code>@Target</code>定义的<code>value</code>是<code>ElementType[]</code>数组，<strong>只有一个元素时，可以省略数组的写法</strong>。</p>
<h5 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h5><p>另一个重要的元注解<code>@Retention</code>定义了<code>Annotation</code>的生命周期：</p>
<ul>
<li><p>仅编译期：<code>RetentionPolicy.SOURCE</code>；</p>
<p>提供给编译器使用，编译结束后会丢掉。</p>
</li>
<li><p>仅class文件：<code>RetentionPolicy.CLASS</code>；</p>
<p>用于修改底层class结构，不会被JVM加载。</p>
</li>
<li><p>运行期：<code>RetentionPolicy.RUNTIME</code>。</p>
<p>可以在程序运行中捕获和处理，最常用。</p>
</li>
</ul>
<p>如果<code>@Retention</code>不存在，则该<code>Annotation</code>默认为<code>CLASS</code>。</p>
<p>因为通常我们自定义的<code>Annotation</code>都是<code>RUNTIME</code>，所以要加上<code>@Retention(RetentionPolicy.RUNTIME)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">type</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    String <span class="title function_">level</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;info&quot;</span>;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Repeatable"><a href="#Repeatable" class="headerlink" title="@Repeatable"></a>@Repeatable</h5><p>使用<code>@Repeatable(Class)</code>这个元注解可以定义<code>Annotation</code>是否可重复标注在同一个地方。</p>
<p>并将重复的注解读到目标 Class 的参数中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将多个 Report 记录到 Reports 注解中。</span></span><br><span class="line"><span class="meta">@Repeatable(Reports.class)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">type</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    String <span class="title function_">level</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;info&quot;</span>;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Reports &#123;</span><br><span class="line">    Report[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过<code>@Repeatable</code>修饰后，在某个类型声明处，就可以添加多个<code>@Report</code>注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Report(type=1, level=&quot;debug&quot;)</span></span><br><span class="line"><span class="meta">@Report(type=2, level=&quot;warning&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h5><p>使用<code>@Inherited</code>定义子类是否可继承父类定义的<code>Annotation</code>。</p>
<p><code>@Inherited</code>仅针对<code>@Target(ElementType.TYPE)</code>类型的<code>annotation</code>有效，并且对<code>interface</code>的继承无效：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">type</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    String <span class="title function_">level</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;info&quot;</span>;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在使用的时候，如果一个类用到了<code>@Report</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Report(type=1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>则它的子类默认也定义了该注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="自定义-Annotation-步骤"><a href="#自定义-Annotation-步骤" class="headerlink" title="自定义 Annotation 步骤"></a>自定义 Annotation 步骤</h4><ol>
<li>用<code>@interface</code>定义注解：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>定义配置参数、默认值：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">type</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    String <span class="title function_">level</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;info&quot;</span>;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把最常用的参数定义为<code>value()</code>，推荐所有参数都尽量设置默认值。</p>
<ol start="3">
<li>用元注解配置注解：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">type</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    String <span class="title function_">level</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;info&quot;</span>;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，必须设置<code>@Target</code>和<code>@Retention</code>，<code>@Retention</code>一般设置为<code>RUNTIME</code>，因为我们自定义的注解通常要求在运行期读取。一般情况下，不必写<code>@Inherited</code>和<code>@Repeatable</code>。</p>
<h3 id="读取处理注解"><a href="#读取处理注解" class="headerlink" title="读取处理注解"></a>读取处理注解</h3><p><code>SOURCE</code>类型的注解主要由编译器使用，因此我们一般只使用，不编写。</p>
<p><code>CLASS</code>类型的注解主要由底层工具库使用，涉及到class的加载，一般我们很少用到。</p>
<p>只有<code>RUNTIME</code>类型的注解不但要使用，还经常需要编写。</p>
<p>因此，以下方式针对 RUNTIME 类型处理。</p>
<h4 id="读取注解："><a href="#读取注解：" class="headerlink" title="读取注解："></a><strong>读取注解</strong>：</h4><p>判断某个注解是否存在于<code>Class</code>、<code>Field</code>、<code>Method</code>或<code>Constructor</code>：</p>
<ul>
<li><code>Class.isAnnotationPresent(Class)</code></li>
<li><code>Field.isAnnotationPresent(Class)</code></li>
<li><code>Method.isAnnotationPresent(Class)</code></li>
<li><code>Constructor.isAnnotationPresent(Class)</code></li>
</ul>
<p>使用反射API读取Annotation：</p>
<ul>
<li><code>Class.getAnnotation(Class)</code></li>
<li><code>Field.getAnnotation(Class)</code></li>
<li><code>Method.getAnnotation(Class)</code></li>
<li><code>Constructor.getAnnotation(Class)</code></li>
</ul>
<p>使用反射API读取<code>Annotation</code>有两种方法。</p>
<ol>
<li>先判断<code>Annotation</code>是否存在，如果存在，就直接读取：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Person.class;</span><br><span class="line"><span class="keyword">if</span> (cls.isAnnotationPresent(Report.class)) &#123;</span><br><span class="line">    <span class="type">Report</span> <span class="variable">report</span> <span class="operator">=</span> cls.getAnnotation(Report.class);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>是直接读取<code>Annotation</code>，如果<code>Annotation</code>不存在，将返回<code>null</code>：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Person.class;</span><br><span class="line"><span class="type">Report</span> <span class="variable">report</span> <span class="operator">=</span> cls.getAnnotation(Report.class);</span><br><span class="line"><span class="keyword">if</span> (report != <span class="literal">null</span>) &#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读取方法、字段和构造方法的<code>Annotation</code>和Class类似。</p>
<p>但要读取方法参数的<code>Annotation</code>就比较麻烦一点，因为方法参数本身可以看成一个数组，而每个参数又可以定义多个注解。</p>
<p>所以，方法参数的所有注解用一个二维数组来表示。</p>
<p>例如，对于以下方法定义的注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">(<span class="meta">@NotNull</span> <span class="meta">@Range(max=5)</span> String name, <span class="meta">@NotNull</span> String prefix)</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要读取方法参数的注解，我们先用反射获取<code>Method</code>实例，然后读取方法参数的所有注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取Method实例:</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> ...</span><br><span class="line"><span class="comment">// 获取所有参数的Annotation:</span></span><br><span class="line">Annotation[][] annos = m.getParameterAnnotations();</span><br><span class="line"><span class="comment">// 第一个参数（索引为0）的所有Annotation:</span></span><br><span class="line">Annotation[] annosOfName = annos[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (Annotation anno : annosOfName) &#123;</span><br><span class="line">    <span class="keyword">if</span> (anno <span class="keyword">instanceof</span> Range r) &#123; <span class="comment">// @Range注解</span></span><br><span class="line">        <span class="comment">// 获取range注解的max参数值</span></span><br><span class="line">        r.max();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anno <span class="keyword">instanceof</span> NotNull n) &#123; <span class="comment">// @NotNull注解</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="处理注解"><a href="#处理注解" class="headerlink" title="处理注解"></a>处理注解</h4><p>注解本身只是一个标注，被标注的对象如何处理完全由程序自己决定。</p>
<p>例如，JUnit是一个测试框架，它会自动运行所有标记为<code>@Test</code>的方法。</p>
<p>以<code>@Range</code>注解标注一个<code>String</code>字段为例，要求标注了这个注解的字段长度满足注解配置参数要求：</p>
<ol>
<li>定义注解</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Range &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">min</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">max</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">255</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用注解</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="meta">@Range(min=1, max=20)</span></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Range(max=10)</span></span><br><span class="line">    <span class="keyword">public</span> String city;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>处理注解</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">check</span><span class="params">(Person person)</span> <span class="keyword">throws</span> IllegalArgumentException, ReflectiveOperationException &#123;</span><br><span class="line">    <span class="comment">// 遍历所有Field:</span></span><br><span class="line">    <span class="keyword">for</span> (Field field : person.getClass().getFields()) &#123;</span><br><span class="line">        <span class="comment">// 获取Field定义的@Range:</span></span><br><span class="line">        <span class="type">Range</span> <span class="variable">range</span> <span class="operator">=</span> field.getAnnotation(Range.class);</span><br><span class="line">        <span class="comment">// 如果@Range存在:</span></span><br><span class="line">        <span class="keyword">if</span> (range != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取Field的值:</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> field.get(person);</span><br><span class="line">            <span class="comment">// 如果值是String:</span></span><br><span class="line">            <span class="keyword">if</span> (value <span class="keyword">instanceof</span> String s) &#123;</span><br><span class="line">                <span class="comment">// 判断值是否满足@Range的min/max:</span></span><br><span class="line">                <span class="keyword">if</span> (s.length() &lt; range.min() || s.length() &gt; range.max()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Invalid field: &quot;</span> + field.getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样一来，通过标注<code>@Range</code>注解，配合<code>check()</code>方法处理，就完成了<code>Person</code>实例的检查。</p>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p><strong>为什么需要泛型？</strong></p>
<p>复用，类型安全，避免出现误转型</p>
<p><strong>泛型的原理</strong></p>
<p>“类型擦除”，自动转型。</p>
<h3 id="定义泛型"><a href="#定义泛型" class="headerlink" title="定义泛型"></a>定义泛型</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(T e)</span> &#123;...&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;...&#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在类名后头用<code>&lt;T&gt;</code>声明类型参数，这个类型可以是任意类型。</p>
<blockquote>
<p>定义接口泛型也是类似</p>
</blockquote>
<h4 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a><strong>向上转型</strong></h4><p><code>ArrayList&lt;Integer&gt;</code>不可以向上转型为<code>ArrayList&lt;Number&gt;</code>或<code>List&lt;Number&gt;</code>。</p>
<p>&#x3D;&#x3D;<strong>泛型不一致不能向上转型</strong>&#x3D;&#x3D;</p>
<p>如果允许成功赋值，在对它进行读取时就会出现类型错误，如 Double 写入了本就是 Integer 的 Number。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建ArrayList&lt;Integer&gt;类型：</span></span><br><span class="line">ArrayList&lt;Integer&gt; integerList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line"><span class="comment">// 添加一个Integer：</span></span><br><span class="line">integerList.add(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">123</span>));</span><br><span class="line"><span class="comment">// “向上转型”为ArrayList&lt;Number&gt;：</span></span><br><span class="line">ArrayList&lt;Number&gt; numberList = integerList;</span><br><span class="line"><span class="comment">// 添加一个Float，因为Float也是Number：</span></span><br><span class="line">numberList.add(<span class="keyword">new</span> <span class="title class_">Float</span>(<span class="number">12.34</span>));</span><br><span class="line"><span class="comment">// 从ArrayList&lt;Integer&gt;获取索引为1的元素（即添加的Float）：</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> integerList.get(<span class="number">1</span>); <span class="comment">// ClassCastException!</span></span><br></pre></td></tr></table></figure>

<p>允许类型<code>ArrayList&lt;T&gt;</code>可以向上转型为<code>List&lt;T&gt;</code>，必须保证泛型一致。</p>
<p>T 可以是 ?，表示可以是任意类型</p>
<p><code>ArrayList&lt;T&gt;</code>可以向上转型为 <code>ArrayList&lt;?&gt; </code></p>
<h4 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(T first, T last)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.first = first;</span><br><span class="line">        <span class="built_in">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getFirst</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getLast</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对静态方法使用&lt;T&gt;:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Pair&lt;T&gt; <span class="title function_">create</span><span class="params">(T first, T last)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;T&gt;(first, last);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>像这种直接在静态方法中使用泛型参数会报错，但是可以用声明泛型方法的方式来使用泛型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 静态泛型方法应该使用其他类型区分:</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K&gt; Pair&lt;K&gt; <span class="title function_">create</span><span class="params">(K first, K last)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;K&gt;(first, last);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态方法的泛型参数是区别于泛型类的，因为不用指定泛型也可以使用静态方法。</p>
<h4 id="多个泛型"><a href="#多个泛型" class="headerlink" title="多个泛型"></a>多个泛型</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T, K&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> K last;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(T first, K last)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.first = first;</span><br><span class="line">        <span class="built_in">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getFirst</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">public</span> K <span class="title function_">getLast</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类似 <code>Map&lt;K, V&gt;</code></p>
<h3 id="使用泛型"><a href="#使用泛型" class="headerlink" title="使用泛型"></a>使用泛型</h3><p>使用<code>ArrayList</code>带有泛型的类时，如果不声明泛型类型时，泛型类型实际上就是<code>Object</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编译器警告:</span></span><br><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">list.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;World&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">first</span> <span class="operator">=</span> (String) list.get(<span class="number">0</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">second</span> <span class="operator">=</span> (String) list.get(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>此时，只能把<code>&lt;T&gt;</code>当作<code>Object</code>使用，没有发挥泛型的优势，依旧需要手动转型。</p>
<p>当我们定义泛型类型<code>&lt;String&gt;</code>后，<code>List&lt;T&gt;</code>的泛型接口变为强类型<code>List&lt;String&gt;</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无编译器警告:</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;World&quot;</span>);</span><br><span class="line"><span class="comment">// 无强制转型:</span></span><br><span class="line"><span class="type">String</span> <span class="variable">first</span> <span class="operator">=</span> list.get(<span class="number">0</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">second</span> <span class="operator">=</span> list.get(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>如果类型声明了泛型类型，在 new 实例时可以省略，由编译器自动推断。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以省略后面的Number，编译器可以自动推断泛型类型：</span></span><br><span class="line">List&lt;Number&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>



<h3 id="擦拭法"><a href="#擦拭法" class="headerlink" title="擦拭法"></a>擦拭法</h3><p>擦拭法是指，虚拟机对泛型其实一无所知，所有的工作像对泛型的检查和转换都是编译器做的。</p>
<p>擦拭法的效果：</p>
<ul>
<li>编译器把类型<code>&lt;T&gt;</code>视为<code>Object</code>；</li>
<li>编译器根据<code>&lt;T&gt;</code>实现安全的强制转型。</li>
</ul>
<p>使用泛型的时候，我们编写的代码也是编译器看到的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair&lt;String&gt; p = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">first</span> <span class="operator">=</span> p.getFirst();</span><br><span class="line"><span class="type">String</span> <span class="variable">last</span> <span class="operator">=</span> p.getLast();</span><br></pre></td></tr></table></figure>

<p>而虚拟机执行的代码并没有泛型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Pair</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pair</span>(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">first</span> <span class="operator">=</span> (String) p.getFirst();</span><br><span class="line"><span class="type">String</span> <span class="variable">last</span> <span class="operator">=</span> (String) p.getLast();</span><br></pre></td></tr></table></figure>

<p>所以，Java的泛型是由编译器在编译时实行的，<strong>编译器</strong>内部永远把所有类型<code>T</code>视为<code>Object</code>处理，但是，在需要转型的时候，<strong>编译器</strong>会根据<code>T</code>的类型自动为我们实行安全地强制转型。</p>
<h4 id="带来的局限"><a href="#带来的局限" class="headerlink" title="带来的局限"></a>带来的局限</h4><ol>
<li><code>&lt;T&gt;</code>不能是基本类型，因为基本类型无法对Object进行强制转型。</li>
<li>泛型类的 Class 实例都是同一个</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair&lt;String&gt; p1 = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">Pair&lt;Integer&gt; p2 = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line"><span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> p1.getClass();</span><br><span class="line"><span class="type">Class</span> <span class="variable">c2</span> <span class="operator">=</span> p2.getClass();</span><br><span class="line">System.out.println(c1==c2); <span class="comment">// true</span></span><br><span class="line">System.out.println(c1==Pair.class); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>无法用 instanceof 判断带泛型的类型</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair&lt;Integer&gt; p = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line"><span class="comment">// Compile error:</span></span><br><span class="line"><span class="keyword">if</span> (p <span class="keyword">instanceof</span> Pair&lt;String&gt;) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>不能使用 new 关键字实例化 T 类型，因为实际上会变成<code>new Object()</code></li>
</ol>
<h4 id="不能覆写Object类的方法"><a href="#不能覆写Object类的方法" class="headerlink" title="不能覆写Object类的方法"></a>不能覆写Object类的方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(T t)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.val == t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果覆盖了Object方法，会导致两个类被向上转型为Object时，出现类型转换错误。</p>
<h4 id="泛型继承"><a href="#泛型继承" class="headerlink" title="泛型继承"></a>泛型继承</h4><p>一个类可以继承自一个泛型类。例如：父类的类型是<code>Pair&lt;Integer&gt;</code>，子类的类型是<code>IntPair</code>，可以这么继承：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntPair</span> <span class="keyword">extends</span> <span class="title class_">Pair</span>&lt;Integer&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用的时候，因为子类<code>IntPair</code>并没有泛型类型，所以，正常使用即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">IntPair</span> <span class="variable">ip</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntPair</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>前面讲了，我们无法获取<code>Pair&lt;T&gt;</code>的<code>T</code>类型，即给定一个变量<code>Pair&lt;Integer&gt; p</code>，无法从<code>p</code>中获取到<code>Integer</code>类型。</p>
<p>但是在父类是泛型类型的情况下，编译器会把类型<code>T</code>（对<code>IntPair</code>来说，也就是<code>Integer</code>类型）保存到子类的class文件中，不然编译器就不知道<code>IntPair</code>只能存取<code>Integer</code>这种类型。</p>
<h4 id="获取父类泛型类型"><a href="#获取父类泛型类型" class="headerlink" title="获取父类泛型类型"></a>获取父类泛型类型</h4><p>在继承了泛型类型的情况下，子类可以获取父类的泛型类型。</p>
<p>例如：<code>IntPair</code>可以获取到父类的泛型类型<code>Integer</code>。获取父类的泛型类型代码比较复杂：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.ParameterizedType;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Class&lt;IntPair&gt; clazz = IntPair.class;</span><br><span class="line">        <span class="type">Type</span> <span class="variable">t</span> <span class="operator">=</span> clazz.getGenericSuperclass();</span><br><span class="line">        <span class="keyword">if</span> (t <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">            <span class="type">ParameterizedType</span> <span class="variable">pt</span> <span class="operator">=</span> (ParameterizedType) t;</span><br><span class="line">            Type[] types = pt.getActualTypeArguments(); <span class="comment">// 可能有多个泛型类型</span></span><br><span class="line">            <span class="type">Type</span> <span class="variable">firstType</span> <span class="operator">=</span> types[<span class="number">0</span>]; <span class="comment">// 取第一个泛型类型</span></span><br><span class="line">            Class&lt;?&gt; typeClass = (Class&lt;?&gt;) firstType;</span><br><span class="line">            System.out.println(typeClass); <span class="comment">// Integer</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="类型标识继承关系"><a href="#类型标识继承关系" class="headerlink" title="类型标识继承关系"></a>类型标识继承关系</h4><p><img src="/../assets/image-20240423215603321.png" alt="image-20240423215603321"></p>
<h3 id="extends、super"><a href="#extends、super" class="headerlink" title="extends、super"></a>extends、super</h3><h4 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Pair&lt;Integer&gt; p = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> add(p);</span><br><span class="line">        System.out.println(n);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(Pair&lt;? extends Number&gt; p)</span> &#123;</span><br><span class="line">        <span class="type">Number</span> <span class="variable">first</span> <span class="operator">=</span> p.getFirst();</span><br><span class="line">        <span class="type">Number</span> <span class="variable">last</span> <span class="operator">=</span> p.getLast();</span><br><span class="line">        <span class="keyword">return</span> first.intValue() + last.intValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>? extends Number</code> 表示该泛型可以是Number或其子类。</p>
<p>允许传入 <code>Pair&lt;Integer&gt;</code>。</p>
<p>这种使用<code>&lt;? extends Number&gt;</code>的泛型定义称之为上界通配符（Upper Bounds Wildcards），即把泛型类型<code>T</code>的上界限定在<code>Number</code>了。</p>
<p>如果声明的类型是 <code>Pair&lt;Number&gt;</code> ，无法传入 <code>Pair&lt;Integer&gt;</code> ，因为后者无法向上转型为前者。</p>
<p><strong>限制：</strong></p>
<p>方法参数签名<code>setFirst(? extends Number)</code>无法传递任何<code>Number</code>的子类型给<code>setFirst(? extends Number)</code>。</p>
<p>因为 Double 和 Integer 都可以传入，编译器会阻止这种类型不安全的行为。</p>
<p>例外：可以传入 null</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">p.setFirst(<span class="literal">null</span>); <span class="comment">// ok, 但是后面会抛出NullPointerException</span></span><br><span class="line">p.getFirst().intValue(); <span class="comment">// NullPointerException</span></span><br></pre></td></tr></table></figure>

<p><strong>应用场景</strong></p>
<p>使用 extends 限定 T 的上界</p>
<p>例如定义 <code>Pair&lt;T extends Number&gt;</code>，则该泛型参数 T 只能传入 Number 的子类。</p>
<blockquote>
<p>T 和 ? 的区别：</p>
<p>? 表示一个通配符，可以传入任何类型。</p>
<p>T 表示一个泛型参数，在定义泛型类或方法时，需要用 T 来描述其他内容。</p>
</blockquote>
<h4 id="super"><a href="#super" class="headerlink" title="super"></a>super</h4><p>和 extends 相反，super 限定了 T 的下界。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">set</span><span class="params">(Pair&lt;? <span class="built_in">super</span> Integer&gt; p, Integer first, Integer last)</span> &#123;</span><br><span class="line">    p.setFirst(first);</span><br><span class="line">    p.setLast(last);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>? super Integer</code> 表示接收泛型类型为 Integer 或其父类。</p>
<p><strong>限制</strong></p>
<p>super 允许写，不允许读。</p>
<p>因为类型无法向下转型。</p>
<h4 id="对比extends和super通配符"><a href="#对比extends和super通配符" class="headerlink" title="对比extends和super通配符"></a>对比extends和super通配符</h4><p>我们再回顾一下<code>extends</code>通配符。作为方法参数，<code>&lt;? extends T&gt;</code>类型和<code>&lt;? super T&gt;</code>类型的区别在于：</p>
<ul>
<li><code>&lt;? extends T&gt;</code>允许调用读方法<code>T get()</code>获取<code>T</code>的引用，但不允许调用写方法<code>set(T)</code>传入<code>T</code>的引用（传入<code>null</code>除外）；</li>
<li><code>&lt;? super T&gt;</code>允许调用写方法<code>set(T)</code>传入<code>T</code>的引用，但不允许调用读方法<code>T get()</code>获取<code>T</code>的引用（获取<code>Object</code>除外）。</li>
</ul>
<p>一个是允许读不允许写，另一个是允许写不允许读。</p>
<p>先记住上面的结论，我们来看Java标准库的<code>Collections</code>类定义的<code>copy()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Collections</span> &#123;</span><br><span class="line">    <span class="comment">// 把src的每个元素复制到dest中:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">copy</span><span class="params">(List&lt;? <span class="built_in">super</span> T&gt; dest, List&lt;? extends T&gt; src)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;src.size(); i++) &#123;</span><br><span class="line">            <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> src.get(i);</span><br><span class="line">            dest.add(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>为什么 super 支持写，extends 支持读</strong></p>
<p>写：因为 super 可以传入 T 的超类，此时的泛型就有可能是 T 或其超类，在 set 时就允许向上转型赋值；而 extends 允许传入子类，如果对其赋值，就是向下转型了。</p>
<p>写：因为 extends 允许传入子类，此时的泛型就是 T 或其子类，那么 get 时，就可以使用 T （上界）来接收，满足向上转型，而 super 允许传入超类，此时这个 T 就是它的下界，不允许向下赋值。</p>
<p>因此，super和extends的读写，可以单独允许Object和null</p>
<h4 id="无限定通配符"><a href="#无限定通配符" class="headerlink" title="无限定通配符"></a>无限定通配符</h4><p>Java的泛型还允许使用无限定通配符（Unbounded Wildcard Type），即只定义一个<code>?</code>：</p>
<p>因为<code>&lt;?&gt;</code>通配符既没有<code>extends</code>，也没有<code>super</code>，因此：</p>
<ul>
<li>不允许调用<code>set(T)</code>方法并传入引用（<code>null</code>除外）；</li>
<li>不允许调用<code>T get()</code>方法并获取<code>T</code>引用（只能获取<code>Object</code>引用）。</li>
</ul>
<p>换句话说，既不能读，也不能写，那只能做一些<code>null</code>判断：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isNull</span><span class="params">(Pair&lt;?&gt; p)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> p.getFirst() == <span class="literal">null</span> || p.getLast() == <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大多数情况下，可以引入泛型参数<code>&lt;T&gt;</code>消除<code>&lt;?&gt;</code>通配符：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="type">boolean</span> <span class="title function_">isNull</span><span class="params">(Pair&lt;T&gt; p)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> p.getFirst() == <span class="literal">null</span> || p.getLast() == <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>&lt;?&gt;</code>通配符有一个独特的特点，就是：<code>Pair&lt;?&gt;</code>是所有<code>Pair&lt;T&gt;</code>的超类：</p>
<h3 id="泛型和反射"><a href="#泛型和反射" class="headerlink" title="泛型和反射"></a>泛型和反射</h3><h4 id="泛型-Class"><a href="#泛型-Class" class="headerlink" title="泛型 Class"></a>泛型 Class</h4><p>Java的部分反射API也是泛型。例如：<code>Class&lt;T&gt;</code>就是泛型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// compile warning:</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> String.class;</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String) clazz.newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">// no warning:</span></span><br><span class="line">Class&lt;String&gt; clazz = String.class;</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> clazz.newInstance();</span><br></pre></td></tr></table></figure>

<p>调用<code>Class</code>的<code>getSuperclass()</code>方法返回的<code>Class</code>类型是<code>Class&lt;? super T&gt;</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;? <span class="built_in">super</span> String&gt; sup = String.class.getSuperclass();</span><br></pre></td></tr></table></figure>

<h4 id="泛型-Constructor"><a href="#泛型-Constructor" class="headerlink" title="泛型 Constructor"></a>泛型 Constructor</h4><p>构造方法<code>Constructor&lt;T&gt;</code>也是泛型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;Integer&gt; clazz = Integer.class;</span><br><span class="line">Constructor&lt;Integer&gt; cons = clazz.getConstructor(<span class="type">int</span>.class);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> cons.newInstance(<span class="number">123</span>);</span><br></pre></td></tr></table></figure>

<h4 id="泛型数组"><a href="#泛型数组" class="headerlink" title="泛型数组"></a>泛型数组</h4><p>我们可以<strong>声明</strong>带泛型的数组，但不能用<code>new</code>操作符<strong>创建</strong>带泛型的数组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair&lt;String&gt;[] ps = <span class="literal">null</span>; <span class="comment">// ok</span></span><br><span class="line">Pair&lt;String&gt;[] ps = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;String&gt;[<span class="number">2</span>]; <span class="comment">// compile error!</span></span><br></pre></td></tr></table></figure>

<p>可以通过强制转型实现“带泛型”的数组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">Pair&lt;String&gt;[] ps = (Pair&lt;String&gt;[]) <span class="keyword">new</span> <span class="title class_">Pair</span>[<span class="number">2</span>];</span><br></pre></td></tr></table></figure>

<p>但是数组实际上在运行期没有泛型，而是 <code>Pair&lt;Object&gt;[]</code>。</p>
<p>因为类型擦拭，只能通过编译器来强制检查变量<code>ps</code>。</p>
<p><strong>注意：通过绕过泛型声明的引用依旧可以使用任意类型修改创建的数组</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair[] arr = <span class="keyword">new</span> <span class="title class_">Pair</span>[<span class="number">2</span>];</span><br><span class="line">Pair&lt;String&gt;[] ps = (Pair&lt;String&gt;[]) arr;</span><br><span class="line"></span><br><span class="line">ps[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;String&gt;(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>);</span><br><span class="line">arr[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;Integer&gt;(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ClassCastException:</span></span><br><span class="line">Pair&lt;String&gt; p = ps[<span class="number">1</span>];</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> p.getFirst();</span><br></pre></td></tr></table></figure>

<p>虽然这两个变量实际上指向同一个数组，但是操作<code>arr</code>可以传入非String的参数。</p>
<p><strong>要安全地使用泛型声明数组，必须扔掉原来<code>arr</code>的引用：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">Pair&lt;String&gt;[] ps = (Pair&lt;String&gt;[]) <span class="keyword">new</span> <span class="title class_">Pair</span>[<span class="number">2</span>];</span><br></pre></td></tr></table></figure>

<p>上面的代码中，由于拿不到原始数组的引用，就只能对泛型数组<code>ps</code>进行操作，这种操作就是安全的。</p>
<p>带泛型的数组实际上是编译器的类型擦除：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair[] arr = <span class="keyword">new</span> <span class="title class_">Pair</span>[<span class="number">2</span>];</span><br><span class="line">Pair&lt;String&gt;[] ps = (Pair&lt;String&gt;[]) arr;</span><br><span class="line"></span><br><span class="line">System.out.println(ps.getClass() == Pair[].class); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> (String) arr[<span class="number">0</span>].getFirst();</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> ps[<span class="number">0</span>].getFirst();</span><br></pre></td></tr></table></figure>

<p>所以我们不能直接创建泛型数组<code>T[]</code>，因为擦拭后代码变为<code>Object[]</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// compile error:</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Abc</span>&lt;T&gt; &#123;</span><br><span class="line">    T[] createArray() &#123;</span><br><span class="line">        <span class="comment">// 实际上返回 Object[]，换个引用就可以随意get,set任何类型</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">T</span>[<span class="number">5</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>创建泛型数组</strong></p>
<ol>
<li>借助<code>Class&lt;T&gt;</code>来创建泛型数组：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">T[] createArray(Class&lt;T&gt; cls) &#123;</span><br><span class="line">    <span class="keyword">return</span> (T[]) Array.newInstance(cls, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>利用可变参数创建泛型数组<code>T[]</code>：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayHelper</span> &#123;</span><br><span class="line">    <span class="meta">@SafeVarargs</span></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; T[] asArray(T... objs) &#123;</span><br><span class="line">        <span class="keyword">return</span> objs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String[] ss = ArrayHelper.asArray(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">Integer[] ns = ArrayHelper.asArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<h4 id="谨慎使用泛型可变参数"><a href="#谨慎使用泛型可变参数" class="headerlink" title="谨慎使用泛型可变参数"></a>谨慎使用泛型可变参数</h4><p>在上面的例子中，我们看到，通过：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; T[] asArray(T... objs) &#123;</span><br><span class="line">    <span class="keyword">return</span> objs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>似乎可以安全地创建一个泛型数组。但实际上，这种方法非常危险。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] arr = asArray(<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">        <span class="comment">// ClassCastException:</span></span><br><span class="line">        String[] firstTwo = pickTwo(<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(firstTwo));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &lt;K&gt; K[] pickTwo(K k1, K k2, K k3) &#123;</span><br><span class="line">        <span class="comment">// 传入的 k1, k2 参数其实是 Object 类型</span></span><br><span class="line">        <span class="keyword">return</span> asArray(k1, k2);  <span class="comment">// 返回 Object[]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; T[] asArray(T... objs) &#123;</span><br><span class="line">        <span class="comment">// 直接返回可变参数数组，可以识别，返回 T[]</span></span><br><span class="line">        <span class="keyword">return</span> objs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接调用<code>asArray(T...)</code>没有问题，直接将获取到的类型参数数组返回。</p>
<p>而如果在另一个方法中调用该方法，传入参数时，参数的类型已经被擦除了。</p>
<p>所以就会返回Object[]，然后产生<code>ClassCastException</code>。</p>
<p>编译器对所有可变泛型参数都会发出警告，只有确认完全没有问题，才可以用<code>@SafeVarargs</code>消除警告。</p>
<p> &#x3D;&#x3D;如果在<strong>方法内部</strong>创建了泛型数组，最好不要将它返回给外部使用。&#x3D;&#x3D;</p>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><p>List 只是一个接口，用来规范使用方法。</p>
<ul>
<li>在末尾添加一个元素：<code>boolean add(E e)</code></li>
<li>在指定索引添加一个元素：<code>boolean add(int index, E e)</code></li>
<li>删除指定索引的元素：<code>E remove(int index)</code></li>
<li>删除某个元素：<code>boolean remove(Object e)</code></li>
<li>获取指定索引的元素：<code>E get(int index)</code></li>
<li>获取链表大小（包含元素的个数）：<code>int size()</code></li>
</ul>
<p>要创建一个 List 实例，可以借助 <code>ArrayList</code> 或 <code>LinkedList</code>。</p>
<p>一个是线性表，一个是链表，区别如下。</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">ArrayList</th>
<th>LinkedList</th>
</tr>
</thead>
<tbody><tr>
<td align="left">获取指定元素</td>
<td align="left">速度很快</td>
<td>需要从头开始查找元素</td>
</tr>
<tr>
<td align="left">添加元素到末尾</td>
<td align="left">速度很快</td>
<td>速度很快</td>
</tr>
<tr>
<td align="left">在指定位置添加&#x2F;删除</td>
<td align="left">需要移动元素</td>
<td>不需要移动元素</td>
</tr>
<tr>
<td align="left">内存占用</td>
<td align="left">少</td>
<td>较大</td>
</tr>
</tbody></table>
<h4 id="List-of"><a href="#List-of" class="headerlink" title="List.of"></a>List.of</h4><p>Java 11以后，可以用 List.of(…T) 静态方法创建一个<strong>只读</strong>的列表。</p>
<p>注意：</p>
<ol>
<li>不允许传入 null</li>
<li>对只读<code>List</code>调用<code>add()</code>、<code>remove()</code>方法会抛出<code>UnsupportedOperationException</code>。</li>
</ol>
<h4 id="List转Array"><a href="#List转Array" class="headerlink" title="List转Array"></a>List转Array</h4><ol>
<li><p>直接调用 toArray 方法，返回 Object 类型数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object[] array = list.toArray();</span><br></pre></td></tr></table></figure>
</li>
<li><p>传入一个数组，返回该数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] arr = list.toArray(<span class="keyword">new</span> <span class="title class_">Integer</span>[<span class="number">5</span>]);</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>传入的数组类型如果和list类型无法兼容，会抛出 <code>ArrayStoreException</code></li>
<li>如果传入的数组容量比list小，会被截掉</li>
</ul>
</li>
<li><p>传入数组的构造方法引用</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] arr = intList.toArray(Integer[]::<span class="keyword">new</span>)</span><br></pre></td></tr></table></figure>



<h4 id="Array转List"><a href="#Array转List" class="headerlink" title="Array转List"></a>Array转List</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(...T)</span><br></pre></td></tr></table></figure>



<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h4 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h4><p>同 List，Map 只是一个接口</p>
<p><strong>常用方法</strong></p>
<ul>
<li>插入元素：<code>V put(K key, V value)</code></li>
<li>访问value：<code>V get(K key)</code></li>
<li>是否包含某个key：<code>boolean containsKey(K key)</code></li>
<li>是否包含某个value：<code>boolean containsKey(K key)</code></li>
<li>返回所有的key：<code>Set&lt;K&gt; keySet()</code></li>
<li>返回所有的value：<code>Collection&lt;V&gt; values()</code></li>
<li>返回所有的键值对：<code>Set&lt;Entry&lt;K, v&gt;&gt; entrySet()</code></li>
</ul>
<p><strong>注意：</strong></p>
<ol>
<li>不存在重复的key，如果对相同的key进行put，会替换掉这个key映射的value，并返回上次的value。</li>
<li>keySet  不一定是有序的。</li>
</ol>
<p><strong>实现类</strong></p>
<ol>
<li>HashMap：无序</li>
<li>TreeMap：有序，可以传入一个比较器来给key排序，默认按照key本身的Comparator</li>
</ol>
<h4 id="HashMap的本质"><a href="#HashMap的本质" class="headerlink" title="HashMap的本质"></a>HashMap的本质</h4><p>通过空间换时间，用一个大数组来存储value，这样就可以直接索引。</p>
<p><strong>步骤：</strong></p>
<ol>
<li>通过 key 的 equals 方法进行匹配到对应的 key</li>
<li>再通过 key 的 hashCode 方法计算出 hash 值，即该 key 对应 value 在数组中存储的索引值。</li>
</ol>
<p><strong>数组长度</strong></p>
<p>HashMap 初始化时默认的数组大小只有 16。</p>
<p>通过类似如下算法的方式，控制 hash 值的分布范围：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> key.hashCode() &amp; <span class="number">0xf</span>; <span class="comment">// 0xf = 15</span></span><br></pre></td></tr></table></figure>

<p>如果添加到超过初始长度后，内部会进行扩容。</p>
<p>&#x3D;&#x3D;为了能方便进行位运算，每次扩容后的长度会保证为 2^n^&#x3D;&#x3D;</p>
<p>为了保证性能，最少创建时就指定相应的容量</p>
<blockquote>
<p>使用 ArrayList 实现类同理</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">10000</span>);</span><br></pre></td></tr></table></figure>

<p>虽然指定容量是<code>10000</code>，但<code>HashMap</code>内部的数组长度总是2n，因此，实际数组长度被初始化为比<code>10000</code>大的<code>16384</code>（214）。</p>
<h4 id="hashcode重复"><a href="#hashcode重复" class="headerlink" title="hashcode重复"></a>hashcode重复</h4><p>假如存入了两个 key，但是非常巧合的是它们的 hashcode 重复了。</p>
<p>那么，在<code>HashMap</code>的数组中，存储的就不是一个 value 了</p>
<p><strong>而是一个由重复的 hashcode 对应 key 的 value 的 <code>List</code>，包含这两个 key 对应的键值对。</strong></p>
<p>于是查找的方法，就不只是直接索引了，而是索引之后再遍历这个 list，找到相应的 key。</p>
<p>如果冲突的概率越大，这个<code>List</code>就越长，<code>Map</code>的<code>get()</code>方法效率就越低</p>
<p>不同的<code>key</code>具有相同的<code>hashCode()</code>的情况称之为<strong>哈希冲突</strong>。</p>
<blockquote>
<p>在冲突的时候，一种最简单的解决办法是用<code>List</code>存储<code>hashCode()</code>相同的<code>key-value</code>。</p>
<p>也可以用链表，树等结构</p>
</blockquote>
<p>总之：hash 值的唯一性决定了 HashMap 的查询性能。</p>
<h4 id="对比-Hashtable"><a href="#对比-Hashtable" class="headerlink" title="对比 Hashtable"></a>对比 Hashtable</h4><ol>
<li>继承类不同 dictionary</li>
<li>提供接口不同</li>
<li>对 key-value 的 null 值</li>
<li>线程安全</li>
<li>遍历方式</li>
<li>容量分配</li>
<li>hash值计算方式</li>
</ol>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><h4 id="使用-3"><a href="#使用-3" class="headerlink" title="使用"></a>使用</h4><p><code>Set</code>用于存储不重复的元素集合，它主要提供以下几个方法：</p>
<ul>
<li>将元素添加进<code>Set&lt;E&gt;</code>：<code>boolean add(E e)</code></li>
<li>将元素从<code>Set&lt;E&gt;</code>删除：<code>boolean remove(Object e)</code></li>
<li>判断是否包含元素：<code>boolean contains(Object e)</code></li>
</ul>
<h4 id="HashSet的本质"><a href="#HashSet的本质" class="headerlink" title="HashSet的本质"></a>HashSet的本质</h4><p><code>HashSet</code>仅仅是对<code>HashMap</code>的一个简单封装，只管理key，而放入相同的Object作为value。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSet</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Set</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="comment">// 持有一个HashMap:</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;E, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 放入HashMap的value:</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.put(e, PRESENT) == <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.containsKey(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.remove(o) == PRESENT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="SortedSet"><a href="#SortedSet" class="headerlink" title="SortedSet"></a>SortedSet</h4><p>Set 是无序的，而 SortedSet 接口继承至 Set，并且是有序的。</p>
<p>实现类是：TreeSet，需要传入一个比较器，如果没有就使用 key 默认的比较器。</p>
<h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><blockquote>
<p>File类，与输入输出流都存放在Java.io包内。</p>
</blockquote>
<p>&#x3D;&#x3D;所有的输入输出类，都必须被异常处理包裹，捕捉FileNotFoundException&#x3D;&#x3D;</p>
<h5 id="1-File类"><a href="#1-File类" class="headerlink" title="1. File类"></a>1. File类</h5><p>File对象主要用来获取文件本身的一些信息，不涉及对文件的读写操作。</p>
<p><strong>构造函数</strong></p>
<ul>
<li>File(String filename);</li>
<li>File(String directoryPath,String filename);</li>
<li>File(File f，String filename);</li>
</ul>
<p>&#x3D;&#x3D;即使文件不存在，也不会报出异常&#x3D;&#x3D;</p>
<p><strong>常用方法</strong></p>
<ul>
<li>public String getName() 获取文件的名字。</li>
<li>public boolean canRead() 判断文件是否是可读的。</li>
<li>public boolean canWrite() 判断文件是否可被写入。</li>
<li>public boolean exits() 判断文件是否存在。</li>
<li>public <strong>long</strong> length() 获取文件的长度（单位是字节）。</li>
</ul>
<p>即长度为该文件内容为多少个字节，返回类型是long。</p>
<p>假如文件内容为：我是who12(整型)1000（long类型），那么读取到的length为4+3+4+8 &#x3D; 19个字节。</p>
<ul>
<li>public String getAbsolutePath() 获取文件的绝对路径。</li>
<li>public boolean isFile() 判断文件是否是一个普通文件，而不是目录。</li>
<li>public boolean isDirectroy() 判断文件是否是一个目录。</li>
</ul>
<h5 id="2-输入输出流"><a href="#2-输入输出流" class="headerlink" title="2. 输入输出流"></a>2. 输入输出流</h5><ul>
<li>FileInputStream</li>
</ul>
<p>以字节的形式读取文件</p>
<p>FileInputStream(String name);<br>FileInputStream(File file);<br>int read() 读取单个字节的数据<br>int read(byte b[]) 读取到字节数组b中，返回读取的实际字节长度，如果到达文件末尾则返回-1。<br>int read(byte b[]，int off，int len) 读取文件内容从off位置len个字节到字节数组b中</p>
<ul>
<li>FileOutputStream</li>
</ul>
<p>以字节的形式写入文件</p>
<p><strong>区别</strong> void write(byte b[],int off,int len) 从字节数组中偏移量off处取len个字节写到目的地。</p>
<ul>
<li>FileReader</li>
</ul>
<p>以字符的形式读取文件</p>
<p>nt read() 读取单个字符的数据<br>int read(char b[]) 读取到字符数组b中<br>int read(char b[]，int off，int len) 读取从off位置len个字符到字符数组b中</p>
<ul>
<li>FileWriter</li>
</ul>
<p>以字符的形式写入文件</p>
<p>使用方法类比即可</p>
<h5 id="3-缓冲流"><a href="#3-缓冲流" class="headerlink" title="3. 缓冲流"></a>3. 缓冲流</h5><p>缓冲流只能指向FileWriter或FileReader类对象，相较于提供了更多输入输出的方法，可以提高大文件（数据）的读写速度。</p>
<ul>
<li>BufferedReader，BufferedWriter</li>
</ul>
<p>readLine() 读取文本行<br>write(String s,int off,int len) 把字符串s写到文件中<br>newLine(); 向文件写入一个回行符</p>
<h5 id="4-随机访问文件流"><a href="#4-随机访问文件流" class="headerlink" title="4. 随机访问文件流"></a>4. 随机访问文件流</h5><p>RandomAccessFile类可以同时实现输入和输出操作。</p>
<p>构造函数：</p>
<p>RandomAccessFile(String name,String mode) ;<br>RandomAccessFile(File file,String mode) ;</p>
<p>mode指对文件的操作方式，如：r 表示只读，rw表示读和写，w表示写入。</p>
<p>使用方法：</p>
<p>read();</p>
<p>writeInt(); writeLong();</p>
<p>seek(long a)  定位RandomAccessFile流的读写位置<br>getFilePointer() 获取流的当前读写位置</p>
<p><strong>还有对象流（用来输入输出对象）等一些乱七八糟的</strong></p>
<h2 id="日期与时间"><a href="#日期与时间" class="headerlink" title="日期与时间"></a>日期与时间</h2><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><h2 id="加密与安全"><a href="#加密与安全" class="headerlink" title="加密与安全"></a>加密与安全</h2><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>多线程可以让程序同时执行多个任务。</p>
<p>但它的本质是<strong>多个任务轮流进行</strong>，比如让浏览器执行0.001秒，让QQ执行0.001秒，再让音乐播放器执行0.001秒，在人看来，CPU就是在同时执行多个任务。</p>
<p>即使是多核CPU，因为任务的数量往往多于CPU的核数，所以任务也是交替进行的。 </p>
<p><strong>为什么多线程操作在程序中往往比单线程快？</strong></p>
<p>以MySQL插入数据为例</p>
<p>因为MySQL内部将调度任务分为了多个线程，如果插入操作是单线程的，就无法占满所有的线程。</p>
<p>相当于给你10个工人，你却只用了一个工人。</p>
<blockquote>
<p>为什么MySQL内部需要多线程？</p>
<p>可能是因为有一些操作需要同时进行，如守护线程 :question:</p>
</blockquote>
<p>总之：在应用多线程中间件（到达目的地的管道）时，同时使用多线程操作才会比单线程快。</p>
<h3 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a><strong>进程与线程</strong></h3><p><img src="/assets/image-20240409104301471.png" alt="image-20240409104301471"></p>
<p>在计算机中，<strong>一个任务整体称为一个进程</strong>。</p>
<p>例如，浏览器就是一个进程，视频播放器是另一个进程，类似的，音乐播放器和Word都是进程。</p>
<p>一个任务整体（进程）里可以包含多个子任务（线程）。</p>
<p>例如，浏览器可以打开多个窗口，同时查看不同网站的内容，此时浏览器进程程执行了多个显示窗口的线程。</p>
<p><strong>进程与线程的关系</strong>：一个进程可以包含一个或多个线程，但<strong>至少</strong>会有一个线程。</p>
<blockquote>
<p><strong>操作系统调度的最小任务单位其实不是进程，而是线程。</strong></p>
</blockquote>
<p><strong>多进程和多线程对比</strong>：</p>
<p>多进程的缺点：</p>
<ol>
<li><p>开销大，创建进程开销大，尤其是在Windows系统上；</p>
</li>
<li><p>通信慢，进程间通信 比 线程间通信要慢，因为线程间通信就是读写同一个变量，速度很快。</p>
</li>
</ol>
<p>多进程的优点：</p>
<ol>
<li><p>稳定性高，多进程稳定性比多线程高，</p>
<p>因为在多进程的情况下，一个进Java程崩溃不会影响其他进程，而在多线程的情况下，任何一个线程崩溃会直接导致整个进程崩溃。</p>
</li>
</ol>
<h3 id="JVM-多线程"><a href="#JVM-多线程" class="headerlink" title="JVM 多线程"></a>JVM 多线程</h3><p>Java 语言内置了多线程支持，一个Java程序实际上是一个JVM进程。</p>
<p>JVM进程用一个主线程来执行<code>main()</code>方法，在<code>main()</code>方法内部也可以启动多个子线程。</p>
<p>此外，JVM还有负责垃圾回收的其他工作线程等。</p>
<p>和单线程相比，<strong>多线程编程的特点</strong>在于：多线程经常需要读写共享数据，并且需要同步。</p>
<h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><p><strong>创建步骤：</strong></p>
<ol>
<li>实例化一个Thread类对象，重写 run() 方法。</li>
<li>再调用Thread对象的start()方法，开启一个新线程。</li>
<li>线程启动后，会自动调用Thread对象的 run() 方法。</li>
</ol>
<p>在这种创建方法中，run方法体的内容就代表这该线程需要执行的任务。</p>
<p><strong>重写 run 的几种方法：</strong></p>
<ol>
<li>继承<code>Thread</code>类，重写<code>run()</code>方法：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start new thread!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>创建<code>Thread</code>实例时，传入一个<code>Runnable</code>实例：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">        t.start(); <span class="comment">// 启动新线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start new thread!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>或者直接传入Runable接口匿名类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>也可以使用 Java 8 后的 lambda 表达式</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>又或者使用T创建 Thread 匿名类，重写run方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：</p>
<ul>
<li><p>在通过start()方法启动新线程后，该线程不一定立即执行。</p>
</li>
<li><p>直接调用线程的run()方法，无法启动新线程，只是执行一个普通方法而已。</p>
<p>线程的开启由 start() 方法代理，执行 run() 方法内容。</p>
</li>
</ul>
<p><strong>线程休眠</strong></p>
<p>通过调用 <code>Thread.sleep(milliseconds)</code> 静态方法，可以使线程休眠 x 毫秒</p>
<p>线程休眠方法会抛出 <code>InterruptedException</code> checked异常，必须显式捕获异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>设置线程的优先级</strong></p>
<p>可以在线程内部调用 <code>Thread.setPriority(n)</code>设置线程的优先级（1 - 10），默认值是5。</p>
<p>优先级高的线程被操作系统调度的优先级较高。</p>
<p>操作系统对高优先级线程可能调度更频繁，<strong>但无法确保高优先级的线程一定会先执行。</strong></p>
<h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><p>一个新的线程开启后，只会执行一次 run 方法，执行完毕代表该线程结束。</p>
<p>线程的状态有以下几种：</p>
<ul>
<li>New：新创建的线程，尚未执行；</li>
<li>Runnable：运行中的线程，正在执行<code>run()</code>方法的Java代码；</li>
<li>Blocked：运行中的线程，因为某些操作被阻塞而挂起；</li>
<li>Waiting：运行中的线程，因为某些操作在等待中；</li>
<li>Timed Waiting：运行中的线程，因为执行<code>sleep()</code>方法正在计时等待；</li>
<li>Terminated：线程已终止，因为<code>run()</code>方法执行完毕。</li>
</ul>
<p><img src="/assets/image-20240409113233199.png" alt="image-20240409113233199"></p>
<p>当线程启动后，它可以在<code>Runnable</code>、<code>Blocked</code>、<code>Waiting</code>和<code>Timed Waiting</code>这几个状态之间切换，直到最后变成<code>Terminated</code>状态，线程终止。</p>
<p><strong>线程终止的原因</strong>有：</p>
<ul>
<li>线程正常终止：<code>run()</code>方法执行到<code>return</code>语句返回；</li>
<li>线程意外终止：<code>run()</code>方法因为未捕获的异常导致线程终止；</li>
<li>对某个线程的<code>Thread</code>实例调用<code>stop()</code>方法强制终止（强烈不推荐使用）。</li>
</ul>
<h3 id="等待线程"><a href="#等待线程" class="headerlink" title="等待线程"></a><strong>等待线程</strong></h3><p>一个线程还可以等待另一个线程直到其运行结束。</p>
<p>例如，<code>main</code>线程在启动<code>t</code>线程后，可以通过<code>t.join()</code>等待<code>t</code>线程结束后再继续运行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;start&quot;</span>);</span><br><span class="line">        t.start();</span><br><span class="line">        t.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>join</code> <strong>含义理解</strong>：</p>
<p>t 线程加入 main 线程任务中，作为任务执行的一个步骤，只有等 t 执行完毕，main 线程任务的步骤才可以继续往下执行。</p>
<p>&#x3D;&#x3D;改正：不是等 t 执行完毕，而是等该线程调度结束，例如，死循环线程不会一直执行。&#x3D;&#x3D;</p>
<p>如果<code>t</code>线程已经结束，对实例<code>t</code>调用<code>join()</code>会立刻返回。</p>
<p>此外，<code>join(long)</code>的重载方法也可以指定一个等待时间，超过等待时间后就不再继续等待（就不要它加入了嘿嘿）。</p>
<h3 id="中断线程"><a href="#中断线程" class="headerlink" title="中断线程"></a>中断线程</h3><p>如果线程需要执行一个 <strong>长时间任务</strong>，就可能需要能<strong>控制的</strong>中断线程，确保这个任务是可控的。</p>
<p>中断线程有三种方法：</p>
<ol>
<li><strong>调用线程对象的<code>interrupt()</code>方法</strong></li>
</ol>
<p>通过调用interrupt方法，给线程传递一个中断的信号。</p>
<p><strong>目标线程需要通过调用继承 Thread 的 <code>isInterrupted()</code> 方法，反复检测自身状态是否是 interrupted 状态。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        t.start();</span><br><span class="line">        Thread.sleep(<span class="number">1</span>); 	<span class="comment">// 暂停 Main 线程1毫秒，确保线程 t 运行一次再结束。</span></span><br><span class="line">        t.interrupt(); 		<span class="comment">// 中断 t 线程</span></span><br><span class="line">        t.join(); 			<span class="comment">// 将 t 线程加入到 main 线程中，确保 “end” 最后输出</span></span><br><span class="line">        System.out.println(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 检测中断信号</span></span><br><span class="line">        <span class="keyword">while</span> (! isInterrupted()) &#123;</span><br><span class="line">            n ++;</span><br><span class="line">            System.out.println(n + <span class="string">&quot; hello!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong>首先开启了一个新的线程 t，该线程监听中断信号不断循环输出 hello（模拟长时间任务），然后 main 线程发出中断信号，同时 t 线程中的循环监听到了中断信号，随后停止运行，重新回到 main 线程继续执行，最后输出 “end”。</p>
<p><strong>注意：</strong>如果线程内没有检测中断信号，只是调用 <code>interrupt()</code> 方法线程是不会中断的。</p>
<p><strong>应用场景：</strong></p>
<p>首先需要注意的是，通过 interrupt 方法中断线程的前提，是目标线程必须时刻监听中断信号。</p>
<p>因此，目标线程应该将<strong>长时间任务转化为分片的任务</strong>，循环进行，同时监听中断信号。</p>
<ol start="2">
<li><strong>监听目标线程内其他线程的 join 方法。</strong></li>
</ol>
<p>假设有两个线程 A，B。</p>
<p>A 线程中对 B 线程调用了 join() 方法，而此时 A 线程又收到了 interrupt 信号</p>
<p>那么 join 方法就会抛出一个 <code>InterruptedException</code> 异常，A 线程就会结束运行。</p>
<p><strong>结束点</strong>：目标线程内部其他线程的 join 时刻</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        <span class="comment">// 开启线程 A</span></span><br><span class="line">        a.start();</span><br><span class="line">        a.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        <span class="comment">// 开启线程 B</span></span><br><span class="line">        b.start();</span><br><span class="line">        <span class="comment">// 捕获异常，但不做处理</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            b.join();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;&#125;</span><br><span class="line">        <span class="comment">// 中断线程 B</span></span><br><span class="line">        b.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(!isInterrupted())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;run&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">break</span>;	<span class="comment">// 如果不加break，概率导致死循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>为什么线程 B 监听了中断信号，在捕获异常时还需要 break？</strong></p>
<p>因为在对 B 线程调用 interrupt 方法时，如果线程 B 本身就在 waiting，sleeping 状态时，内部的 sleep 方法会抛出 InterrputedException 异常，并重置中断状态（isInterrupted&#x3D;false），所以要在捕获到异常时break。</p>
<p>:question: 上方答案存疑</p>
<ol start="3">
<li><strong>定义标志变量结束线程</strong></li>
</ol>
<p>例如，定义一个变量 running，然后在目标线程中监听其值来决定是否结束线程（类似 Thread 自身维护的 isInterrupt）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">HelloThread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloThread</span>();</span><br><span class="line">        t.start();</span><br><span class="line">        Thread.sleep(<span class="number">1</span>);</span><br><span class="line">        t.running = <span class="literal">false</span>; <span class="comment">// 将标志变量设置为false，结束线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HelloThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">running</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (running) &#123;</span><br><span class="line">            n ++;</span><br><span class="line">            System.out.println(n + <span class="string">&quot; hello!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;end!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>running 在此处代码中，同时作为了 main 和 t 线程之间共享的变量。</p>
<p><strong>变量的更新机制</strong></p>
<p>在Java虚拟机中，变量是保存在主内存的。</p>
<p>每个线程<strong>访问</strong>变量时，会先生成一个副本保存在自己的工作内存中。</p>
<p>如果线程<strong>修改</strong>了变量的值，虚拟机会在不确定的时刻再把修改后的值写回到主内存，存在线程之间变量不一致的问题！</p>
<p>例如，running &#x3D; false，然后 main 修改其为 true，但是没有写到主内存，那么此时线程 A 访问 running 仍会的到 true，而不会立刻结束线程，只有在回写到主内存后才会结束线程。</p>
<p>而 <code>volatile</code> 关键字的目的是告诉虚拟机：</p>
<ul>
<li>每次访问变量时，总是获取主内存的最新值；</li>
<li>每次修改变量后，立刻回写到主内存。</li>
</ul>
<p>这样就可以确保线程之间变量的一致性。</p>
<h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p>有一种线程的目的就是无限循环，无法设定结束条件。</p>
<p>例如，一个定时任务的线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TimerThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(LocalTime.now());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>已知 JVM 需要所有线程都运行结束后，才会退出。</strong> </p>
<p>如果存在这样一个无限执行的线程，且与任务无关，但是又需要在所有任务结束后，关闭 JVM 终止程序，该如何操作呢。</p>
<p>答案：守护线程。</p>
<p><strong>守护线程是指为其他线程服务的线程。</strong></p>
<p><strong>JVM 关闭时无需关心守护线程是否结束，只要其他线程结束就终止程序，同时顺带关闭守护线程</strong>。</p>
<p>创建守护线程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">t.setDaemon(<span class="literal">true</span>);</span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure>

<p>目标线程通过调用 setDeamon(true)；来将本线程设为守护线程。</p>
<p><strong>注意：</strong>守护线程不应该持有任何需要手动关闭的资源，如打开文件。因为该线程何时关闭是不确定的，无法释放资源。</p>
<h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><p><strong>同步：</strong>指两个变量始终保持一定的相对关系，可以是同时，也可以是完成同一个操作一前一后（你先做，再到我做）。</p>
<p>从 volatile 那一节中知道，如果多个线程同时读写共享的变量，会出现数据不一致的问题。</p>
<p>假设有两个加法线程，同时操作同一个变量，都执行加法操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">n = n + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>这一行语句被 JVM 解析成 3 条指令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ILOAD</span><br><span class="line">IADD</span><br><span class="line">ISTORE</span><br></pre></td></tr></table></figure>

<p><img src="/assets/image-20240410233303176.png" alt="image-20240410233303176"></p>
<p>如果线程 1 在LOAD后就被中断，转而执行线程 2，此时 n 还是 100，就会出现两个线程同时写入 101 给 n，而不是正常的 102。</p>
<p><strong>如何让线程 2 每次都基于线程 1 的结果继续运算呢？</strong></p>
<p>只需要保证当一个线程进行 LOAD, ADD, STORE 操作时，其他线程必须等待这一个线程执行完之后再依次执行，确保操作的<strong>原子性</strong>。</p>
<p>这样的操作被称为<strong>原子操作</strong></p>
<p><img src="/assets/image-20240410233957456.png" alt="image-20240410233957456"></p>
<p>这样的操作称为加锁，解锁。</p>
<p>通过加锁和解锁的操作，就能保证3条指令执行期间只有一个线程，不会有其他线程会进入此指令区间。</p>
<p>只有在执行线程解锁，将锁释放后，其他线程才能获得锁并执行这 3 条指令。</p>
<h4 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a><strong>synchronized</strong></h4><p>Java 使用 <code>synchronized</code> 关键字对一个对象进行加锁，保证了代码块在任意时刻最多只有一个线程能执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">add</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AddThread</span>();</span><br><span class="line">        <span class="type">var</span> <span class="variable">dec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DecThread</span>();</span><br><span class="line">        add.start();</span><br><span class="line">        dec.start();</span><br><span class="line">        add.join();</span><br><span class="line">        dec.join();</span><br><span class="line">        System.out.println(Counter.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Counter.lock) &#123;</span><br><span class="line">                Counter.count += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DecThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Counter.lock) &#123;</span><br><span class="line">                Counter.count -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里以 lock 作为锁，每个线程执行加减操作时需要先获取锁，如果这把锁被其他线程占用了，就需要等待锁被释放后，重新获取锁才能执行。</p>
<h4 id="保持线程之间同步的步骤："><a href="#保持线程之间同步的步骤：" class="headerlink" title="保持线程之间同步的步骤："></a><strong>保持线程之间同步的步骤：</strong></h4><ol>
<li>划出需要同步的代码块；</li>
<li>选择同一个对象作为锁；</li>
<li>使用 <code>synchronized(lockObject) &#123; ... &#125;</code> 包裹代码块。</li>
</ol>
<p><strong>注意</strong>：</p>
<ul>
<li>锁的对象必须是同一个，如果不同就会有两把锁，出现两个线程异步执行的情况。</li>
<li>获取锁和释放锁需要消耗一定的时间，所以，<code>synchronized</code>会降低程序的执行效率、性能。</li>
<li>不用担心同步过程中会抛出异常，锁会被正确释放。</li>
</ul>
<h4 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a><strong>原子操作</strong></h4><p>具有原子性的操作被称为原子操作。原子：不可以再被分解的物质。</p>
<p><strong>原子操作是指不能被中断的一个或一系列操作。</strong></p>
<p>对于原子操作不需要使用锁，因为每一个原子操作，都是在“一下”完成的，不被其他线程打断。</p>
<p>JVM规范定义了几种原子操作：</p>
<ul>
<li>基本类型（<code>long</code>和<code>double</code>除外，没有明确规定）赋值，例如：<code>int n = m</code>；</li>
<li>引用类型赋值，例如：<code>List&lt;String&gt; list = anotherList</code>。</li>
</ul>
<p>但如果是多行赋值操作，就需要给操作加锁（对象本身）了。</p>
<p>锁的对象随实际需要改变，这里假设多个线程用到了同一个 Pair 实例对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> x，<span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.x = x;</span><br><span class="line">            <span class="built_in">this</span>.y = y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 同时，读的操作也许加锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] get() &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="type">int</span>[] copy = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">            copy[<span class="number">0</span>] = x;</span><br><span class="line">            copy[<span class="number">1</span>] = y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果“写”操作不加锁，就会出现当 A 线程给 pair 对象的 x 赋值时，被 B 线程打断并重新把 x 赋值为另一个值，这时候 A 线程的逻辑就会不严谨。</p>
<p> 假设当前坐标是<code>(100, 200)</code>。</p>
<p>那么当设置新坐标为<code>(110, 220)</code>时，如果“读”操作不加锁，读到的值可能有：</p>
<ul>
<li>(100, 200)：x，y更新前；</li>
<li>(110, 200)：x更新后，y更新前就调用了 pair 的 get 方法；</li>
<li>(110, 220)：x，y更新后。</li>
</ul>
<p>加锁可以保证读的值不被污染，并且是最新。</p>
<p><strong>有时也可以巧妙的将非原子操作转换为原子操作</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] pair;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> x，<span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="comment">// 局部变量不需要同步</span></span><br><span class="line">        <span class="type">int</span>[] ps = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; x，y &#125;; </span><br><span class="line">        <span class="built_in">this</span>.pair = ps;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] get() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;x, y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 ps 是局部变量，不被其他线程可见，不存在被其他线程中途修改的问题。</p>
<p><strong>每个线程都会有各自的局部变量，互不影响，并且互不可见，并不需要同步。</strong></p>
<p>将多行赋值改为引用赋值，确保操作被“一次”执行，保证原子性。</p>
<p>同理这里的读操作也转为了原子操作，x,y 每次都同步读取，不存在读了线程 A 设置的 x 后，y 又变成了线程 B 设置的。</p>
<p>缺点就是无法保证每次都是最新的状态，可以再添加 <code>volatile</code> 关键字，确保实时性。</p>
<p>看到这里应该就明白 <code>volatile</code> 和 <code>synchronized</code> 之间的区别的吧。</p>
<p>区别：</p>
<ol>
<li>volatile 只用于保证状态更新后能被实时写入主内存，保证状态的实时性。</li>
<li>synchronized 则用于保证一连串操作同时只有一个线程在执行。</li>
</ol>
<p>如果用 volatile 来限制 n &#x3D; n + 1，只能确保每个线程更新后能立马写回主内存，但无法确保每个线程用来更新的值是其他线程执行完之后的值，还是操作了同一个值。</p>
<p>总之，volatile 只注重变量被赋值后“真正”更新的实时性。</p>
<h4 id="不可变对象无需同步"><a href="#不可变对象无需同步" class="headerlink" title="不可变对象无需同步"></a>不可变对象无需同步</h4><p>如果多线程读写的是一个不可变对象（如String，List），那么无需同步。</p>
<p>因为不会修改这个对象的状态，而是修改对象本身。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Data &#123;</span><br><span class="line">    List&lt;String&gt; names;</span><br><span class="line">    void set(String[] names) &#123;</span><br><span class="line">        this.names = List.of(names);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;String&gt; get() &#123;</span><br><span class="line">        return this.names;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到<code>set()</code>方法内部创建了一个不可变<code>List</code>，这个<code>List</code>包含的对象也是不可变对象<code>String</code>，因此，整个<code>List&lt;String&gt;</code>对象都是不可变的，因此读写均无需同步。</p>
<p>对于读写的操作的同步问题</p>
<p>其实只需要多加思考如何保证写的操作是“阶段性”的，那么读就很容易保持阶段性（同步）。</p>
<h4 id="总结多线程"><a href="#总结多线程" class="headerlink" title="总结多线程"></a><strong>总结多线程</strong></h4><p>深入理解多线程还需理解变量在栈上的存储方式，基本类型和引用类型的存储方式也不同。</p>
<p>什么时候需要考虑多线程问题？</p>
<ol>
<li>并发高的场景</li>
<li>修改线程共享变量（对象变量等）的时候</li>
</ol>
<p>为什么需要多线程？</p>
<p>每个任务分别做一点，和任务交替完成，总和不是一样的吗？</p>
<p>是的，但是前提是这写些个任务之间是可以“相加”的关系，前后结果没有太大联系。</p>
<p>但如果前一个任务和后一个任务中，<strong>有一部分成果是一致的呢？基于某一个相同的结果呢？</strong></p>
<p>&#x3D;&#x3D;那多线程带来的效率就是幂级的提升&#x3D;&#x3D;</p>
<h3 id="synchronized-方法"><a href="#synchronized-方法" class="headerlink" title="synchronized 方法"></a>synchronized 方法</h3><p>在业务逻辑中，如果自由的自定义 <code>synchronized</code> 代码块，会显得代码逻辑混乱。</p>
<p>因此，常常将同步的行为整体封装为一个类，如计数器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">            count += n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dec</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">            count -= n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该计数器的加减操作以自身 this 实例为锁，支持同时创建多个实例，每个实例内部维护各自的 COUNT 不因为线程而错乱。</p>
<p>如果一个类被设计为允许 多线程 正确访问，我们就说这个类是<strong>线程安全</strong>的。</p>
<p>还有一些不变类，例如<code>String</code>，<code>Integer</code>，<code>LocalDate</code>，它们的所有成员变量都是<code>final</code>，多线程同时访问时只能读不能写，这些不变类也是线程安全的。</p>
<p>最后，类似<code>Math</code>这些只提供静态方法，没有成员变量的类，也是线程安全的。</p>
<p>事实上大部分情况下，大部分类，例如<code>ArrayList</code>，都是非线程安全的类，我们不能在多线程中安全的使用它们。</p>
<p><strong>即使是上升为 List 引用，也是线程非安全的，因为内部的作用域还是 ArrayList 本身</strong></p>
<blockquote>
<p>只能访问，不能插入和修改元素，因为 length 和 元素内存值 会不一致。</p>
</blockquote>
<p>&#x3D;&#x3D;没有特殊说明时，一个类默认是非线程安全的。&#x3D;&#x3D;</p>
<blockquote>
<p>因为内置线程安全会影响性能，应交由开发者自由控制。</p>
</blockquote>
<p><strong>synchronized 方法修饰符</strong></p>
<p>当锁的对象是 this 实例时，以下两种写法等价。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123; <span class="comment">// 锁住this</span></span><br><span class="line">        count += n;</span><br><span class="line">    &#125; <span class="comment">// 解锁</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> n)</span> &#123; <span class="comment">// 锁住this</span></span><br><span class="line">    count += n;</span><br><span class="line">&#125; <span class="comment">// 解锁</span></span><br></pre></td></tr></table></figure>

<p><strong>static 方法加锁</strong></p>
<p>由于 static 方法没有 this 实例，因此其锁住的是一个类的 Class 实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(Counter.class) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>Java的线程锁是可重入的锁。</p>
<p><strong>可重入锁</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            dec(-n);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            count += n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">dec</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        count += n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码先执行 add，然后在 add 内部再执行 dec，可以看到两个方法都是以 this 为锁对象的。</p>
<p><strong>像这种同一把锁可以允许同一个线程多次获取的情况，就是可重入锁。</strong></p>
<p><strong>如果不同线程获取不同锁呢？</strong></p>
<p>会造成 <strong>死锁</strong> 发生。</p>
<p>死锁通俗来说，就是这把锁无法被再次正常使用了，获取不到也释放不了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> m)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(lockA) &#123; <span class="comment">// 获得lockA的锁</span></span><br><span class="line">        <span class="built_in">this</span>.value += m;</span><br><span class="line">        <span class="keyword">synchronized</span>(lockB) &#123; <span class="comment">// 获得lockB的锁</span></span><br><span class="line">            <span class="built_in">this</span>.another += m;</span><br><span class="line">        &#125; <span class="comment">// 释放lockB的锁</span></span><br><span class="line">    &#125; <span class="comment">// 释放lockA的锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dec</span><span class="params">(<span class="type">int</span> m)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(lockB) &#123; <span class="comment">// 获得lockB的锁</span></span><br><span class="line">        <span class="built_in">this</span>.another -= m;</span><br><span class="line">        <span class="keyword">synchronized</span>(lockA) &#123; <span class="comment">// 获得lockA的锁</span></span><br><span class="line">            <span class="built_in">this</span>.value -= m;</span><br><span class="line">        &#125; <span class="comment">// 释放lockA的锁</span></span><br><span class="line">    &#125; <span class="comment">// 释放lockB的锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设同时有两个线程，分别执行 add 和 dec 方法，首先都获取到了 lockA 和 lockB，就会出现这样一个情况：</p>
<ul>
<li>线程1：准备获得<code>lockB</code>，失败，等待中；</li>
<li>线程2：准备获得<code>lockA</code>，失败，等待中。</li>
</ul>
<p>两个线程都因为想要获取对方的锁，而无限等待，造成死锁。</p>
<p><strong>死锁发生后，没有任何机制能解除死锁，只能强制结束JVM进程。</strong><br>&#x3D;&#x3D;如何避免死锁&#x3D;&#x3D;</p>
<p>答案：只要保证获取锁的顺序一致。</p>
<p>所有线程都遵循这个顺序同步，只要存在线程获取到锁开始了，其他线程就必须等待，不允许步骤交叉进行。</p>
<p>将 dec 方法改为如下代码，即可避免死锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dec</span><span class="params">(<span class="type">int</span> m)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(lockA) &#123; <span class="comment">// 获得lockA的锁</span></span><br><span class="line">        <span class="built_in">this</span>.value -= m;</span><br><span class="line">        <span class="keyword">synchronized</span>(lockB) &#123; <span class="comment">// 获得lockB的锁</span></span><br><span class="line">            <span class="built_in">this</span>.another -= m;</span><br><span class="line">        &#125; <span class="comment">// 释放lockB的锁</span></span><br><span class="line">    &#125; <span class="comment">// 释放lockA的锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，大部分情况下的业务逻辑都比这个复杂，可能这个服务和另一个服务交叉获取了锁，无法被明显的发现而造成死锁。</p>
<p>这时候可以借助第三方工具，如 redis，给“锁”设置一个过期时间，超出过期时间后就自动释放。</p>
<h3 id="wait和notify"><a href="#wait和notify" class="headerlink" title="wait和notify"></a>wait和notify</h3><p>synchronized 解决了多线程竞争问题，但是没有解决协调问题。</p>
<p>竞争：多个线程争夺执行权</p>
<p>协调：多个线程之间配合交换执行权</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TaskQueue</span> &#123;</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">addTask</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.queue.add(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title function_">getTask</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码看上去没有问题：<code>getTask()</code>内部先判断队列是否为空，如果为空，就循环等待，直到另一个线程往队列中放入了一个任务，<code>while()</code>循环退出，就可以返回队列的元素了。</p>
<p>但实际上<code>while()</code>循环永远不会退出。因为线程在执行<code>while()</code>循环时，已经在<code>getTask()</code>入口获取了<code>this</code>锁，其他线程根本无法调用<code>addTask()</code>，因为<code>addTask()</code>执行条件也是获取<code>this</code>锁。</p>
<p>在队列为空的时候 getTask 获取了锁并进入了死循环，导致永远无法 addTask，造成了逻辑死锁。</p>
<p><strong>正确的逻辑</strong>：一个线程可以调用<code>getTask()</code>从队列中获取任务。如果队列为空，则该线程应该等待，直到其他线程往队列中添加了任务之后被唤醒。</p>
<p><strong>借助 wait 和 notify 改造代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TaskQueue</span> &#123;</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">addTask</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.queue.add(s);</span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title function_">getTask</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">            <span class="built_in">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当队列为空时，该线程调用 wait 方法等待。</p>
<p><strong>wait 期间会<em>释放</em>线程获得的锁，<code>wait()</code>方法返回后，线程又会重新试图获得锁。</strong></p>
<p><code>wait()</code>方法必须在当前获取的锁对象上调用，这里获取的是<code>this</code>锁，因此调用<code>this.wait()</code>。</p>
<p><strong>notifyAll 和 notify</strong></p>
<p>内部调用了<code>this.notifyAll()</code>而不是<code>this.notify()</code>，使用<code>notifyAll()</code>将唤醒所有当前正在<code>this</code>锁等待的线程，而<code>notify()</code>只会唤醒其中一个（具体哪个依赖操作系统，有一定的随机性）。</p>
<p>通常来说，<code>notifyAll()</code>更安全。有些时候，如果我们的代码逻辑考虑不周，用<code>notify()</code>会导致只唤醒了一个线程，而其他线程可能永远等待下去醒不过来了。</p>
<p><strong>注意：</strong></p>
<p>在<code>while()</code>循环中调用<code>wait()</code>，而不是<code>if</code>语句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title function_">getTask</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (queue.isEmpty()) &#123;</span><br><span class="line">        <span class="built_in">this</span>.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述的写法是错误的，因为可能会有多个线程同时 getTask，而没有获取到锁的线程，会再次进入 wait，如果这里是 if 的话，当线程被唤醒后不会继续判断，而是继续往下执行。</p>
<h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a><strong>ReentrantLock</strong></h3><p>Java 5开始，引入了 <code>java.util.concurrent</code> 并发工具包。</p>
<p>它提供了大量更高级的并发功能，能大大简化多线程程序的编写。</p>
<p>虽然 Java 可以直接用<code>synchronized</code>关键字加锁，但这种锁有很大的缺点。</p>
<ol>
<li>使用起来不方便，需要嵌套代码，非常“重量级”</li>
<li>获取锁失败时必须一直等待，没有额外的尝试，等待超时机制。</li>
</ol>
<p><code>java.util.concurrent.locks</code> 包提供的 <code>ReentrantLock</code> 可以用于替代 <code>synchronized</code> 加锁，也是一把可重入锁。</p>
<p>分别给出 synchronized 和 ReentrantLock 加锁代码：</p>
<p><strong>synchronized</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">            count += n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ReentrantLock</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            count += n;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为确保锁住是 this 实例，将 ReentrantLock 声明为对象属性。</p>
<p><strong>对比</strong></p>
<p>因为<code>synchronized</code>是Java语言层面提供的语法，所以我们不需要考虑异常。</p>
<p>而<code>ReentrantLock</code>是Java代码实现的锁，我们就必须先手动获取锁，然后在确保无论是否发生异常，都要在<code>finally</code>中正确释放锁。</p>
<p><strong>尝试机制</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 尝试获取锁，最多等待 1 秒</span></span><br><span class="line"><span class="keyword">if</span> (lock.tryLock(<span class="number">1</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 tryLock 尝试获取锁并设置尝试的时间，返回一个 boolean 值。</p>
<p>如果超时返回 false，可以进行一些额外的操作，而不是一直等待下去。</p>
<h3 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h3><p>synchronized 具有 wait 和 notify 功能，ReentrantLock 该如何呢？</p>
<p>同样提供了 Condition 类，可以使用<code>Condition</code>对象来实现<code>wait</code>和<code>notify</code>的功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TaskQueue</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addTask</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            queue.add(s);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getTask</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> queue.remove();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用方式和 wait 和 notify 类似。</p>
<p>注意：引用的<code>Condition</code>对象必须从<code>Lock</code>实例的<code>newCondition()</code>返回，这样才能正确协调获取这同一把锁的线程。</p>
<p><code>Condition</code>提供的<code>await()</code>、<code>signal()</code>、<code>signalAll()</code>原理和<code>synchronized</code>锁对象的<code>wait()</code>、<code>notify()</code>、<code>notifyAll()</code>是一致的，并且其行为也是一样的：</p>
<ul>
<li><code>await()</code>会释放当前锁，进入等待状态；</li>
<li><code>signal()</code>会唤醒某个等待线程；</li>
<li><code>signalAll()</code>会唤醒所有等待线程；</li>
<li>唤醒线程从<code>await()</code>返回后需要重新获得锁。</li>
</ul>
<p>此外，和<code>tryLock()</code>类似，<code>await()</code>可以在等待指定时间后，如果还没有被其他线程通过<code>signal()</code>或<code>signalAll()</code>唤醒，可以自己醒来：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (condition.await(1, TimeUnit.SECOND)) &#123;</span><br><span class="line">    // 被其他线程唤醒</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // 指定时间内没有被其他线程唤醒</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a>ReadWriteLock</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] counts = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inc</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            counts[index] += <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] get() &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Arrays.copyOf(counts, counts.length);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ReentrantLock 保证了某一段操作同时只有一个线程在执行，但是对于不影响内存的操作：“读”，难道也只能同时允许一个线程进入吗？？</p>
<p>但是如果不加锁，又会出现数据不一致的情况。</p>
<p>实际上我们想要的是：允许多个线程同时读，但只要有一个线程在写，其他线程就必须等待：</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">读</th>
<th align="left">写</th>
</tr>
</thead>
<tbody><tr>
<td align="left">读</td>
<td align="left">允许</td>
<td align="left">不允许</td>
</tr>
<tr>
<td align="left">写</td>
<td align="left">不允许</td>
<td align="left">不允许</td>
</tr>
</tbody></table>
<p>使用<code>ReadWriteLock</code>可以解决这个问题，它保证：</p>
<ul>
<li>只允许一个线程写入（其他线程既不能写入也不能读取）；</li>
<li>没有写入时，多个线程允许同时读（提高性能）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReadWriteLock</span> <span class="variable">rwlock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="comment">// 获取读锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">rlock</span> <span class="operator">=</span> rwlock.readLock();</span><br><span class="line">    <span class="comment">// 获取写锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">wlock</span> <span class="operator">=</span> rwlock.writeLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] counts = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inc</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        wlock.lock(); <span class="comment">// 加写锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            counts[index] += <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            wlock.unlock(); <span class="comment">// 释放写锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] get() &#123;</span><br><span class="line">        rlock.lock(); <span class="comment">// 加读锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Arrays.copyOf(counts, counts.length);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rlock.unlock(); <span class="comment">// 释放读锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>内部应该是维护了一个状态量，同时监控读写锁的状态，满足 无写-无读 的情况才可以写</p>
</blockquote>
<p>使用<code>ReadWriteLock</code>时，适用条件是同一个数据，有大量线程读取，但仅有少数线程修改。</p>
<p>例如，一个论坛的帖子，回复可以看做写入操作，它是不频繁的，但是，浏览可以看做读取操作，是非常频繁的，这种情况就可以使用<code>ReadWriteLock</code>。</p>
<h3 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h3><p><code>ReadWriteLock</code> 仍然存在效率问题。</p>
<p>如果有线程正在读，写线程需要等待读线程释放锁后才能获取写锁，即读的过程中不允许写，这是一种悲观的读锁。</p>
<p>悲观：读的过程中一定会有其他线程执行写操作，为确保一致性应拒绝。</p>
<p>而 StampedLock 是一种乐观锁，允许在读的同时进行写；但是这样会造成数据不一致，需要额外编写代码维护一致性。</p>
<p>乐观：读的过程不会被写入，允许写操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">StampedLock</span> <span class="variable">stampedLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StampedLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">(<span class="type">double</span> deltaX, <span class="type">double</span> deltaY)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> stampedLock.writeLock(); <span class="comment">// 获取写锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            x += deltaX;</span><br><span class="line">            y += deltaY;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            stampedLock.unlockWrite(stamp); <span class="comment">// 释放写锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">distanceFromOrigin</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> stampedLock.tryOptimisticRead(); <span class="comment">// 获得一个乐观读锁</span></span><br><span class="line">        <span class="comment">// 注意下面两行代码不是原子操作</span></span><br><span class="line">        <span class="comment">// 假设x,y = (100,200)</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">currentX</span> <span class="operator">=</span> x;</span><br><span class="line">        <span class="comment">// 此处已读取到x=100，但x,y可能被写线程修改为(300,400)</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">currentY</span> <span class="operator">=</span> y;</span><br><span class="line">        <span class="comment">// 此处已读取到y，如果没有写入，读取是正确的(100,200)</span></span><br><span class="line">        <span class="comment">// 如果有写入，读取是错误的(100,400)</span></span><br><span class="line">        <span class="keyword">if</span> (!stampedLock.validate(stamp)) &#123; <span class="comment">// 检查乐观读锁后是否有其他写锁发生</span></span><br><span class="line">            stamp = stampedLock.readLock(); <span class="comment">// 获取一个悲观读锁</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                currentX = x;</span><br><span class="line">                currentY = y;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                stampedLock.unlockRead(stamp); <span class="comment">// 释放悲观读锁</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.sqrt(currentX * currentX + currentY * currentY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给乐观读的操作加一个 validate 确保数据一致性，如果有其他线程写入，则获取悲观读锁重新读，保证一致性。</p>
<h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><p>Semaphore：信号量。</p>
<p>前面学习各种锁的实现。</p>
<p>本质上锁的目的是保护一种受限资源，保证同一时刻只有一个线程能访问（ReentrantLock），或者只有一个线程能写入（ReadWriteLock）。</p>
<p>还有一种受限资源，目的是控制一种资源访问量，可能是不存在并发问题的只读操作。</p>
<p>例如，一个服务器同时只能允许 10 个人进入。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccessLimitControl</span> &#123;</span><br><span class="line">    <span class="comment">// 任意时刻仅允许最多3个线程获取许可:</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">access</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 如果超过了许可数量,其他线程将在此等待:</span></span><br><span class="line">        semaphore.acquire();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">            <span class="keyword">return</span> UUID.randomUUID().toString();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放资源</span></span><br><span class="line">            semaphore.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用<code>acquire()</code>可能会进入等待，直到满足条件为止。也可以使用<code>tryAcquire()</code>指定等待时间：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (semaphore.tryAcquire(3, TimeUnit.SECONDS)) &#123;</span><br><span class="line">    // 指定等待时间3秒内获取到许可:</span><br><span class="line">    try &#123;</span><br><span class="line">        // TODO:</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        semaphore.release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要对某一受限资源进行限流访问，可以使用<code>Semaphore</code>，保证同一时间最多N个线程访问受限资源。</p>
<blockquote>
<p>线程容量和QBS区别</p>
</blockquote>
<h3 id="Concurrent集合"><a href="#Concurrent集合" class="headerlink" title="Concurrent集合"></a>Concurrent集合</h3><p>在前面通过 ReentrantLock 和 Condition 实现了一个阻塞的任务队列 BlockingQueue。</p>
<p><code>BlockingQueue</code>的意思就是说，当一个线程调用这个<code>getTask()</code>方法时，该方法内部可能会让线程变成等待状态，直到队列条件满足不为空，线程被唤醒后，<code>getTask()</code>方法才会返回。</p>
<p>除了<code>BlockingQueue</code>外，针对<code>List</code>、<code>Map</code>、<code>Set</code>、<code>Deque</code>等，<code>java.util.concurrent</code>包也提供了对应的并发集合类。我们归纳一下：</p>
<table>
<thead>
<tr>
<th align="left">interface</th>
<th align="left">non-thread-safe</th>
<th align="left">thread-safe</th>
</tr>
</thead>
<tbody><tr>
<td align="left">List</td>
<td align="left">ArrayList</td>
<td align="left">CopyOnWriteArrayList</td>
</tr>
<tr>
<td align="left">Map</td>
<td align="left">HashMap</td>
<td align="left">ConcurrentHashMap</td>
</tr>
<tr>
<td align="left">Set</td>
<td align="left">HashSet &#x2F; TreeSet</td>
<td align="left">CopyOnWriteArraySet</td>
</tr>
<tr>
<td align="left">Queue</td>
<td align="left">ArrayDeque &#x2F; LinkedList</td>
<td align="left">ArrayBlockingQueue &#x2F; LinkedBlockingQueue</td>
</tr>
<tr>
<td align="left">Deque 双向队列</td>
<td align="left">ArrayDeque &#x2F; LinkedList</td>
<td align="left">LinkedBlockingDeque</td>
</tr>
</tbody></table>
<p>使用这些并发集合与使用非线程安全的集合类完全相同。我们以<code>ConcurrentHashMap</code>为例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = new ConcurrentHashMap&lt;&gt;();</span><br><span class="line">// 在不同的线程读写:</span><br><span class="line">map.put(&quot;A&quot;, &quot;1&quot;);</span><br><span class="line">map.put(&quot;B&quot;, &quot;2&quot;);</span><br><span class="line">map.get(&quot;A&quot;, &quot;1&quot;);</span><br></pre></td></tr></table></figure>

<p>操作和原生集合使用一致，所有的同步和加锁的逻辑都在集合内部实现了</p>
<p><code>java.util.Collections</code>工具类还提供了一个<strong>旧的线程安全集合转换器</strong>，可以这么用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Map unsafeMap = new HashMap();</span><br><span class="line">Map threadSafeMap = Collections.synchronizedMap(unsafeMap);</span><br></pre></td></tr></table></figure>

<p>但是它实际上是封装了了非线程安全的<code>Map</code>，对所有读写方法都用<code>synchronized</code>加锁。</p>
<p>这样获得的线程安全集合的性能比<code>java.util.concurrent</code>集合要低很多，所以不推荐使用。</p>
<h3 id="Atomic-类"><a href="#Atomic-类" class="headerlink" title="Atomic 类"></a>Atomic 类</h3><p>ava的<code>java.util.concurrent</code>包除了提供底层锁、并发集合外，还提供了一组原子操作的封装类，它们位于<code>java.util.concurrent.atomic</code>包。</p>
<p>我们以<code>AtomicInteger</code>为例，它提供的主要操作有：</p>
<ul>
<li>增加值并返回新值：<code>int addAndGet(int delta)</code></li>
<li>加1后返回新值：<code>int incrementAndGet()</code></li>
<li>获取当前值：<code>int get()</code></li>
<li>用CAS方式设置：<code>int compareAndSet(int expect, int update)</code></li>
</ul>
<p>Atomic类是通过无锁（lock-free）的方式实现的线程安全（thread-safe）访问。它的主要原理是利用了CAS：Compare and Set。</p>
<p>如果我们自己通过CAS编写<code>incrementAndGet()</code>，它大概长这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以把这里的 var 看成对象属性，参数（局部变量）在多线程中是不共享的。</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">incrementAndGet</span><span class="params">(AtomicInteger <span class="keyword">var</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> prev, next;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prev = <span class="keyword">var</span>.get();</span><br><span class="line">        next = prev + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> ( ! <span class="keyword">var</span>.compareAndSet(prev, next));</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CAS：将比较和写入封装成原子性操作。</p>
<p>用一个以 CAS 为条件的 do~while 循环包裹 inc 和 get 操作，只要在自增后原值不变则返回值，如果期间改变了就重复操作。</p>
<p>利用<code>AtomicLong</code>可以编写一个多线程安全的全局唯一ID生成器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class IdGenerator &#123;</span><br><span class="line">    AtomicLong var = new AtomicLong(0);</span><br><span class="line"></span><br><span class="line">    public long getNextId() &#123;</span><br><span class="line">        return var.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在高度竞争的情况下，还可以使用Java 8提供的<code>LongAdder</code>和<code>LongAccumulator</code>。</p>
<p>应用：</p>
<ul>
<li>原子操作实现了无锁的线程安全；</li>
<li>适用于计数器，累加器等。</li>
</ul>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>为什么需要线程池？</p>
<p>因为创建线程需要操作系统资源（线程资源，栈空间等），频繁创建和销毁大量线程需要消耗大量时间。</p>
<p>而大多数情况下因为每个线程执行的任务不一定会同时完成，而是有一些线程提前完成。</p>
<p>那如果需要继续完成类似的任务，要继续创建新的线程来执行吗？</p>
<p>不是的，为了避免频繁创建线程浪费资源，选择创建一个线程池，当线程执行结束后，会被收回线程池，以供下次调用，就不用创建新线程了。</p>
<p><strong>创建线程池</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个固定大小的线程池:</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            es.submit(<span class="keyword">new</span> <span class="title class_">Task</span>(<span class="string">&quot;&quot;</span> + i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭线程池:</span></span><br><span class="line">        es.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>提交任务后，会异步的执行完这一些任务。</p>
<p>线程池在程序结束的时候要关闭。有三种关闭的方式：</p>
<ol>
<li>使用<code>shutdown()</code>方法关闭线程池的时候，它会等待正在执行的任务先完成，然后再关闭。</li>
<li><code>shutdownNow()</code>会立刻停止正在执行的任务，</li>
<li><code>awaitTermination()</code>则会等待指定的时间让线程池关闭。</li>
</ol>
<p>因为<code>ExecutorService</code>只是接口，Java标准库提供的几个常用实现类有：</p>
<ul>
<li>FixedThreadPool：线程数固定的线程池；</li>
<li>CachedThreadPool：线程数根据任务动态调整的线程池；</li>
<li>SingleThreadExecutor：仅单线程执行的线程池。</li>
</ul>
<p>创建这些线程池的方法都被封装到<code>Executors</code>这个工厂类中，可以选择创建需要的线程池。</p>
<p><strong>ScheduledThreadPool</strong></p>
<p>还有一种任务，需要定期反复执行，例如，每秒刷新证券价格。</p>
<p>这种任务本身固定，需要反复执行的，可以使用<code>ScheduledThreadPool</code>。</p>
<p>创建一个<code>ScheduledThreadPool</code>仍然是通过<code>Executors</code>类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ScheduledExecutorService ses = Executors.newScheduledThreadPool(4);</span><br></pre></td></tr></table></figure>

<p>我们可以提交一次性任务，它会在指定延迟后只执行一次：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 1秒后执行一次性任务:</span><br><span class="line">ses.schedule(new Task(&quot;one-time&quot;), 1, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<p>如果任务以固定的每3秒执行，我们可以这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 2秒后开始执行定时任务，每3秒执行:</span><br><span class="line">ses.scheduleAtFixedRate(new Task(&quot;fixed-rate&quot;), 2, 3, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<p>如果任务以固定的3秒为间隔执行，我们可以这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 2秒后开始执行定时任务，以3秒为间隔执行:</span><br><span class="line">ses.scheduleWithFixedDelay(new Task(&quot;fixed-delay&quot;), 2, 3, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<p>注意FixedRate和FixedDelay的区别。FixedRate是指任务总是<strong>以固定时间间隔触发</strong>，不管任务执行多长时间：</p>
<p><img src="/assets/image-20240415131920186.png" alt="image-20240415131920186"></p>
<p>而FixedDelay是指，上一次任务<strong>执行完毕</strong>后，等待固定的时间间隔，再执行下一次任务：</p>
<p><img src="/assets/image-20240415131957807.png" alt="image-20240415131957807"></p>
<p><strong>注意：</strong></p>
<ol>
<li><p>在FixedRate模式下，假设每秒触发，如果某次任务执行时间超过1秒，后续任务会不会并发执行？</p>
<p>也就是原定于每 1 秒执行一次的任务，但是上次任务还没有执行完，还会根据每秒一次执行吗？</p>
<p>答案：不会，如果任务执行时间超出了触发间隔，会在这一次任务执行完毕后，再执行下一次任务，如果下一次任务没有超出时间间隔，则保持间隔时间触发，如果又超出了，继续等待至完毕后再执行下一次，变成了顺序执行固定任务。</p>
</li>
<li><p>如果任务抛出了异常，后续任务是否继续执行？</p>
<p>答案：如果一个定时任务中任何一次执行出现了问题，这么这个 schedule 就会停止。</p>
</li>
</ol>
<p><strong>Timer</strong></p>
<p>Java标准库还提供了一个<code>java.util.Timer</code>类，这个类也可以定期执行任务，但是，一个<code>Timer</code>会对应一个<code>Thread</code>，所以，一个<code>Timer</code>只能定期执行一个任务，多个定时任务必须启动多个<code>Timer</code>，而一个<code>ScheduledThreadPool</code>就可以调度多个定时任务，所以，我们完全可以用<code>ScheduledThreadPool</code>取代旧的<code>Timer</code>。</p>
<h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><p><code>Runnable</code>接口有个问题，它的方法没有返回值。</p>
<p>如果任务需要一个返回结果，那么只能保存到变量，还要额外封装方法读取，要考虑诸多因素非常不便。</p>
<p>所以，Java标准库还提供了一个<code>Callable</code>接口，和<code>Runnable</code>接口比，它多了一个返回值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> longTimeCalculation(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并且<code>Callable</code>接口是一个泛型接口，可以返回指定类型的结果。</p>
<p>在线程池中的 submit 中，如果提供一个 Callable 接口，就会返回一个<code>Future</code>类型，一个<code>Future</code>类型的实例代表一个未来能获取结果的对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">4</span>); </span><br><span class="line"><span class="comment">// 定义任务:</span></span><br><span class="line">Callable&lt;String&gt; task = <span class="keyword">new</span> <span class="title class_">Task</span>();</span><br><span class="line"><span class="comment">// 提交任务并获得Future:</span></span><br><span class="line">Future&lt;String&gt; future = executor.submit(task);</span><br><span class="line"><span class="comment">// 从Future获取异步执行返回的结果:</span></span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> future.get(); <span class="comment">// 可能阻塞</span></span><br></pre></td></tr></table></figure>

<p>在调用<code>get()</code>时，如果异步任务已经完成，我们就直接获得结果。</p>
<p>如果异步任务还没有完成，那么<code>get()</code>会阻塞，直到任务完成后才返回结果。</p>
<p>一个<code>Future&lt;V&gt;</code>接口表示一个未来可能会返回的结果，它定义的方法有：</p>
<ul>
<li><code>get()</code>：获取结果（可能会等待）</li>
<li><code>get(long timeout, TimeUnit unit)</code>：获取结果，但只等待指定的时间；</li>
<li><code>cancel(boolean mayInterruptIfRunning)</code>：取消当前任务；</li>
<li><code>isDone()</code>：判断任务是否已完成。</li>
</ul>
<h3 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h3><p>使用<code>Future</code>获得异步执行结果时，由于 get 结果并进行处理会进行阻塞或者封装一些其他的方法，非常麻烦。</p>
<p>从Java 8开始引入了<code>CompletableFuture</code>，它针对<code>Future</code>做了改进，可以传入回调对象，当异步任务完成或者发生异常时，自动调用回调对象的回调方法。</p>
<p><strong>使用方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建异步执行任务:</span></span><br><span class="line">        CompletableFuture&lt;Double&gt; cf = CompletableFuture.supplyAsync(Main::fetchPrice);</span><br><span class="line">        <span class="comment">// 如果执行成功:</span></span><br><span class="line">        cf.thenAccept((result) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;price: &quot;</span> + result);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 如果执行异常:</span></span><br><span class="line">        cf.exceptionally((e) -&gt; &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭:</span></span><br><span class="line">        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行成功：thenAccept；执行异常：exceptionally。</p>
<p>supplyAsync接收的是一个Supplier接口函数，thenAccept, exceptionally接收一个Consumer接口函数</p>
<p>相比于 Future 优点：</p>
<ul>
<li>异步任务<strong>结束时</strong>，会自动回调某个对象的方法；</li>
<li>异步任务<strong>出错时</strong>，会自动回调某个对象的方法；</li>
<li>主线程设置好回调后，不再关心异步任务的执行。</li>
</ul>
<p><strong>CompletableFuture 还可以制作串行、并行及两者结合的异步操作</strong></p>
<p><strong>串行</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 第一个任务:</span></span><br><span class="line">        CompletableFuture&lt;String&gt; cfQuery = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> queryCode(<span class="string">&quot;中国石油&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// cfQuery成功后继续执行下一个任务:</span></span><br><span class="line">        CompletableFuture&lt;Double&gt; cfFetch = cfQuery.thenApplyAsync((code) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> fetchPrice(code);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// cfFetch成功后打印结果:</span></span><br><span class="line">        cfFetch.thenAccept((result) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;price: &quot;</span> + result);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭:</span></span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 thenApplyAsync 接着上一步异步继续执行，并且返回一个新的 CompletableFuture 对象。</p>
<p><strong>并行串行结合</strong></p>
<p>考虑如下这样的一个场景：</p>
<p>同时从新浪和网易查询证券代码，只要任意一个返回结果，就进行下一步查询价格，查询价格也同时从新浪和网易查询，只要任意一个返回结果，就完成操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 两个CompletableFuture执行异步查询:</span></span><br><span class="line">        CompletableFuture&lt;String&gt; cfQueryFromSina = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> queryCode(<span class="string">&quot;中国石油&quot;</span>, <span class="string">&quot;https://finance.sina.com.cn/code/&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        CompletableFuture&lt;String&gt; cfQueryFrom163 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> queryCode(<span class="string">&quot;中国石油&quot;</span>, <span class="string">&quot;https://money.163.com/code/&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用anyOf合并为一个新的CompletableFuture:</span></span><br><span class="line">        CompletableFuture&lt;Object&gt; cfQuery = CompletableFuture.anyOf(cfQueryFromSina, cfQueryFrom163);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 两个CompletableFuture执行异步查询:</span></span><br><span class="line">        CompletableFuture&lt;Double&gt; cfFetchFromSina = cfQuery.thenApplyAsync((code) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> fetchPrice((String) code, <span class="string">&quot;https://finance.sina.com.cn/price/&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        CompletableFuture&lt;Double&gt; cfFetchFrom163 = cfQuery.thenApplyAsync((code) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> fetchPrice((String) code, <span class="string">&quot;https://money.163.com/price/&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用anyOf合并为一个新的CompletableFuture:</span></span><br><span class="line">        CompletableFuture&lt;Object&gt; cfFetch = CompletableFuture.anyOf(cfFetchFromSina, cfFetchFrom163);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最终结果:</span></span><br><span class="line">        cfFetch.thenAccept((result) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;price: &quot;</span> + result);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭:</span></span><br><span class="line">        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述的执行流程，可以用下图解释：</p>
<p><img src="/assets/image-20240415134338932.png" alt="image-20240415134338932"></p>
<p>除了<code>anyOf()</code>可以实现“任意个<code>CompletableFuture</code>只要一个成功”，<code>allOf()</code>可以实现“所有<code>CompletableFuture</code>都必须成功”，这些组合操作可以实现非常复杂的异步流程控制。</p>
<p>最后我们注意<code>CompletableFuture</code>的命名规则：</p>
<ul>
<li><code>xxx()</code>：表示该方法将继续在已有的线程中执行；</li>
<li><code>xxxAsync()</code>：表示将异步在线程池中执行。</li>
</ul>
<p><strong>注意</strong>：不管是 thenApplyAsync 还是 anyOf, allOf 等操作对 CompletableFuture 进行整合，都会返回一个新的 CompletableFuture 对象，最终结果应基于最后一个组合对象操作。</p>
<blockquote>
<p>还有个 runAsync 方法，可以不需要返回值也能使用。</p>
</blockquote>
<h3 id="ForkJoin"><a href="#ForkJoin" class="headerlink" title="ForkJoin"></a>ForkJoin</h3><p>Java 7开始引入了一种新的Fork&#x2F;Join线程池，它可以执行一种特殊的任务：把一个大任务拆成多个小任务并行执行。</p>
<p>以大数据进行并行求和为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建2000个随机数组成的数组:</span></span><br><span class="line">        <span class="type">long</span>[] array = <span class="keyword">new</span> <span class="title class_">long</span>[<span class="number">2000</span>];</span><br><span class="line">        <span class="type">long</span> <span class="variable">expectedSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            array[i] = random();</span><br><span class="line">            expectedSum += array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Expected sum: &quot;</span> + expectedSum);</span><br><span class="line">        <span class="comment">// fork/join:</span></span><br><span class="line">        ForkJoinTask&lt;Long&gt; task = <span class="keyword">new</span> <span class="title class_">SumTask</span>(array, <span class="number">0</span>, array.length);</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> ForkJoinPool.commonPool().invoke(task);</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;Fork/join sum: &quot;</span> + result + <span class="string">&quot; in &quot;</span> + (endTime - startTime) + <span class="string">&quot; ms.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">random</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> random.nextInt(<span class="number">10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SumTask</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Long&gt; &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THRESHOLD</span> <span class="operator">=</span> <span class="number">500</span>;</span><br><span class="line">    <span class="type">long</span>[] array;</span><br><span class="line">    <span class="type">int</span> start;</span><br><span class="line">    <span class="type">int</span> end;</span><br><span class="line"></span><br><span class="line">    SumTask(<span class="type">long</span>[] array, <span class="type">int</span> start, <span class="type">int</span> end) &#123;</span><br><span class="line">        <span class="built_in">this</span>.array = array;</span><br><span class="line">        <span class="built_in">this</span>.start = start;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Long <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (end - start &lt;= THRESHOLD) &#123;</span><br><span class="line">            <span class="comment">// 如果任务足够小,直接计算:</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; end; i++) &#123;</span><br><span class="line">                sum += <span class="built_in">this</span>.array[i];</span><br><span class="line">                <span class="comment">// 故意放慢计算速度:</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 任务太大,一分为二:</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> (end + start) / <span class="number">2</span>;</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;split %d~%d ==&gt; %d~%d, %d~%d&quot;</span>, start, end, start, middle, middle, end));</span><br><span class="line">        <span class="type">SumTask</span> <span class="variable">subtask1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SumTask</span>(<span class="built_in">this</span>.array, start, middle);</span><br><span class="line">        <span class="type">SumTask</span> <span class="variable">subtask2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SumTask</span>(<span class="built_in">this</span>.array, middle, end);</span><br><span class="line">        invokeAll(subtask1, subtask2);</span><br><span class="line">        <span class="type">Long</span> <span class="variable">subresult1</span> <span class="operator">=</span> subtask1.join();</span><br><span class="line">        <span class="type">Long</span> <span class="variable">subresult2</span> <span class="operator">=</span> subtask2.join();</span><br><span class="line">        <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> subresult1 + subresult2;</span><br><span class="line">        System.out.println(<span class="string">&quot;result = &quot;</span> + subresult1 + <span class="string">&quot; + &quot;</span> + subresult2 + <span class="string">&quot; ==&gt; &quot;</span> + result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>观察上述代码的执行过程，一个大的计算任务0<del>2000首先分裂为两个小任务0</del>1000和1000<del>2000，这两个小任务仍然太大，继续分裂为更小的0</del>500，500<del>1000，1000</del>1500，1500~2000，最后，计算结果被依次合并，得到最终结果。</p>
<blockquote>
<p>该例子并不适用，因为本质是同源的，多线程最大的优势是在应用不同源。</p>
</blockquote>
<blockquote>
<p>同源：每次切换一个线程加一点数，和一次加完所有的数是一样的（也不一定，多核CPU下，当然是一个任务能占据更多核速度最快）。</p>
<p>不同源：每次切换一个线程和不同“服务”通信，所有服务并行执行。</p>
</blockquote>
<p>Fork&#x2F;Join线程池在Java标准库中就有应用。</p>
<p>Java标准库提供的<code>java.util.Arrays.parallelSort(array)</code>可以进行并行排序，它的原理就是内部通过Fork&#x2F;Join对大数组分拆进行并行排序，在多核CPU上就可以大大提高排序的速度。</p>
<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>多线程是Java实现多任务的基础。</p>
<p><strong>获取多线程id</strong></p>
<p><code>Thread</code>对象代表一个线程，我们可以在代码中调用<code>Thread.currentThread()</code>获取当前线程。</p>
<p><strong>传递状态</strong></p>
<p>通常一个任务需要多个方法完成，对象如何在多个方法中传递相同的状态？</p>
<p>定义一个对象属性？多线程共享会不一致该怎么办？</p>
<p>Java标准库提供了一个特殊的<code>ThreadLocal</code>，它可以确保每一个线程中都维护各自的一个对象属性值。</p>
<p><code>ThreadLocal</code>实例通常总是以<strong>静态字段初始化</strong>如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> ThreadLocal&lt;User&gt; threadLocalUser = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p><strong>使用方式</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加载器</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">processUser</span><span class="params">(user)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        threadLocalUser.set(user);</span><br><span class="line">        step1();</span><br><span class="line">        step2();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        threadLocalUser.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以把<code>ThreadLocal</code>看成一个全局<code>Map&lt;Thread, Object&gt;</code>：每个线程获取<code>ThreadLocal</code>变量时，总是使用<code>Thread</code>自身作为key：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">threadLocalValue</span> <span class="operator">=</span> threadLocalMap.get(Thread.currentThread());</span><br></pre></td></tr></table></figure>

<p>因此，<code>ThreadLocal</code>相当于给每个线程都开辟了一个独立的存储空间，各个线程的<code>ThreadLocal</code>关联的实例互不干扰。</p>
<p>最后，特别注意<code>ThreadLocal</code>一定要在<code>finally</code>中清除：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    threadLocalUser.set(user);</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    threadLocalUser.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是因为当前线程执行完相关代码后，很可能会被重新放入线程池中，如果<code>ThreadLocal</code>没有被清除，该线程执行其他代码时，会把上一次的状态带进去。</p>
<p>而且 ThreadLocal 可以维护的线程数是有限的，如果超出了限制，会造成内存污染，共用一个对象的情况。</p>
<p><strong>实现 AutoCloseable 接口</strong></p>
<p>为了保证能释放<code>ThreadLocal</code>关联的实例，我们可以通过<code>AutoCloseable</code>接口配合<code>try (resource) &#123;...&#125;</code>结构，让编译器自动为我们关闭。</p>
<p>例如，将用于保存当前用户名的<code>ThreadLocal</code>封装为一个<code>UserContext</code>对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserContext</span> <span class="keyword">implements</span> <span class="title class_">AutoCloseable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; ctx = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserContext</span><span class="params">(String user)</span> &#123;</span><br><span class="line">        ctx.set(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">currentUser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ctx.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        ctx.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用的时候，我们借助<code>try (resource) &#123;...&#125;</code>结构，可以这么写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try (var ctx = new UserContext(&quot;Bob&quot;)) &#123;</span><br><span class="line">    // 可任意调用UserContext.currentUser():</span><br><span class="line">    String currentUser = UserContext.currentUser();</span><br><span class="line">&#125; // 在此自动调用UserContext.close()方法释放ThreadLocal关联对象</span><br></pre></td></tr></table></figure>

<p>将 UserContext 实例对象的作用限定在 try {} 中，当离开作用域时自动回收该实例，并调用 close 方法移除 ThreadLocal 关联对象（有点像析构方法接口）。</p>
<h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><h2 id="易混概念"><a href="#易混概念" class="headerlink" title="易混概念"></a>易混概念</h2><ol>
<li>主类: 所有定义了main方法的类叫做主类，开发者常在类中定义main方法，用来调试代码</li>
<li>在基本数据类型变量声明时，不能用占用内存大的值赋给占用内存小的变量类型，如 float a &#x3D; 1.19; 1.19 默认是double型，因此该语句会编译出错; &#x3D;&#x3D;2e9&#x3D;&#x3D;科学计数，默认也是double型!!!</li>
<li>使用…声明可变长参数，如int sort(int… a);</li>
<li>命令行参数</li>
</ol>
<blockquote>
<p>各个类的main方法可以相互调用</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(String str: args) &#123;</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] strs = &#123;<span class="string">&quot;hello&quot;</span>，<span class="string">&quot;world&quot;</span>&#125;;</span><br><span class="line">        B.main(strs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>重载是&#x3D;&#x3D;多态&#x3D;&#x3D;的一种。</li>
<li>不管是继承还是实现接口，重写方法时都不可以降低方法的可见性（Visiability）</li>
</ol>
<blockquote>
<p>如：继承的public方法不能重写为protected方法，但是protected方法重写后可改为public。</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Redisson分布式锁、联锁</title>
    <url>/2024/03/29/240329/</url>
    <content><![CDATA[<h1 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h1><h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><ol>
<li>引入依赖</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.13.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>配置 RedissonClient</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedissonConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedissonClient <span class="title function_">redissonClient</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        <span class="comment">// 配置redis地址</span></span><br><span class="line">        config.useSingleServer()</span><br><span class="line">            .setAddress(<span class="string">&quot;redis://192.168.59.128:6379&quot;</span>)</span><br><span class="line">            .setPassword(<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建redisson客户端</span></span><br><span class="line">        <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>获取锁</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> RedissonClient.getLock(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">lock.tryLock();</span><br><span class="line">lock.unlock();</span><br></pre></td></tr></table></figure>

<h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><ol>
<li><p>可重入</p>
<p>将存储结构改为 Hash 类型，field 为线程标识，value 为重入次数，记录锁重入的次数并每次重入刷新有效期。</p>
<p>释放锁的时候判断是否重入次数变为0，否则-1</p>
</li>
<li><p>可重试</p>
<p>允许设置 waitTime，在等待时间范围内不断重新获取锁</p>
</li>
<li><p>超时释放</p>
<p>设立 watchdog 任务机制，只要服务还在进行就不停续约，如果服务宕机就会过期释放</p>
</li>
<li><p>联锁</p>
<p>允许使用多个 Redis 节点，必须在所有节点获取到锁才算成功，如果有一个节点宕机即使主从不一致，也无法从一个节点就获取到锁。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>每日总结</category>
      </categories>
      <tags>
        <tag>Redisson</tag>
        <tag>Watchdog</tag>
        <tag>Redis</tag>
        <tag>分布式锁</tag>
        <tag>联锁</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux，分布式锁</title>
    <url>/2024/03/28/240328/</url>
    <content><![CDATA[<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>链接文件：一个可以“通向”其他文件的文件。</p>
<p>分为 软链接 和 硬链接。</p>
<p><strong>软链接：</strong>类似 Windows 的快捷方式，不是一个实质的文件，当链接的文件被销毁后，也就失去作用了</p>
<p><strong>硬链接：</strong>直接和 另一个文件 通向 相同的内存，和链接的文件共享文件内容，这边修改了那边也会跟着变</p>
<blockquote>
<p>和 Docker 的 Volume 有点像</p>
</blockquote>
<p><strong>命令</strong>：<code>ln -s &lt;linked&gt; &lt;link&gt;</code></p>
<p>s: symbolic 符号，表示创建软链接（符号链接）</p>
<p>如 ln b.txt a.txt：创建 a 对 b 的硬链接。</p>
<p><strong>注意：</strong>硬链接不能指向目录，因为目录只是一个层级，不是文件，无法让你修改。</p>
<h3 id="vi编辑器"><a href="#vi编辑器" class="headerlink" title="vi编辑器"></a>vi编辑器</h3><p>打开方式：<code>vi &lt;file&gt;</code> </p>
<p>如果文件不存在则会创建新文件。</p>
<p>vim编辑器中分为三种状态 </p>
<ol>
<li>命令模式，按下按键不会输入字符，而是执行命令。</li>
<li>输入模式，可以插入字符</li>
<li>底线命令模式，在界面最低端，输入命令执行相应操作</li>
</ol>
<p><strong>命令模式常用</strong></p>
<ol>
<li>i、a、o，分别是在光标当前、随后、下一行进入输入模式，可以输入字符</li>
<li>u，复原操作</li>
<li>dd，删除这一行</li>
<li><code>:</code>，切换到底线命令模式</li>
</ol>
<p><strong>输入模式常用</strong></p>
<ol>
<li>ctrl + u，撤回操作</li>
</ol>
<p><strong>底线命令模式</strong></p>
<ol>
<li>q 退出</li>
<li>q！强制退出，加一个！表示强制的意思</li>
<li>w 保存</li>
<li>wq 保存退出</li>
<li>！暂时离开进入terminal查看信息</li>
<li>set nu 显示行号</li>
<li>set nonu 取消显示行号</li>
</ol>
<h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><p>在集群部署的情况下，保证某个操作只能单线程执行。</p>
<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a><strong>实现方式</strong></h3><ol>
<li>MySQL 本身的互斥锁机制（还没学）</li>
<li>Redis setnx 互斥命令</li>
<li>zookeeper 唯一有序节点</li>
</ol>
<p><strong>定义 Lock 接口</strong></p>
<ul>
<li><p><code>boolean tryLock(long timeSec)</code> 尝试获取锁，并设置过期时间，防止服务宕机造成死锁</p>
<blockquote>
<p>MySQL 断连会自动释放，zookeeper 是临时节点</p>
</blockquote>
</li>
<li><p><code>void unlock()</code></p>
</li>
</ul>
<h3 id="防止误删"><a href="#防止误删" class="headerlink" title="防止误删"></a><strong>防止误删</strong></h3><p>如果某次操作执行非常慢或者被阻塞了，导致他获取的锁被过期释放了，此时其他线程获取到了新的锁，但由于锁的 key 都是一致的，最后这个被阻塞的操作完成后会误删了其他线程的锁。</p>
<p><strong>一、给锁加上标识</strong></p>
<p>为了误删其他线程的锁，需要再释放之前，判断这把锁是否是为当前线程的锁。</p>
<p>利用 UUID + 线程id 生成不同服务器不同的标识</p>
<blockquote>
<p>如果只用id的话，由于这个id是顺序生成的，不同服务器之间会冲突。</p>
</blockquote>
<p><strong>二、原子性</strong></p>
<p>既然出现了判断，就会有数据不一致的并发问题。</p>
<p>如果因为 JVM 的 GC 垃圾回收等机制造成了阻塞，导致在判断完之后锁又过期的情况下，又会误删其他线程的锁。</p>
<p>因此，需要保证 判断 和 释放 两个操作的原子性。</p>
<p>这里采用脱离 JVM，让 Redis 执行 lua 脚本的方法。</p>
<p>实现步骤：</p>
<ol>
<li>编写 lua 脚本</li>
<li>借助 StringRedisTemplate 的 execute 方法执行脚本</li>
</ol>
<blockquote>
<p>Redis 会不会产生数据不一致的问题，在查询到标识之后被其他线程改了？多线程？</p>
</blockquote>
<p>Redis 在 5 版本之前都是单线程的，而且事务保证了原子性。</p>
]]></content>
      <categories>
        <category>每日总结</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>分布式锁</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux；锁、并发</title>
    <url>/2024/03/28/240327/</url>
    <content><![CDATA[<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><h3 id="开关机"><a href="#开关机" class="headerlink" title="开关机"></a>开关机</h3><p><code>shutdown -h &lt;time&gt;</code> </p>
<p>h: halt 停止</p>
<p>这里的 time 可以是数字（分钟），也可以是时间（时:分），还可以是 now （等时间说明？）</p>
<p><code>shutdown -r &lt;time&gt;</code></p>
<p>r: reboot 重启</p>
<p>time 同上方命令</p>
<p><code>reboot</code> ：直接重启</p>
<p><code>halt</code>、<code>poweroff</code>：关闭系统，等同于 <code>shutdown -h now</code></p>
<p><code>sync</code> ：将内存数据同步到硬盘，关机重启前应执行此命令保证数据不被丢失。</p>
<h3 id="目录管理"><a href="#目录管理" class="headerlink" title="目录管理"></a>目录管理</h3><p><strong>目录操作</strong></p>
<p><code>mkdir -p &lt;file&gt;</code> </p>
<p>p: parent 父级</p>
<p>创建目录，可以选择添加 p 参数创建多级目录</p>
<p><code>rmdir -p &lt;file&gt;</code></p>
<p>删除目录，可以选择添加 p 参数删除多级目录（目录不为空无法删除）</p>
<p><code>rm -rfi &lt;file / path&gt;</code></p>
<p>r: recursive 递归</p>
<p>f: force 强制</p>
<p>i: interactive 交互（询问是否删除）</p>
<blockquote>
<p>linux 中命令参数可以合并在一起写，所以写成了 -rfi</p>
</blockquote>
<p>删除文件或目录</p>
<p><code>pwd</code>：print working directory 打印当前目录</p>
<p><strong>列出目录内容</strong></p>
<p><code>ls -al</code> 列举目录内容</p>
<p>a: all 全部</p>
<p>l: long 长格式（详细信息：权限、属主、分组、大小、创建时间、名称）</p>
<p><code>ll</code> 列出目录内详细，等同于 <code>ls -l</code></p>
<h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><p><strong>权限管理</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-rwxr-xr-x. 2 root root   24 3月   7 11:13 nacos.txt</span><br><span class="line">drwxr-xr-x. 3 root root   59 3月  18 13:44 nginx</span><br></pre></td></tr></table></figure>

<p><code>- rwx rwx rwx</code> 可以分为 4 组</p>
<p>第一组：文件类型，- 表示这是一个可执行文件，d 表示目录，l 表示链接（软 &#x2F; 硬）</p>
<p>第二、三、四组：当前用户、所属用户、分组用户可操作的文件权限</p>
<p>第一个root：创建用户</p>
<p>第二个root：分组</p>
<p>r：读，w：写，x：执行 execute</p>
<p><code>chgrp &lt;group&gt; &lt;file&gt;</code> 修改文件分组</p>
<p><code>chmod (rwx)(rwx)(rwx) &lt;file&gt;</code> 修改文件对应当前、属主、分组的可操作权限</p>
<p>这里的 rwx 分别用对应数字的累加来声明</p>
<p>r：4，w：2，x：1</p>
<blockquote>
<p>为什么 r 是 4 ？</p>
<p>因为如果是 3，会出现组合重复，r: 3 等同 wx: 3</p>
</blockquote>
<p>如 <code>chmod 775 file</code> </p>
<p>表示当前用户权限：r+w+x &#x3D; 7</p>
<p>表示创建用户权限：r+w+x &#x3D; 7</p>
<p>表示分组用户权限：r+w+0 &#x3D; 5</p>
<p><strong>文件查看</strong></p>
<p><code>cat</code> 从上往下打印文件内容，<code>tac</code> 倒序打印，cat反过来</p>
<p><code>less、more</code> 分页显示文件内容</p>
<p>less 区别于 more，less 可以上下翻页 “PageUp”，“PagesDown” 按键和上下单行移动 “ArrowUp”，“ArrowDown” 按键。</p>
<p>操作：</p>
<ul>
<li>空格翻页</li>
<li>回车显示下一行</li>
<li>输入 &#x2F;xxx，查询 xxx ，<strong>less 才能查</strong>，n 向上搜索，N 向下搜索</li>
<li>q 退出分页查看</li>
</ul>
<p><code>head / tail -n &lt;line&gt; &lt;file&gt;</code> 分别显示头尾 n 行</p>
<p><code>nl &lt;file&gt;</code> 输出文件内容，并标注行号</p>
<h2 id="对并发的理解"><a href="#对并发的理解" class="headerlink" title="对并发的理解"></a>对并发的理解</h2><p>什么时候需要考虑并发：</p>
<ol>
<li>涉及数据一致性</li>
<li>涉及数据库操作</li>
</ol>
<p>并发在哪里产生问题：</p>
<ol>
<li>“判断”：只要同时存在多个线程绕过这个限制，就会出现并发问题</li>
</ol>
<p>如何处理并发问题：“锁”</p>
<ol>
<li>悲观锁：全程阻塞，整个过程保证同时只有一个线程。</li>
<li>乐观锁：阻塞不符合条件的线程。</li>
<li>id锁：保证同时只有一个线程访问这个id。</li>
</ol>
<h2 id="订单超卖"><a href="#订单超卖" class="headerlink" title="订单超卖"></a>订单超卖</h2><p>场景描述：一共只有 100 份，却卖出了 110 份，这就是超卖。</p>
<p>造成原因：高并发，一份的空隙被 10 个用户绕了过去，同时进行了操作。</p>
<p>解决办法：</p>
<ol>
<li>全程加锁，限制同时只能有一份被一个用户操作，但是<strong>效率太低</strong>。</li>
<li>乐观锁，只要没有超出限制，就允许同时操作，保证了效率和业务正常。</li>
</ol>
]]></content>
      <categories>
        <category>每日总结</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>并发</tag>
        <tag>锁</tag>
        <tag>订单超卖</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux学习第一天</title>
    <url>/2024/03/27/Linux-1/</url>
    <content><![CDATA[<h2 id="开关机"><a href="#开关机" class="headerlink" title="开关机"></a>开关机</h2><p><code>shutdown -h &lt;time&gt;</code> </p>
<p>h: halt 停止</p>
<p>这里的 time 可以是数字（分钟），也可以是时间（时:分），还可以是 now （等时间说明？）</p>
<p><code>shutdown -r &lt;time&gt;</code></p>
<p>r: reboot 重启</p>
<p>time 同上方命令</p>
<p><code>reboot</code> ：直接重启</p>
<p><code>halt</code>、<code>poweroff</code>：关闭系统，等同于 <code>shutdown -h now</code></p>
<p><code>sync</code> ：将内存数据同步到硬盘，关机重启前应执行此命令保证数据不被丢失。</p>
<h2 id="目录管理"><a href="#目录管理" class="headerlink" title="目录管理"></a>目录管理</h2><h3 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a><strong>目录操作</strong></h3><p><code>mkdir -p &lt;file&gt;</code> </p>
<p>p: parent 父级</p>
<p>创建目录，可以选择添加 p 参数创建多级目录</p>
<p><code>rmdir -p &lt;file&gt;</code></p>
<p>删除目录，可以选择添加 p 参数删除多级目录（目录不为空无法删除）</p>
<p><code>rm -rfi &lt;file / path&gt;</code></p>
<p>r: recursive 递归</p>
<p>f: force 强制</p>
<p>i: interactive 交互（询问是否删除）</p>
<blockquote>
<p>linux 中命令参数可以合并在一起写，所以写成了 -rfi</p>
</blockquote>
<p>删除文件或目录</p>
<p><code>pwd</code>：print working directory 打印当前目录</p>
<h3 id="列出目录内容"><a href="#列出目录内容" class="headerlink" title="列出目录内容"></a><strong>列出目录内容</strong></h3><p><code>ls -al</code> 列举目录内容</p>
<p>a: all 全部</p>
<p>l: long 长格式（详细信息：权限、属主、分组、大小、创建时间、名称）</p>
<p><code>ll</code> 列出目录内详细，等同于 <code>ls -l</code></p>
<h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><h3 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a><strong>权限管理</strong></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-rwxr-xr-x. 2 root root   24 3月   7 11:13 nacos.txt</span><br><span class="line">drwxr-xr-x. 3 root root   59 3月  18 13:44 nginx</span><br></pre></td></tr></table></figure>

<p><code>- rwx rwx rwx</code> 可以分为 4 组</p>
<p>第一组：文件类型，- 表示这是一个可执行文件，d 表示目录，l 表示链接（软 &#x2F; 硬）</p>
<p>第二、三、四组：当前用户、所属用户、分组用户可操作的文件权限</p>
<p>第一个root：创建用户</p>
<p>第二个root：分组</p>
<p>r：读，w：写，x：执行 execute</p>
<p><code>chgrp &lt;group&gt; &lt;file&gt;</code> 修改文件分组</p>
<p><code>chmod (rwx)(rwx)(rwx) &lt;file&gt;</code> 修改文件对应当前、属主、分组的可操作权限</p>
<p>这里的 rwx 分别用对应数字的累加来声明</p>
<p>r：4，w：2，x：1</p>
<blockquote>
<p>为什么 r 是 4 ？</p>
<p>因为如果是 3，会出现组合重复，r: 3 等同 wx: 3</p>
</blockquote>
<p>如 <code>chmod 775 file</code> </p>
<p>表示当前用户权限：r+w+x &#x3D; 7</p>
<p>表示创建用户权限：r+w+x &#x3D; 7</p>
<p>表示分组用户权限：r+w+0 &#x3D; 5</p>
<h3 id="文件查看"><a href="#文件查看" class="headerlink" title="文件查看"></a><strong>文件查看</strong></h3><p><code>cat</code> 从上往下打印文件内容，<code>tac</code> 倒序打印，cat反过来</p>
<p><code>less、more</code> 分页显示文件内容</p>
<p>less 区别于 more，less 可以上下翻页 “PageUp”，“PagesDown” 按键和上下单行移动 “ArrowUp”，“ArrowDown” 按键。</p>
<p>操作：</p>
<ul>
<li>空格翻页</li>
<li>回车显示下一行</li>
<li>输入 &#x2F;xxx，查询 xxx ，<strong>less 才能查</strong>，n 向上搜索，N 向下搜索</li>
<li>q 退出分页查看</li>
</ul>
<p><code>head / tail -n &lt;line&gt; &lt;file&gt;</code> 分别显示头尾 n 行</p>
<p><code>nl &lt;file&gt;</code> 输出文件内容，并标注行号</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 文件状态梳理</title>
    <url>/2024/03/25/Git-1/</url>
    <content><![CDATA[<h2 id="文件状态"><a href="#文件状态" class="headerlink" title="文件状态"></a>文件状态</h2><p><img src="/assets/image-20240325104013093.png" alt="Git文件的四种状态"></p>
<p>下面以新增 README.md 文件为例</p>
<h3 id="Untracked"><a href="#Untracked" class="headerlink" title="Untracked"></a><strong>Untracked</strong></h3><p>未被 Git 跟踪的文件状态</p>
<ol>
<li>新创建</li>
<li>从其他地方移动过来（复制 &#x2F; 剪切等）</li>
</ol>
<p><img src="/assets/image-20240325104023093.png" alt="image-20240325104023093"></p>
<h3 id="Staged"><a href="#Staged" class="headerlink" title="Staged"></a><strong>Staged</strong></h3><p>使用 <code>git add &lt;file&gt;</code> 命令将文件加入暂存区，转化为 <code>Staged</code> 状态</p>
<p><img src="/assets/image-20240325104341887.png" alt="image-20240325104341887"></p>
<p>使用 <code>git rm --cached &lt;file&gt;</code> 可以将文件移出缓存区，重新变为 <code>Untracked</code> 状态</p>
<p><img src="/assets/image-20240325104726863.png" alt="image-20240325104726863"></p>
<p><strong>文件当前内容</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">123</span><br></pre></td></tr></table></figure>



<h3 id="Modified"><a href="#Modified" class="headerlink" title="Modified"></a><strong>Modified</strong></h3><p>对 <code>Staged</code> 已经存入暂存区的文件进行修改，转化为 <code>Modified</code> 状态</p>
<p><strong>文件修改后</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">123</span><br><span class="line">restore 丢弃的内容</span><br></pre></td></tr></table></figure>

<p><img src="/assets/image-20240325105331466.png" alt="image-20240325105331466"></p>
<p>可以看到和 <code>Untracked</code> 状态一样，被 Git 标红了</p>
<p>意味着此时暂存区内该文件的内容还是 <code>123</code>，需要重新使用 <code>git add &lt;file&gt;</code> 命令将本次修改保存到 Git 中（更新 Git 的 diff 内容）。</p>
<p><strong>后续命令</strong></p>
<ul>
<li><code>git restore &lt;file&gt;</code>，丢弃本次修改，恢复到当前暂存区存取的内容（最后一次被修改之前的状态）</li>
<li><code>git checkout &lt;file&gt;</code> 等价于 restore</li>
</ul>
<p><strong>文件 restore 后</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">123</span><br></pre></td></tr></table></figure>

<p><strong>应用场景</strong></p>
<p>操作涉及 工作区 和 暂存区 两个区域。</p>
<p>当工作到某个重要节点，你需要在这个节点上进行扩展，但是你又不确定这个扩展是否可行</p>
<p>这时候就可以 “stage” 这个节点，然后继续修改，如果不可行就通过 <code>git restore &lt;file&gt;</code> 回到这个节点，丢弃掉所有修改内容。</p>
<blockquote>
<p>当然如果这个节点是重要且确定的，你可以直接 <code>git add &lt;file&gt;</code> &#x3D;&gt; <code>git commit</code> 将其提交到本次仓库中</p>
</blockquote>
<p><strong>提问</strong></p>
<ol>
<li>如果我 “stage” 了这次新的修改，原先的节点还能找到吗 :x:</li>
</ol>
<h3 id="UnModified"><a href="#UnModified" class="headerlink" title="UnModified"></a>UnModified</h3><p>将 <code>Staged</code> 状态的文件（暂存区的文件）通过 <code>git commit</code> 提交到本次仓库中，转化为 <code>Unmodified</code> 状态。</p>
<p>为了后续追踪文件内容，添加了一行 commit 标志</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">123</span><br><span class="line"></span><br><span class="line">第一次commit</span><br></pre></td></tr></table></figure>

<p><img src="/assets/image-20240325114403701.png" alt="image-20240325114403701"></p>
<p>commit 提交后，该文件就加入本地仓库了，并输出了本次 commit 的 branch（master）和 refs（9db5ee9）。</p>
<p>接下来继续对文件进行修改（工作区）、保存（暂存区）、提交（本地仓库），完成一整个流程。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">123</span><br><span class="line"></span><br><span class="line">第一次commit</span><br><span class="line"></span><br><span class="line">修改内容</span><br></pre></td></tr></table></figure>

<p><img src="/assets/image-20240325115211160.png" alt="image-20240325115211160"></p>
<h3 id="状态流程"><a href="#状态流程" class="headerlink" title="状态流程"></a><strong>状态流程</strong></h3><p><strong>新加入的文件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 首次加入</span><br><span class="line">Untracked =(add)=&gt; Staged =(self update)=&gt; Modified =(commit)=&gt; UnModified</span><br><span class="line">// 追踪更改</span><br><span class="line">=(self update)=&gt; Modified =(add)=&gt; Staged =(commit)=&gt; UnModified</span><br></pre></td></tr></table></figure>

<p><strong>已追踪的文件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 追踪更改</span><br><span class="line">=(self update)=&gt; Modified =(add)=&gt; Staged =(commit)=&gt; UnModified</span><br></pre></td></tr></table></figure>

<p>注意：未被追踪的文件，无论怎么修改都不会被 Git 管理为 Modified 文件</p>
<p><img src="/assets/image-20240326000827982.png" alt="image-20240326000827982"></p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
</search>
